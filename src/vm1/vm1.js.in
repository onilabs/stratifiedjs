/*
 * VM1 Stratified JavaScript Virtual Machine
 *
 * Part of StratifiedJS
 * http://onilabs.com/stratifiedjs
 *
 * (c) 2011-2013 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/*
Preprocessor flags:

define CLIENTSIDE    : for browser-based VM (as opposed to rocket-hosted)
define NODEJS        : for nodejs VM (as opposed to rocket/clientside)

define DEBUG_VM      : VM debugging

define HOTPATH       : don't build execution frames unless we have to

OBSOLETE FLAGS:
    verbose exceptions are always on now; not predicated on this flag anymore:
define VERBOSE_EXCEPTIONS : add line/file/stack members to exceptions
                             (requires compiling c1 with VERBOSE_EXCEPTIONS to
                              get correct values)
                             XXX We should actually only amend Error objects
                             where they are *created*. This code is possibly a
                             bit flaky with exceptions that are thrown by
                             JS code and caught/rethrown by SJS.


    we really don't want async resume:
define ASYNC_RESUME  : obsolete asynchronous resume code path

*/
#define DEBUG_VM 1
#ifdef DEBUG_VM
function dumpExecutionFrameParents(ef, indent) {
  indent = indent || 0;
  if (ef && ef.parent)
    dumpExecutionFrameParents(ef.parent, indent+1);
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<undefined>';
  console.log(str);
}
function dumpExecutionFrameChildren(ef, indent) {
  indent = indent || 0;
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<undefined>';
  console.log(str);
  if (ef && ef.child_frame)
    dumpExecutionFrameChildren(ef.child_frame, indent+1);
  else if (ef && ef.children) {
    for (var i = 0; i<ef.children.length; ++i) {
      dumpExecutionFrameChildren(ef.children[i], indent+1);
    }
  }
}
#define EF_TYPES
#define LOG(x) console.log(x);
// XXX figure out why normal CPP stringification is screwed
#define ASSERT(X) if(!(X)) { console.log("Assertion failed: " + "X" ); throw new Error("Assertion failed: " + "X")}
#define WHENDEBUG(X) X
#else
#define ASSERT(X)
#define LOG(x)
#define WHENDEBUG(X)
#endif

// we don't want to rely on the global 'undefined' symbol; see
// https://groups.google.com/d/msg/oni-apollo/fNMz2W8S5mU/sYCgrriYj1MJ
var UNDEF; // == undefined

// on firefox this seems to help, on v8 it doesn't :-/
//define HOTPATH 1

// maximum size of callstack that we'll record in tail-recursive scenarios:
#define MAX_CALLSTACK 20


function dummy() {}


//----------------------------------------------------------------------

#if defined (CLIENTSIDE)
exports.G = window;
#elif defined (NODEJS)
exports.G = global;
#endif

// XXX
var nextTick;
if (exports.G.nextTick) {
  nextTick  = exports.G.nextTick;
}
else if (exports.G.Promise) {
 nextTick = function(cb) { Promise.resolve().then(cb); };
}
else throw new Error("host environment not supported - need 'Promise' or 'nextTick'");


//----------------------------------------------------------------------

//XXX NEEDED FOR ANYTHING IN THE LIB? #define is_stratum(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_stratum)


//----------------------------------------------------------------------
// Control Flow Exceptions

/*
{
  __oni_cfx: true,
  type:      "i"(internal)|"r"(return)|"b"(break)|"c"(continue)|"t"(thrown)|"blb"(blklambda break)|"blb_int"(internal blocklambda break),
  val:       value
}
*/

// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_cfx(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_cfx)
// define is_cfx(obj) (obj instanceof CFException)
/*function is_cfx(obj) {
  return obj && obj.__oni_cfx;
}*/

function stack_to_string(stack) {
  var rv = '';
  if (stack) {
    for (var i=0; i<stack.length; ++i) {
      var line = stack[i];
      if (line.length == 1)
        line = line[0];
      else
        line = '    at ' + line.slice(0,2).join(':');
      rv += '\n' + line;
    }
  }
  return rv;
}

function CFException_toString() {
  return this.name+": "+this.message + stack_to_string(this.__oni_stack);
}

function adopt_native_stack(e, caller_module) {
  if(!e.stack)
    return;
  var stack = String(e.stack);
  // Remove default toString() output, which can take form:
  // - <msg>
  // - <type>
  // - <type>: <msg>
  var firstColon = stack.indexOf(': ');
  var msgStart = (firstColon === -1) ? 0 : firstColon + 2;
  
  // if firstColon appears after a newline, it's not the one we want
  if (stack.lastIndexOf('\n', msgStart) !== -1) msgStart = 0;

  var msg = String(e.message);
  if (msg && stack.lastIndexOf(msg, msgStart) == msgStart) {
    stack = stack.slice(msgStart + msg.length);
  } else {
    // remove sole <type>, assuming type ends with 'Error'
    stack = stack.replace(/^\w*Error/, '');
  }
  delete e.stack;
  var lines = stack.split("\n");
  var i;
  for (i=0; i<lines.length; i++) {
    var line = lines[i];
    if (!line.length) continue;
    // TODO: make this check more reliable
    if((caller_module && line.indexOf(caller_module) !== -1) ||
       line.indexOf(".app!bundle") !== -1 ||
       line.indexOf("stratified-node.js") !== -1 ||
       line.indexOf("stratified.js") !== -1 ) {
      // we've hit an sjs stack line.
      break;
    }
    e.__oni_stack.push([line]);
  }
}

var token_oniE = {}; // oni-modified exception
function CFException(type, value, line, file) {
  this.type = type;
  this.val = value;
  // XXX checking for "value instanceof Error" alone doesn't work for some errors on firefox
  if (type === "t" && 
      (value instanceof Error || (typeof value === 'object' && value != null && value.message))) {
    if (value._oniE !== token_oniE) {
      // annotate the exception object with our oni-special fields:
      value._oniE = token_oniE;
      value.__oni_stack = value.__oni_stack || [];
      value.line = line;
      value.file = file || "unknown SJS source";

      adopt_native_stack(value, file);

      if (!value.hasOwnProperty('toString')) value.toString = CFException_toString;
    }

    // push current line/file onto stack (if provided):
    if (line)
      value.__oni_stack.push([file || 'unknown SJS source', line]);
  }
  // this.eid = UNDEF;  // 'execution frame' tag for targetted return/break/continue
}

var CFETypes = { r:"return", b:"break", c:"continue", blb_old: "blocklambda break old", blb: "blocklambda break", blb_int: "internal blocklambda break"};
CFException.prototype = {
  __oni_cfx : true,
  toString : function() {
    if (this.type in CFETypes)
      return "Unexpected "+CFETypes[this.type]+" statement";
    else
      return "Uncaught internal SJS control flow exception ("+this.type+":: "+this.val+")";
  },
  mapToJS : function(uncaught) {
    if (this.type == "t") {
#if defined (CLIENTSIDE)
      // 'uncaught' means we know this exception won't be caught by SJS.
      // We could throw a plain JS error, but browsers have terrible reporting.
      // Instead, we emulate a good browser's onError handling, with full stack
      // logging on an unhandled error.
      // See https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror
      // XXX is there anything browsers do internally to handle errors other than calling onerror?
      if (uncaught && this.val != null && this.val.__oni_stack) {
        var handler = window.onerror;
        var handled = false;
        var msg = this.val.toString();

        if (handler) {
          // we could probably extract a proper url & lineno here,
          // but who cares when we have the entire stacktrace?
          handled = handler.call(window,
              msg,
              "", // url
              0,  // lineno
              0,  // column
              this.val); // exception
        }
        if (!handled) {
          if (console) {
            if (console.error) console.error(msg);
            else console.log(msg);
          }
        }
      }
      else
#endif // CLIENTSIDE
        throw this.val;
    }
    else if (this.type === 'blb') {
      throw this;
    }
    else if (!this.eid) // XXX DO WE NEED THIS???
      throw new Error(this.toString());
    else // this is a 'blb' or 'r' tunneling through a JS functions:
      throw this;
  }
};


// In certain cases where an exception might be picked up several times via different routes (as in
// stratum.value(), we need to make sure that we don't get crosstalk between differently 
// amended stacks.
// For this purpose, we clone exceptions in these cases.
// XXX Note that this will break certain *very unlikely* pathological programming patterns that check 
// an exception for strict equality. Checking for `instanceof` (as would be more common) will still 
// work, and this only affects exceptions that inherit from `Error` (as these are the only ones we 
// annotate in the first place).
// 
#define is_annotated_oni_cfx(obj) (is_cfx(obj) && obj.type === 't' && obj.val != null && obj.val._oniE === token_oniE)

function cloneAnnotatedCFX(obj) { 
  // ASSERT(is_annotated_oni_cfx(obj)) // caller to ensure this
  obj = new CFException('t', Object.create(obj.val));
  obj.val.toString = CFException_toString;
  // The following are necessary to fix cloned JS errors being reported as 'illegal invocation':
  // XXX alternatively we could use an amended CFException_toString, but it's tricky to get
  // that to work with exceptions that are cloned multiple levels deep (if there are such exceptions?)
  Object.defineProperty(obj.val, 'name', { get: function() { return this.__proto__.name; } });
  Object.defineProperty(obj.val, 'message', { get: function() { return this.__proto__.message; }});

  // make sure that the new exceptions gets its own __oni_stack property:
  obj.val.__oni_stack = [].concat(obj.val.__oni_stack);
  return obj;
}


//----------------------------------------------------------------------
// Dynamic variable support:

// current_dyn_vars is a global variable holding dynamic variable
// bindings for the currently stratum. It will be manipulated by the
// VM when a stratum switch takes place:
// We cannot use 'Env' for this, because environments get reset at every function
// boundary (to support SJS being callable from JS)
exports.current_dyn_vars = null; 

//----------------------------------------------------------------------
// Callstack support:

// current_call is set to [file,lineno] for every Fcall & I_call 
// This is used to extract stack information for stratum calls (spawn/adopt):
exports.current_call = null;

//----------------------------------------------------------------------
// Execution Frames

/*
  Note on `ReturnToParentContinuation` & global `cont` function

  In SJS, we can (asynchronously) build large execution frame trees in
  a tail-safe way. To ensure that we we can also unravel these trees
  without blowing the JS stack (by a long chain of
  cont-returnToParent-cont-returnToParent-... calls), we need to code
  calls that tear down a tree in continuation passing style.

  Grep the code for ReturnToParentContinuation for more notes.

*/
#define is_returnToParent(obj) (obj && obj.__oni_rtpc)
function ReturnToParentContinuation(frame, idx, val) {
  this.frame = frame;
  this.idx = idx;
  this.val = val;
}
ReturnToParentContinuation.prototype = {
  __oni_rtpc: true,
  execute: function() { return this.frame.cont(this.idx, this.val) }
};

/*
  Execution frames' `cont` methods should never be called directly,
  but always be through this global function. It takes care of
  executing any `ReturnToParentContinuation`s that the callee might
  return.
*/
function cont(frame, idx, val) {
  var rv = frame.cont(idx, val);
  while (is_returnToParent(rv)) {
    rv = rv.execute();
  }
  return rv;
}

exports.is_ef = function(obj) {
  return obj && obj.__oni_ef;
}
// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_ef(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_ef===true)

function setEFProto(t) { for (var p in EF_Proto) t[p] = EF_Proto[p]; }
//function setEFProto(t) { t.__proto__ = EF_Proto; }


// helper to merge callstacks of two execution frames:
function mergeCallstacks(target_ef, src_ef) {
  // prevent duplication of the callstack if the frames are the same:
  if (target_ef === src_ef) return;
  if (target_ef.callstack) {
    // stack-tests 17
    
    // concat stacks; potentially dropping frames in the middle if
    // we go above MAX_CALLSTACK:
    target_ef.callstack = target_ef.callstack.concat(src_ef.callstack);
    if (target_ef.callstack.length > MAX_CALLSTACK)
      target_ef.callstack.splice(MAX_CALLSTACK/2, 
                                 target_ef.callstack.length-MAX_CALLSTACK+1, 
                                 ['    ...(frames omitted)']);
  }
  else {
    // stack-tests 16
    target_ef.callstack = src_ef.callstack;
  }
}

// base prototype object for execution frames
var EF_Proto = {
#ifdef EF_TYPES
  toString: function() { var rv = "<"+(typeof(this.type) === 'function' ? this.type() : this.type)+""+(this.id ? this.id:'')+((this.env && this.env.file) ? '@'+this.env.file.substr(-20): '')+">";
                         if (this.callstack)
                           rv += '[' + this.callstack.join(' > ') + ']';
                         return rv;
 },
#else
  toString: function() { return "<suspended SJS>"; },
#endif
  __oni_ef : true,

  wait: function() { return this; },

#ifdef DEBUG_VM
  gatherSuspensionTree: function() {
    try {
    return (this.callstack||[]).concat(this.child_frame ? this.child_frame.gatherSuspensionTree() : []);
    }
    catch (e) {
      console.log("ERROR GATHERING SUSPENSION TREE FOR "+this.child_frame);
      throw e;
    }
  },
#endif

  setChildFrame: function(ef, idx, prevent_callstack_copy) {
    if (this.child_frame) {
      if (prevent_callstack_copy !== true && this.child_frame.callstack) {
        // merge callstacks of old & new childframes:
        mergeCallstacks(ef, this.child_frame);
      }
      this.child_frame.parent = UNDEF;
    }
    this.async = true;
    this.child_frame = ef;
    ef.parent = this;
    ef.parent_idx = idx;
  },

  // quench reentrant resume calls.
  // This signal is issued before abort() calls, to prevent any resume() calls in our
  // call tree from firing, in case they are reentrantly executed by finally-code 
  // in our call tree. See also the tertiary waitfor/and/or sjs-testsuite testcases
  // 153-156.
  quench: function() {
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'abort'
    if (this.child_frame) 
      this.child_frame.quench();
  },

  // abort must either return 'this' (if we need to wait), or a controlflow exception
  abort: function(pseudo_abort) {
#ifdef DEBUG_VM
    if (this.aborted) {
      console.log('ERROR: '+this + ': redundant abort');
    }
    // leave the assert, so that the process exits:
    ASSERT(!this.aborted);
#endif
    this.aborted = true;
    this.pseudo_abort = pseudo_abort;
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'quench'
    if (!this.child_frame) {
      // reentrant abortion
      return this;
    }
    else {
      var abort_val = this.child_frame.abort(pseudo_abort);
      if (is_ef(abort_val)) {
        return this; // need to stay in picture because abort must not return child frame
      }
      else {
        if (is_annotated_oni_cfx(abort_val) && this.callstack) {
          abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }

        // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
        this.unreturnable = true;
        return abort_val;
      }
    }
  },

  returnToParent: function(val) {
#ifdef DEBUG_VM_X
    // We currently call returnToParent prematurely under various reentrancy scenarios in
    // Alt, Par, and Spawn.
    // XXX This is wrong and extremely fragile and needs a rewrite at some point.
    if (this.__rtp_called) {
      console.log(this + ": redundant call to returnToParent("+val+")");
    }
    else {
      this.__rtp_called = true;
    }
#endif

    if(is_cfx(val) && val.type == 't' && this.callstack && val.val!=null && val.val.__oni_stack) {
      val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
    }
    if (this.swallow_r) {
      if (is_cfx(val)) {
        if (val.type === "r") {
          if (!val.eid || val.eid === this.sid) {
            val = val.val;
            if (this.swallow_r === 3) {
              // we've received a tail-called 'return' that shouldn't
              // be returned via the present function. see also notes below
              val = UNDEF;
            }
          }
        }
      }
      else if (is_ef(val)) {
        // we're tailcalling the ef 'val' through ef 'this'. I.e. ef
        // 'this' is dropping out of the picture.

        // We have to ensure that ef 'val' gets a 'swallow_r' policy consistent with that of ef 'this'.
        // In particular, we want 'val' to have the same 'swallow_r' as 'this', with the exception where
        // 'this' is a tail-called function (this.tailcall === true) that is set to return proper 
        // returns only (this.swallow_r === 1) and val is *also* already set up to swallow returns (i.e. it is/was a functional context too). In this case we want to convert any 'returns' emitted
        // by ef 'val' to undef (i.e. set val.swallow_r to 3).
        // The swallow_r special casing fixes sjs-2-tests.sjs:async return propagation and
        // sjs-2-tests.sjs:return propagation from suspended blocklambda

        if (this.swallow_r === 1 && val.swallow_r && this.tailcall) {
          val.swallow_r = 3;
        }
        else {
          val.swallow_r = this.swallow_r; // just pass down flag to child
        }
      }
      else if (this.swallow_r !== 2) {
        val = UNDEF; // only 'return' returns a value to parent
      }
    }
  
    // Mark this frame as unreturnable. This is used by
    // blocklambdas to determine if the lexical function container is
    // still alive.
    this.unreturnable = true;

    // a little cleanup which might aid GC:
    // XXX this breaks function-tests.sjs:exclusive
    // this.env = UNDEF;

    if (this.async) {
      if (this.parent) {
        // we would like to call 
        //   this.parent.cont(this.parent_idx, val) 
        // here, but this might blow the JS stack.
        // We encode in continuation-passing style instead; the topmost `cont`
        // parent of this code path knows how to handle 
        // ReturnToParentContinuation
        return new ReturnToParentContinuation(this.parent, this.parent_idx, val);

        // remove parent to aid gc; we can only do this if val != this
        // (par and alt call through returnToParent via abortInner, which in the 
        // async case returns their own EF)
        // XXX empirically this doesn't seem to help much 
        // if (val !== this) this.parent = UNDEF;
      }
      else // noone waiting for result; make sure exceptions get reported
        if (is_cfx(val)) {
          //console.log("UNREPORTED EXCEPTION IN "+this+":"+val.type+" eid="+val.eid);
          val.mapToJS(true);
        }
    }
    else // sync context
      return val;
  }

};
//EF_Proto.__proto__ = null;


//----------------------------------------------------------------------
// 'overrides' for parallel execution nodes (EF_Par, EF_Alt, EF_WfW, EF_Reified):
// XXX these should really be refactored into a separate 'EF_ParProto' baseclass
// XXX only works for array children (not Map)

// quenchPar works for array
function quenchPar() {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench', sjs-3-tests:'waitfor/while:reentrant quench'
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally
  for (var child of this.children) {
    if (child)
      child.quench();
  }

};

// parallel setChildFrame version
function setChildFramePar(ef, idx) {
  if (this.children[idx]) {
    if (this.children[idx].callstack) {
      // merge callstacks of old & new childframes (stack-tests 28,29)
      mergeCallstacks(ef, this.children[idx]);
    }
    this.children[idx].parent = UNDEF;
  }
  this.children[idx] = ef;
  ef.parent = this;
  ef.parent_idx = idx;
}




//----------------------------------------------------------------------
// Instruction nodes

// Token which identifies an object as an instruction node
// dispatcher (obj.__oni_dis == token_dis)
var token_dis = {};

// execute an instruction node without mapping exceptions:
function execIN(node, env) {
  if (!node || node.__oni_dis != token_dis) {
    return node; // a literal value
  }
  return node.exec(node.ndata, env);
}
exports.ex = execIN;

// function bodies: create a seq and exec it. map exceptions.
// short for __oni_rt.exec(__oni_rt.Seq(...), aobj, thisobj, file)
// aobj: effective `arguments`
// tobj: effective `this`
exports.exseq = function(aobj,tobj,file, args) {
  var rv = I_seq(args, new Env(aobj,tobj,file));
//  var rv = (new EF_Seq(args, new Env(aobj,tobj,file))).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS(); // throw exceptions, so that we can call this from normal js
  return rv;
};

// reified function body:
exports.exrseq = function(aobj,tobj,file,args) {
  var rv = I_reifiedseq(args, new Env(aobj,tobj,file));
  if (is_cfx(rv))
    return rv.mapToJS(); // throw exceptions, so that we can call this from normal js
  return rv;
};

// block lambda bodies: create a blseq and exec it. XXX don't map exceptions?
// short for __oni_rt.exec(__oni_rt.Seq(...), env)
exports.exbl = function(env, args) {
  var rv = I_blseq(args, env);
//  var rv = (new EF_Seq(args, env)).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS();
  return rv;
};

var StratumAborted = exports.StratumAborted = function() {}
StratumAborted.prototype = new Error("stratum aborted");


//   exec: instruction executor function
//   returns IN constructor function which returns a instruction object
// For some reason instruction objects created directly without makeINCtor execute slightly faster on chrome and ff 
// -> removing use of makeINCtor
//
//function makeINCtor(exec) {
//  return function(/* ndata */) {
//    return {
//      exec: exec,
//      ndata: arguments,
//      __oni_dis: token_dis
//    };
//  }
//}


//----------------------------------------------------------------------
// Execution environment
/*

  {
    aobj: 'arguments' object,
    tobj: 'this' object,
    file: filename,
    blbref: function execution frame that blocklambda breaks should
            target in current environment 
    blrref: function execution frame that blocklambda returns should
            target in current environment
    blscope: this is the target ef scope (seq+some children) that will be returned to by blbreaks. 
             The scope a particular blbreak will be sent to is given by 'blbref' which is (usually) 
             the parent's blscope.
             blbreaks return to the topmost active execution frame within the 'blscope' env.
             blscope will be reset at function boundaries. 

    blanchor: blocklambda anchor call (ef of type 'EF_FAcall' - valid in argument children of EF_FAcall)
    bl: blocklambda execution frame (valid within children of a bl execution frame)

    XXX ONLY PROPAGATE blanchor to _arguments_

  }

*/

function Env(aobj, tobj, file, blbref, blrref, blscope, fold, branch, blanchor, reifiedstratum) { 
  this.aobj = aobj; // 'arguments' object
  this.tobj = tobj; // 'this' object
  this.file = file; // filename
  this.blbref = blbref;
  this.blrref = blrref;
  this.blscope = blscope;
  this.fold = fold; // place where 'alt' forks
  this.branch = branch; // id of fork branch. XXX should be merged with 'fold'
  this.blanchor = blanchor; // blocklambda anchor
  this.reifiedstratum = reifiedstratum;
}

function copyEnv(e) {
  return new Env(e.aobj, e.tobj, e.file, e.blbref, e.blrref, e.blscope, e.fold, e.branch, e.blanchor, e.reifiedstratum);  
}

//----------------------------------------------------------------------
// C : instruction node for function calls with non-blocking args
// Calls the given function with 'this' set to current environment 

// structure of ndata array:
#define NDATA_CALL_JSFUNC() ndata[0]
#define NDATA_CALL_LINENO() ndata[1]
function I_call(ndata, env) {
  try {
    current_call = [env.file, NDATA_CALL_LINENO()];
    var rv = (NDATA_CALL_JSFUNC()).call(env);
    if (is_ef(rv)) {
      // collect callstack on the execution frame:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([env.file, NDATA_CALL_LINENO()]);
    }
    return rv;
  }
  catch (e) {
    if (is_cfx(e)) {
      if (e.type === 'blb') {
        console.log('I_call saw: '+e);
      }
    }
    else { //if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_CALL_LINENO(), env.file);
    }
    return e;
  }
}
//exports.C = makeINCtor(I_call);
exports.C = function(...args/*f, line*/) {
  return {
    exec: I_call,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Nb : instruction node for non-blocking, argument-less javascript code 
// Calls the given function with 'this' set to current environment.

// structure of ndata array:
#define NDATA_NBLOCK_JSFUNC() ndata[0]
#define NDATA_NBLOCK_LINENO() ndata[1]
function I_nblock(ndata, env) {
  try {
    return (NDATA_NBLOCK_JSFUNC()).call(env);
  }
  catch (e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_NBLOCK_LINENO(), env.file);
    }
    return e;
  }
}
//exports.Nb = makeINCtor(I_nblock);
exports.Nb = function(...args/*f, line*/) {
  return {
    exec: I_nblock,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  };
};


//----------------------------------------------------------------------
// Seq : instruction node for sequential execution of child nodes

// ndata[0] contains flags.
#define NDATA_SEQ_FLAGS() ndata[0]
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE SEQ_FLAG_'s in kernel-sjs.js.in
#define NDATA_SEQ_FLAG_NONE 0
#define NDATA_SEQ_FLAG_FUNCTION 1
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_OR 2
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_AND 4
#define NDATA_SEQ_FLAG_NOTAILCALL 8
#define NDATA_SEQ_FLAG_UNRETURNABLE 16
#define NDATA_SEQ_FLAG_IMPLICIT_RETURN 32 
// ndata[1..end] contains sequence of instruction nodes

/*
  continuation index:
  1      : start
  2..end : returning from ndata[n-1] (last one tail-called)  
 */

var seq_counter = 0;

function EF_Seq(ndata, env) {
  // 'sid' is an id used in blocklambda break and return references
  this.sid = ++seq_counter;
#ifdef DEBUG_VM
  this.id = this.sid; 
#endif
  this.ndata = ndata;
  this.env = env;

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) {
    // No need to copy env here, because we are (by implication) a non-blocklambda function or the top-level
    ASSERT(!!(NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_FUNCTION|NDATA_SEQ_FLAG_UNRETURNABLE)));
    ASSERT(env.blbref === undefined);
    ASSERT(env.blrref === undefined);
    ASSERT(env.blscope === undefined);
    ASSERT(env.fold === undefined);
    ASSERT(env.branch === undefined);
    env.blbref = this; // note down function execution frame in environment
    env.blrref = this;
    env.blscope = this;
  }
  else if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
#ifdef DEBUG_VM
    // assert that we're a 'normal' function with a fresh env:
    ASSERT(env.blbref === undefined);
    ASSERT(env.blrref === undefined);
    ASSERT(env.blscope === undefined);
    ASSERT(env.fold === undefined);
    ASSERT(env.branch === undefined);
    // i.e. no need to copy env!
#endif // DEBUG_VM
  }

  this.tailcall = !(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == 0    : returns tunnel through us
  // swallow_r == 1    : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  // swallow_r == 3    : 'catch' a tailcalled Return(exp) that should not be returned (i.e. convert to undefined)
  this.swallow_r = (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION == NDATA_SEQ_FLAG_FUNCTION) ? 1 : 0;
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

  // is this a top-level seq (one that can't be return'ed to?)
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE) {
    this.unreturnable = true;
    // mark it as toplevel, for correct error messages and to allow
    // blocklambda breaks to target this frame:
    this.toplevel = true; 
  }
}
setEFProto(EF_Seq.prototype={});
#ifdef EF_TYPES
EF_Seq.prototype.type = function() { 
  var rv = "Seq";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION)
    rv += "(fun)";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    rv += "(notail)";

  return rv;
};
#endif
EF_Seq.prototype.cont = function(idx, val) {
#ifdef DEBUG_VM_XX
  var getType = function(val) {
    var sub = val && val.type;
    return "Seq/" + (sub || "??");
  };
  LOG("EF_Seq.prototype.cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "]) @ " + this.env.file);
#endif
 // console.log(this+"cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "])");

  if (is_ef(val)) {
    // child frame being replaced:
    this.setChildFrame(val, idx);
  }
  else {
    if (is_cfx(val) || this.aborted) {
      // block lambda break
      if (is_cfx(val) && val.type == 'blb_old' && this.env.blscope && val.eid == this.env.blscope.sid) {
        val = UNDEF;
      }
      else {
        // pass through other exceptions/abort

        // some cleanup first:
        if (this.child_frame) {
          this.child_frame.parent = UNDEF;
          this.child_frame = UNDEF;
        }

        return this.returnToParent(val);
      }
    }
    while (idx<this.ndata.length) {
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF; // ensures correct reentrant aborting
      }
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          if (!is_ef(val)) {
            return this.returnToParent(val);
          }
        }
      }
      if (++idx == this.ndata.length && this.tailcall) {
        // tail call optimization: 
        break;
      }
      if (is_cfx(val)) {
        // THE ACTUAL TEST CASE HITTING THIS IS observable-tests:'observe multiple values at once':
        // handle reentrant blocklambda breaks
        // (see sjs-2-tests:reentrant blocklambda resume/break)
        if (val.type === 'blb_old' && this.env.blscope && val.eid === this.env.blscope.sid) {
          val = UNDEF;
          console.log("HITTING THIS, idx="+idx+". total = "+this.ndata.length);
        }
        else
          break;
      }
      else if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
    return this.returnToParent(val);
  }
};

#ifdef HOTPATH
function I_seq(ndata, env) {
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    return cont(new EF_Seq(ndata, env), 1);

  var sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 
  var idx = 1;
  var val;
  var l = ndata.length;
  while (idx<l) {
    val = execIN(ndata[idx++], env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

    if (is_cfx(val)) break;
    if (is_ef(val)) {
      // need to create an execution frame for ourselves... 
      var ef = new EF_Seq(ndata, env);
      ef.setChildFrame(val, idx);
      return ef;
    }
    if (sc) {
      if (sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
        if (val) break; // returns val
      }
      else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
        if (!val) break; // returns val
      }
    }
  }

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
    if (is_cfx(val)) {
      if (val.type == "r") { 
        if (!val.eid)
          val = val.val;
      }
    }
    else
      val = UNDEF;
  }
  return val;
}
#else /* !HOTPATH */
function I_seq(ndata, env) {
  return cont(new EF_Seq(ndata, env), 1);
}
#endif /* HOTPATH */
//exports.Seq = makeINCtor(I_seq);
exports.Seq = function(...args) {
  return {
    exec: I_seq,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// EF_Reified is not directly exported - instead it is being called by 'exrseq' in blocklambda code

function createReifiedStratum(ef) {
  var RS = {
    toString: function() { return "[object Stratum '"+ef.id+"']"; },
    wait: function() {
      if (ef.done) return RS;
      var wef = {
#ifdef EF_TYPES
        toString: function() { return "<wait on stratum "+ef.id+">"; },
#endif
        wait: function() { return wef; },
        quench: function() { ef.wait_frames.delete(wef); },
        abort: function() { 
          exports.current_dyn_vars = wef.__oni_dynvars;
          //to aid gc; check if this is possible: wef.__oni_dynvars = UNDEF;
          return UNDEF;
        },
        __oni_ef: true,
        __oni_dynvars: exports.current_dyn_vars
      };

      ef.wait_frames.add(wef);

      return wef;
    },
    running: true,
    spawn: function(f) { return spawnSubStratum(f, ef) },
    join: function() { 
      if (ef.pending < 2) return; // no sub strata
      //console.log(ef+": JOIN ON "+ef.pending);
      var jef = {
#ifdef EF_TYPES
        toString: function() { return "<join on stratum "+ef.id+">"; },
#endif
        wait: function() { return jef; },
        quench: function() { ef.join_frames.delete(jef); },
        abort: function() { 
          //console.log("ABORT JOIN FRAME for "+ef);  
          exports.current_dyn_vars = jef.__oni_dynvars;
          //XXX to aid gc; check if this is ok: jef.__oni_dynvars = UNDEF;
          return UNDEF; 
        },
        __oni_ef: true,
        __oni_dynvars: exports.current_dyn_vars
      };

      ef.join_frames.add(jef);

      return jef;

    },
    abort: function() { 
      if (!RS.aborted) { 
        ef.quench(); 
        var dyn_vars = exports.current_dyn_vars;
        if ((ef.abort() !== ef) && ef.parent) {
          cont(ef.parent, ef.parent_idx, ef.pending_rv); 
        }
        exports.current_dyn_vars = dyn_vars;
      }; 
      return RS; 
    },
    capture: function() {
      return exports.sys.captureStratum(RS);
    },
    adopt: function(s) { 
      if (s._ef.done || s._ef.parent === ef) return s; // stratum is already done; no need to adopt
      var ef_to_adopt = s._ef;

      // see unit/stack-tests spawn/adopt tests
      if (ef_to_adopt.callstack) { 
        ef_to_adopt.callstack.push(current_call);
      }
      else {
        // for reentrant adoption of non-spawned stratum, we won't have a callstack, but
        // we will have 'pending_caller' set:
        ASSERT(ef_to_adopt.pending_caller);
        ef_to_adopt.callstack = [ current_call, ef_to_adopt.pending_caller ];
      }
      // ef_to_adopt might not have a parent if it is reentrantly adopted 
      var old_parent = s._ef.parent;
      var old_parent_idx = s._ef.parent_idx;
      //console.log(ef+' adopting '+ef_to_adopt+' with parent='+old_parent+', '+old_parent_idx);
      var id = ++ef.substratumid;
      ef_to_adopt.id += '~'+ef.id+'/'+id;
      ++ef.pending;
      ef_to_adopt.async = true;
      if (old_parent) {
        cont(old_parent, old_parent_idx, UNDEF);
      }
      else {
        //console.log("---------- ADOPT WITH NO PARENT");
        // mark as adopted, so that we don't hook up to parent in `spawn`:
        ef_to_adopt.adopted = true;
      }
      // this needs to come after cont(old_parent,...), because that code might set child_frame.parent=UNDEF
      cont(ef, -2, [id,ef_to_adopt]);
      return ef_to_adopt.reifiedstratum;
    },
    _ef:ef,
    __oni_stratum: true
  };
  return RS;
}

function spawnSubStratum(f, parent_ef) {
  if (parent_ef.done) throw new Error("Cannot spawn stratum with inactive parent");
  var id = ++parent_ef.substratumid;
  var reified_ef = new EF_Reified(parent_ef.id+'/'+id);
  //console.log("!spawn "+reified_ef);
  ++reified_ef.pending;
  ++parent_ef.pending;
  reified_ef.callstack = [ current_call ];
  var val;
  try {
    var parent_dynvars = exports.current_dyn_vars;
    exports.current_dyn_vars = Object.create(parent_dynvars);
    // start executing substratum:
    val = f(reified_ef.reifiedstratum);
  }
  catch(e) {
    // dispatch synchronous exception to parent_ef, then return 
    //XXX handle me
    if (!is_cfx(e)) {
      e = new CFException("t", e, 0, ''); // XXX call info
    }
    val = e;
  }
  exports.current_dyn_vars = parent_dynvars;
  // initialize substratum execution frame with main thread rv:
  var substratum_val = cont(reified_ef,-1,val);
  if (!reified_ef.adopted) {
    // hook up to parent stratum:
    cont(parent_ef, -2, [id,substratum_val]);
  }
  else {
    //console.log("NOT HOOKING UP ADOPTED STRATUM IN .SPAWN (parent="+reified_ef.parent+")");
    // need to clear pending: (XXX might be able to do this by direct setting?)
    cont(parent_ef, -2, [id, UNDEF]);
  }
  return reified_ef.reifiedstratum;
}

function EF_Reified(id) {
  // inject stratum interface
  this.id = id;
  this.reifiedstratum = createReifiedStratum(this);
  this.pending = 0;
  this.substratumid = 0;
  this.pending_rv = UNDEF;
  this.main_child = UNDEF;
  this.strata_children = new Map();
  this.strata_children_aborted = false;
  this.wait_frames = new Set();
  this.join_frames = new Set();
}
setEFProto(EF_Reified.prototype = {});
#ifdef EF_TYPES
EF_Reified.prototype.type = function() { 
  var rv = "Reified";
  return rv;
};
#endif

/*
  idx:
   -1: main branch start
   -2: new stratum

*/
EF_Reified.prototype.cont = function(idx, val) {
  //console.log(this+".cont("+idx+", "+val+", pending="+this.pending+",parent="+this.parent+")");
  ASSERT(idx <= 0 || this.strata_children.has(idx));

  if (idx === -1) {
    // main stratum setup
    // xxx note we might get child strata before this
    idx = 0; // this becomes the index for the child frame
    if (is_ef(val)) {
      if (this.aborted) {
        // reentrant abortion
        val.quench();
        val = val.abort();
      }
    }
  }
  else if (idx === -2) {
    idx = val[0];
    val = val[1];
    // new sub-stratum setup
    // val can be an execution frame or a value or exception
    if (is_ef(val)) {
      if (this.strata_children_aborted) {
        // reentrant abortion
        val.quench();
        val = val.abort();
      }
    }
  }
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    //console.log(this+"--PENDING(idx "+idx+") IN CONT >"+(this.pending-1));
    --this.pending;
    if (idx === 0) {
      this.main_child = UNDEF;
    }
    else {
      var child = this.strata_children.get(idx);
      if (child) {
        child.parent = UNDEF;
        this.strata_children.delete(idx);
      }
    }

    if (idx === 0) {
      //console.log(this+' setting pending_rv to '+val);
      if (this.pending_rv === UNDEF) 
        this.pending_rv = val;
      else
        this.pending_rv = mergeExceptions(val, this.pending_rv);
      //console.log(this+' pending_rv='+this.pending_rv);
      this.aborted = true;
      if (!this.strata_children_aborted)
        this.abort_child_strata();
    }
    else if (is_cfx(val)) {
      if (!this.aborted) {
//        console.log(this+' merge pending_rv '+this.pending_rv+' to '+val);
        this.pending_rv = mergeExceptions(val, this.pending_rv);
//        console.log(this+' pending_rv='+this.pending_rv);
        this.quench();
        this.abort();
      }
      else if (val.type === 't') {
        this.pending_rv = mergeExceptions(val, this.pending_rv);
      }
      else {
        var msg = "Swallowing control-flow exception '"+val+"' from aborted sub-stratum";
        if (console.error) console.error(msg);
        else console.log(msg);
      }
    }
  }
  
  if (this.pending <= 1) {
    this.flush_join_frames();
  }

  if (this.pending===0) {
    this.done = true;
    this.reifiedstratum.running = false;

    if (this.wait_frames.size) {
      var me = this;
      nextTick(function() { me.flush_wait_frames(); });
    }

    //console.log(this+".rtp ASYNC = "+this.async+', returning: '+this.pending_rv);
    return this.returnToParent(this.pending_rv);
  }
  else if (idx === 0) {
    this.async = true;
    //console.log(this + " RET THIS, parent="+this.parent+" pending="+this.pending);
    return this;
  }
};

EF_Reified.prototype.flush_join_frames = function() {
  var frames = this.join_frames;
  this.join_frames = new Set();
  for (var join_frame of frames) {
    if (join_frame.parent) {
      var current_dyn_vars = exports.current_dyn_vars;
      exports.current_dyn_vars = join_frame.__oni_dynvars;
      cont(join_frame.parent, join_frame.parent_idx, UNDEF);
      exports.current_dyn_vars = current_dyn_vars;
    }
    //XXX to aid gc; check if this is possible: join_frame.__oni_dynvars = UNDEF;
  }
};

EF_Reified.prototype.flush_wait_frames = function() {
  var frames = this.wait_frames;
  this.wait_frames = new Set(); // XXX UNNECESSARY?
  for (var wait_frame of frames) {
    if (wait_frame.parent) {
      var current_dyn_vars = exports.current_dyn_vars;
      exports.current_dyn_vars = wait_frame.__oni_dynvars;
      cont(wait_frame.parent, wait_frame.parent_idx, this.reifiedstratum);
      exports.current_dyn_vars = current_dyn_vars;
    }
    //XXX to aid gc; check if this is possible: wait_frame.__oni_dynvars = UNDEF;
  }
}

EF_Reified.prototype.abort_child_strata = function() {
  //console.log(this+' aborting child strata');
  //ASSERT(!this.strata_children_aborted);

  /* we need to be careful about how to quench&abort our children, since a still-running child
     can re-adopt another child */
  this.strata_children_aborted = true;
  for (var child of this.strata_children) {
    //console.log(this+' abort child '+child[0]);
    if (child[1].parent === this) {
      child[1].quench();
      var abort_val = child[1].abort(); // XXX do we need support for pseudo-abort?
      if (is_ef(abort_val)) {
        //console.log(this + ' need to wait for '+child[0]+': '+abort_val);
        //XXXUNN this.setChildFrame(abort_val, child[0]);
      }
      else {
        child[1].parent = UNDEF;
        //console.log(this+"--PENDING(CHILD "+child[1]+") IN ABORT >"+(this.pending-1));
        this.strata_children.delete(child[0]);
        --this.pending;
        // XXX check this is correct:
        if (is_annotated_oni_cfx(abort_val) && this.callstack) {
          abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }
        //console.log(this+' on child abort: merging '+abort_val);
        this.pending_rv = mergeExceptions(abort_val, this.pending_rv);
        //console.log(this+' pending_rv='+this.pending_rv);
      }
    }
    else {
      //console.log(this + " not aborting re-adopted child "+child[1]);
      this.strata_children.delete(child[0]);
    }
  }
//  console.log('pending after child_strata abort: '+this.pending);
};

EF_Reified.prototype.abort = function(pseudo_abort) {
  //console.log(this+".ABORT pending = "+this.pending+", aborted="+this.aborted+", done="+this.done+", main_child="+this.main_child+" parent="+this.parent);
  // allow redundant aborts
  if (this.aborted) return this;//this.done ? UNDEF : this;
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  if (!this.main_child) { 
    // reentrant abortion; we need to wait
    return this; 
  }
  else {
    var abort_val = this.main_child.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      //XXXUNN this.setChildFrame(abort_val, 0);
      return this;
    }
    else {
      this.main_child = UNDEF;
      //console.log(this+"--PENDING(MAIN CHILD) IN ABORT >"+(this.pending-1));
      --this.pending;
      // XXX check this is correct:
      if (is_annotated_oni_cfx(abort_val) && this.callstack) {
        abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }
      this.pending_rv = mergeExceptions(abort_val, this.pending_rv);
      //console.log(this+' pending_rv='+this.pending_rv);
      this.abort_child_strata();
    }

    if (this.pending <= 1) {
      this.flush_join_frames();
    }
    //console.log(this+" after abort, pending="+this.pending);
    if (this.pending) return this; // need to stay in picture because abort must not return child frame
    
    // XXX consolidate this code with the equivalent in 'cont':
    this.done = true;
    this.reifiedstratum.running = false;

    if (this.wait_frames.size) {
      var me = this;
      nextTick(function() { me.flush_wait_frames(); });
    }

    // XXX check if this is still an issue:
    // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
    this.unreturnable = true;
    //console.log(this+" ABORT DONE & RETURNING: "+this.pending_rv);
    return this.pending_rv;
  }
};

// XXX can't use quenchPar here, because we have to use a Map for children:
EF_Reified.prototype.quench = function() {
  //console.log(this+'quench');
  // XXX figure out quench logic
  if (this.main_child) this.main_child.quench();
  // don't quench child strata here; they might still be re-adopted as part of 
  // abortion
  //for (var child of this.strata_children) {
  //  if (child[1])
  //    child[1].quench();
  //}
};

// XXX can't use setChildFramePar here, because we have to use a Map for children:
EF_Reified.prototype.setChildFrame = function(ef, idx) {
  //console.log(this+'.setchildframe('+ef+','+idx+' parent='+this.parent+')');
  if (idx === 0) {
    if (this.main_child) {
      if (this.main_child.callstack) {
        // merge callstacks of old & new childframes (stack-tests 28,29)
        mergeCallstacks(ef, this.main_child);
      }
      this.main_child.parent = UNDEF;
    }
    this.main_child = ef;
  }
  else {
    if (this.strata_children.has(idx)) {
      if (this.strata_children.get(idx).callstack) {
        // merge callstacks of old & new childframes (stack-tests 28,29)
        mergeCallstacks(ef, this.strata_children.get(idx));
      }
      this.strata_children.get(idx).parent = UNDEF;
    }
    this.strata_children.set(idx,ef);
  }
  ef.parent = this;
  ef.parent_idx = idx;
}

var reified_counter = 0;
function I_reifiedseq(ndata, env) {
  var inner_ef = new EF_Seq(ndata, env);
  var reified_ef = new EF_Reified(++reified_counter/*inner_ef.type()*/);
  // we're setting pending_caller, in case there is a reentrant adopt:
  // - see also unit/stack-tests:'function abort'
  reified_ef.pending_caller = current_call;
  //console.log("!seq "+reified_ef);
  ++reified_ef.pending;
  // inject stratum interface:
  inner_ef.env.reifiedstratum = reified_ef.reifiedstratum;
  // start inner seq:
  var val = cont(inner_ef, 0);
  // initialize stratum ef & return:
  var rv = cont(reified_ef,-1,val);
  return reified_ef.adopted ? UNDEF : rv;
}

//----------------------------------------------------------------------
// Bl : instruction node for block lambdas
/*

  Semantics:

  - Blocklambda throws exception if anchor call is finished

*/


// EF_BlSeq is not directly exported - instead it is being called by 'exbl' in blocklambda code

// ndata[0] contains flags - same as for seq
//var blseq_counter = 0;

function EF_BlSeq(ndata, env) {
//  this.blsid = ++blseq_counter;
  this.sid = ++seq_counter;
#ifdef DEBUG_VM
//  this.id = this.blsid; 
  this.id = this.sid;
#endif

  ASSERT(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION);
  ASSERT(!(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE));
  ASSERT(env.blanchor);

  this.ndata = ndata;
  this.env = copyEnv(env);
  
//  this.env.bl = this;

  this.env.blbref = env.blscope; // `break` in our scope targets our parent's scope
  
  this.blanchor = env.blanchor;
  this.env.blanchor = undefined;


  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) {
    this.env.blrref = env.blrref;
    this.env.blscope = this; // we're a scope for any `break`s in nested blocklambdas
  }
  else {
    // we're a blocklambda but NOT a scope for any `break`s in child frames (otherwise the compiler would
    // have marked us 'notailcall'). clear blscope so that targeted `break` calls that travel down the call tree will
    // find their way to the correct scope (we need the `break` to 'tunnel' through these non-targeted functions)
    // XXX could equally set this to 'this'
    this.env.blscope = null;
  }

  this.tailcall = false; //!(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == 0    : returns tunnel through us
  // swallow_r == 1    : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  // swallow_r == 3    : 'catch' a tailcalled Return(exp) that should not be returned (i.e. convert to undefined)
  this.swallow_r = 1;
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

}
setEFProto(EF_BlSeq.prototype={});
#ifdef EF_TYPES
EF_BlSeq.prototype.type = function() { 
  var rv = "BlSeq";
  return rv;
};
#endif
EF_BlSeq.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    // child frame being replaced:
    this.setChildFrame(val, idx);
  }
  else {
    if (is_cfx(val) || this.aborted) {
      // block lambda break
      /*if (val.type == 'blb') {
        var rv;
        if (!this.aborted) {
          rv = this.do_break();
          if (!this.aborted) {
            if (is_returnToParent(rv)) {
              nextTick(function() {
                while (is_returnToParent(rv)) {
                  rv = rv.execute();
                }
              });
            }
            return this;
          }
        }
        return rv;
      }*/
      if (is_cfx(val) && val.type === 'blb_int') {
        //XXX check if blanchor still alive
        var rv = new CFException('blb');
        rv.blanchor = this.blanchor; // XXX make this a serializable ID
        return this.returnToParent(rv);
      }
      else {
        // block lambda break
        if (is_cfx(val) && val.type == 'blb_old' && this.env.blscope && val.eid == this.env.blscope.sid) {
          val = UNDEF;
        }
        else {
          // pass through other exceptions/abort

          // some cleanup first:
          if (this.child_frame) {
            this.child_frame.parent = UNDEF;
            this.child_frame = UNDEF;
          }

          return this.returnToParent(val);
        }
      }
    }
    while (idx<this.ndata.length) {
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF; // ensures correct reentrant aborting
      }
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        //console.log(this + ' reentrantly aborting return value: '+val);
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench();
          val = val.abort(this.pseudo_abort);
          //console.log(this + ' reentrant aborting yields: '+val);
          if (!is_ef(val)) {
            return this.returnToParent(val);
          }
        }
        //XXX needed? -> No, this leads to the wrong aborting behavior:
        //if (!is_cfx(val) && !is_ef(val)) val = UNDEF;
        //console.log(this + ' returning '+val+' to '+this.parent);
        //return this.returnToParent(val);
      }
      ++idx;
//      if (++idx == this.ndata.length && this.tailcall) {
//        // tail call optimization: 
//        break;
//      }
      if (is_cfx(val)) {
        // handle reentrant blocklambda breaks
        // (see sjs2-tests:reentrant blocklambda resume/break)
        /* if (val.type === 'blb') {
          var rv;
          if (!this.aborted) {
            rv = this.do_break();
            // this do_break might have (usually will have) aborted us
            if (!this.aborted) {
              if (is_returnToParent(rv)) {
                nextTick(function() {
                  while (is_returnToParent(rv)) {
                    rv = rv.execute();
                  }
                 });
              }
              return this;
            }
          }
          return rv;
        } */
        if (val.type === 'blb_int') {
          //XXX check if blanchor still alive
          val = new CFException('blb');
          val.blanchor = this.blanchor; // XXX make this a serializable ID
          console.log('handing blb off to '+this.parent);
        }
        else if (val.type === 'blb_old' && this.env.blscope && val.eid === this.env.blscope.sid) {
          val = undefined;
        }
        break; // bail out of while loop
      }
      else if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
    return this.returnToParent(val);
  }
};

EF_BlSeq.prototype.abort = function(pseudo_abort) {
#ifdef DEBUG_VM
  if (this.aborted) {
    console.log('ERROR: '+ this + ': redundant abort');
  }
  // leave the assert, so that the process exits:
  ASSERT(!this.aborted);
#endif
  this.aborted = true;
  if (this.breaking) return UNDEF;
  this.pseudo_abort = pseudo_abort;
  // see sjs-2-test 'reentrant quench/abort' for why we need to
  // check for 'this.child_frame' here and in 'quench'
  if (!this.child_frame) {
    //console.log(this+ ' reentrant abort');
    // reentrant abortion
    return this;
  }
  else {
    //console.log(this + ' abort child frame:'+this.child_frame);
    var abort_val = this.child_frame.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      return this; // need to stay in picture because abort must not return child frame
    }
    else {
      if (is_annotated_oni_cfx(abort_val) && this.callstack) {
        abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
      }
      
      // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
      this.unreturnable = true;
      return abort_val;
    }
  }
};
/*
EF_BlSeq.prototype.do_break = function() {
  // XXX abort the blseq
//  console.log(this + ' do_break');
  this.breaking = true;
  return this.blanchor.do_break();
};
*/
// called only by 'exbl':
function I_blseq(ndata, env) {
  ASSERT(env.blanchor);
  if (env.blanchor.unreturnable) return new CFException("t", new Error("Blocklambda anchor at "+env.file+":"+env.blanchor.ndata[1]+" is inactive."));
  return cont(new EF_BlSeq(ndata, env), 1);
}


// structure of ndata array:
#define NDATA_BLOCKLAMBDA_JSFUNC() ndata
function I_blocklambda(ndata, env) {
  return NDATA_BLOCKLAMBDA_JSFUNC().bind(env);
}
//exports.Bl = makeINCtor(I_blocklambda);
exports.Bl = function(f) {
  return {
    exec: I_blocklambda,
    ndata: f,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// blocklambda break

/*
function EF_BlBreak(ndata, env) {
  this.dyn_vars = exports.current_dyn_vars;
  this.bl = env.bl;
}
setEFProto(EF_BlBreak.prototype={});
#ifdef EF_TYPES
EF_BlBreak.prototype.type = "BlBreak";
#endif

EF_BlBreak.prototype.cont = function(idx, val) {
  this.bl.do_break();
  return this.aborted ? null : this;
};

EF_BlBreak.prototype.quench = dummy;
EF_BlBreak.prototype.abort = function() { exports.current_dyn_vars = this.dyn_vars; this.aborted = true; return UNDEF};
*/
function I_blbreak(ndata, env) {
  return new CFException("blb_int");
//  return cont(new EF_BlBreak(ndata, env), 0);
}
  
//exports.BlBreak = makeINCtor(I_blbreak);
exports.BlBreak = function() {
  return {
    exec: I_blbreak,
    ndata: undefined,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Reify (executed by 'reifiedStratum' builtin)

// no execution frame needed, but we need access to 'env'
// could also encode this as a strict function:
// kernel-sjs: nblock, 'return __oni_rt.Reify(this)'

function I_reify(ndata, env) {
  var s = env.reifiedstratum;
  if (!s) return new CFException("t", new Error("Context is not reifiable"));
  return s;
};

exports.Reify = function() {
  return {
    exec: I_reify,
    ndata: undefined,
    __oni_dis: token_dis
  };
};

//----------------------------------------------------------------------
// Sc : simple strict function call
//
// executes env.SC_L(arg1, arg2, ...) where arg1..n are strictly
// evaluated instruction nodes


// structure of ndata array:
#define NDATA_SC_LINE() ndata[0]
#define NDATA_SC_L() ndata[1]
#define NDATA_SC_ARGS_OFFSET 2
// ndata[NDATA_SC_ARGS_OFFSET..end] : sc args

/*
  continuation index:
   0 : start
   1 : returning from args evaluation
*/

function EF_Sc(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_SC_ARGS_OFFSET;
  this.pars = [];
}
setEFProto(EF_Sc.prototype={});
#ifdef EF_TYPES
EF_Sc.prototype.type = "Sc";
EF_Sc.prototype.toString = function() {
  return "<Sc@"+this.env.file.substr(-20)+':'+this.ndata[0]+'>';
};
#endif

EF_Sc.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }
    return this.returnToParent(val);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 20
    }
    if (idx == 1) {
      // handle a result that has been passed in
      this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1);
        return this;
      }
      this.pars.push(rv);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the pars, let's do the call:
    try {
        rv = this.NDATA_SC_L().apply(this.env, this.pars);
    }
    catch (e) {
      rv = new CFException("t", e,
                           this.NDATA_SC_LINE(),
                           this.env.file);
    }
    return this.returnToParent(rv);
  }
};

function I_sc(ndata, env) {
  return cont(new EF_Sc(ndata, env), 0);
}

//exports.Sc = makeINCtor(I_sc);
exports.Sc = function(...args) {
  return {
    exec: I_sc,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Fcall : instruction node for calling a function 

// IE-safe helper to determine if something is a function
function testIsFunction(f) {
  if (typeof f == "function") return true;
  // ... else, the IE/Safari workarounds (some things like
  // document.getElementById are not functions)
  // try 1:
//  return ((""+f).indexOf("[native code]") != -1) ||
//    ((""+f).indexOf("Constructor]") != -1);
  // try 2: (doesn't catch "[object ...]")
//  return ((""+f).indexOf("[") != -1 )
  // try 3:
  // don't catch things like: html::Element[div] (stringification of mho:surface html primitives) 
  return /(^| )\[[^o]/.test(""+f);
}  

// structure of ndata array:
// mode: 0: normal call, 1: reference call, 2: 'new' call
#define FCALL_MODE_NORMAL    0
#define FCALL_MODE_REFERENCE 1
#define FCALL_MODE_NEW       2
#define FCALL_FLAGS_MODE_MASK 3
#define FCALL_FLAG_SPREAD 4
#define NDATA_FCALL_FLAGS() ndata[0]
#define NDATA_FCALL_LINE() ndata[1]
#define NDATA_L_INDEX 2
#define NDATA_FCALL_L() ndata[2]
#define NDATA_FCALL_ARGS_OFFSET 3
// ndata[NDATA_FCALL_ARGS_OFFSET..end] : fcall args
// if FCALL_FLAG_SPREAD is set, then last arg is array of 0-based indices of args that should be spread (...)
/*
  continuation index:
   0 : start
   1 : returning from l/pars evaluation
   2 : returning from 'new' call (need to return 'this.o') 
*/

function EF_Fcall(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];

}
setEFProto(EF_Fcall.prototype={});
#ifdef EF_TYPES
EF_Fcall.prototype.type = "Fcall";
EF_Fcall.prototype.toString = function() { return "<Fcall@"+this.env.file.substr(-20)+":"+this.NDATA_FCALL_LINE()+">"};
#endif

EF_Fcall.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    // XXX CLEANUP childframe
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // returning from a 'new' call
    return this.returnToParent(typeof val === 'object' ? val : this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i===NDATA_FCALL_ARGS_OFFSET) {
        this.l = val;
      }
      else
        this.pars.push(val);
    }
    var rv;
    var args_length = this.ndata.length;
    if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) --args_length;
    while (this.i<args_length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1, true); // prevent unnecessary callstack copying
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    }
    
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the left side + pars, let's do the call:
    try {
      var pars;

      if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) {
        pars = [];
        var spreads = this.ndata[this.ndata.length-1];
        for (var i=0; i<this.pars.length;++i) {
          if (spreads[0] === i) {
            pars = pars.concat(this.pars[i]);
            spreads.shift();
          }
          else
            pars.push(this.pars[i]);
        }
      }
      else 
        pars = this.pars;

      current_call = [this.env.file, this.NDATA_FCALL_LINE()];

      switch (this.NDATA_FCALL_FLAGS() & FCALL_FLAGS_MODE_MASK) {
      case FCALL_MODE_NORMAL:
      // 'normal' call
      if (typeof this.l == "function") {
        rv = this.l(...pars);
      } 
      else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        //        var command = "this.l(";
        //        for (var i=0; i<pars.length; ++i) {
        //          if (i) command +=",";
        //          command += "pars["+i+"]";
        //        }
        //        command += ")";
        try {
          this.l(...pars);
        //          rv = eval(command);
        }
        catch (e) {
          // we have a bit of a problem now... the command could have
          // failed because the "function" wasn't a function after
          // all, or because running the builtin failed. As this is
          // mainly a problem on windows (maybe also safari?) we'll
          // take a punt and replace the (cryptic) exception we get
          // ("this.l isn't a function") by a saner one:
          rv = new CFException("t",
                               new Error("'"+this.l+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_REFERENCE:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA !== "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<pars.length; ++i) {
          if (i) command +=",";
          command += "pars["+i+"]";
        }
        command += ")";

        try {
          rv = eval(command);
        }
        catch (e) {
          // as above, we have a bit of a problem now... the command
          // could have failed because the "function" wasn't a
          // function after all, or because running the builtin
          // failed. As this is mainly a problem on windows (maybe
          // also safari?) we'll take a punt and replace the (cryptic)
          // exception we get ("this.l isn't a function") by a saner
          // one:
          rv = new CFException("t",
                               new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_NEW:
        // 'new' call
        var ctor = this.l;
        rv = new ctor(...pars);
        if (is_ef(rv)) {
          if (!rv.env) throw new Error("Invalid constructor function (no environment)");
          this.o = rv.env.tobj;
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      if (is_cfx(e)) {
        // handle blocklambda break: 
        if (e.type == 'blb_old' && this.env.blscope && e.eid == this.env.blscope.sid) {
          rv = UNDEF;
        }
        else
          rv = e;
      }
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }
    if (is_ef(rv)) {
      if (this.aborted) {
        // reentrant abortion
        rv = rv.abort(this.pseudo_abort);
        return this.returnToParent(rv);
      }

      // the call is blocking -> insert ourselves into callstack:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([this.env.file, this.NDATA_FCALL_LINE()]);
    }
    return this.returnToParent(rv);
  }
};

function I_fcall(ndata, env) {
  return cont(new EF_Fcall(ndata, env), 0);
}

//exports.Fcall = makeINCtor(I_fcall);
exports.Fcall = function(...args) {
  return {
    exec: I_fcall,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// FAcall: Fcall that is an anchor for a blocklambda
// same ndata format as fcall, but in addition we have:
/*
  continuation index:

    3: returning from waiting for function call result (we're never tail-called)
*/


function EF_FAcall(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];

  // inject ourselves into environment:
  this.env = copyEnv(env);
  this.env.blanchor = this;

}
setEFProto(EF_FAcall.prototype={});
#ifdef EF_TYPES
EF_FAcall.prototype.type = "FAcall";
EF_FAcall.prototype.toString = function() { return "<FAcall@"+this.env.file.substr(-20)+":"+this.NDATA_FCALL_LINE()+">"};
#endif

EF_FAcall.prototype.cont = function(idx, val) {
//console.log(this+'.cont('+idx+','+val+')');
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    if (is_cfx(val) && val.type === 'blb' && val.blanchor === this) {
      console.log("GOT ASYNC BLB:"+val);
      val = UNDEF;
    }
    // XXX CLEAN UP CHILDFRAME
    return this.returnToParent(val);
  }
  else if (idx === 3) {
/*    if (this.breaked && !this.aborted) {
      val = UNDEF;
    }*/
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // returning from a 'new' call
    return this.returnToParent(typeof val === 'object' ? val : this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i===NDATA_FCALL_ARGS_OFFSET) {
        this.l = val;
      }
      else
        this.pars.push(val);
    }
    var rv;
    var args_length = this.ndata.length;
    if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) --args_length;
    while (this.i<args_length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1, true); // prevent unnecessary callstack copying
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    }
    
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the left side + pars, let's do the call:
    try {
      var pars;

      if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) {
        pars = [];
        var spreads = this.ndata[this.ndata.length-1];
        for (var i=0; i<this.pars.length;++i) {
          if (spreads[0] === i) {
            pars = pars.concat(this.pars[i]);
            spreads.shift();
          }
          else
            pars.push(this.pars[i]);
        }
      }
      else 
        pars = this.pars;

      switch (this.NDATA_FCALL_FLAGS() & FCALL_FLAGS_MODE_MASK) {
      case FCALL_MODE_NORMAL:
      // 'normal' call
      if (typeof this.l == "function") {
        rv = this.l(...pars);
      } 
      else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        //        var command = "this.l(";
        //        for (var i=0; i<pars.length; ++i) {
        //          if (i) command +=",";
        //          command += "pars["+i+"]";
        //        }
        //        command += ")";
        try {
          this.l(...pars);
        //          rv = eval(command);
        }
        catch (e) {
          // we have a bit of a problem now... the command could have
          // failed because the "function" wasn't a function after
          // all, or because running the builtin failed. As this is
          // mainly a problem on windows (maybe also safari?) we'll
          // take a punt and replace the (cryptic) exception we get
          // ("this.l isn't a function") by a saner one:
          rv = new CFException("t",
                               new Error("'"+this.l+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_REFERENCE:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA !== "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<pars.length; ++i) {
          if (i) command +=",";
          command += "pars["+i+"]";
        }
        command += ")";

        try {
          rv = eval(command);
        }
        catch (e) {
          // as above, we have a bit of a problem now... the command
          // could have failed because the "function" wasn't a
          // function after all, or because running the builtin
          // failed. As this is mainly a problem on windows (maybe
          // also safari?) we'll take a punt and replace the (cryptic)
          // exception we get ("this.l isn't a function") by a saner
          // one:
          rv = new CFException("t",
                               new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_NEW:
        // 'new' call
        var ctor = this.l;
        rv = new ctor(...pars);
        if (is_ef(rv)) {
          if (!rv.env) throw new Error("Invalid constructor function (no environment)");
          this.o = rv.env.tobj;
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      if (is_cfx(e)) {
        if (e.type === 'blb' && e.blanchor === this) {
          rv = UNDEF;
        }

        // handle blocklambda break: 
        if (e.type == 'blb_old' && this.env.blscope && e.eid == this.env.blscope.sid) {
          rv = UNDEF;
        }
        else if (e.type === 'blb' && e.blanchor === this) {
          console.log('GOT BLB: '+e);
          rv = UNDEF;
        }
        else
          rv = e;
      }
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }
    if (is_ef(rv)) {
      if (this.aborted) {
        // reentrant abortion
        //console.log(this+': applying reentrant abortion to child frame');
        rv = rv.abort(this.pseudo_abort);
        return this.returnToParent(rv);
      }
/*
      else if (this.breaked) {
        //console.log(this + ' reentrant break');
        // reentrant break
        rv = rv.abort();
        //console.log(this + ' rv aborted; abort returned:'+rv);
        if (!is_ef(rv)) rv = undefined;
      }
*/
      if (rv) {
        // the call is blocking -> insert ourselves into callstack:
        if (!rv.callstack) rv.callstack = [];
        rv.callstack.push([this.env.file, this.NDATA_FCALL_LINE()]);
      }
    }

    // make sure we're not tail-called:
    if (is_ef(rv)) {
      this.setChildFrame(rv, 3);
      return this;
    }
    else
      return this.returnToParent(rv);
  }
};

/*
EF_FAcall.prototype.do_break = function() {
  console.log(this+' do_break');
  if (this.breaked) {
    console.log('ERROR: '+this+' redundant break');
    return;
  }
  this.breaked = true;
  if (this.child_frame) {
    console.log(this + ' aborting '+this.child_frame);
    this.child_frame.quench();
    var rv = this.child_frame.abort();
    console.log(this + ' do_break abort childframe returned: '+rv);
    if (is_ef(rv)) {
      // we need to wait
      this.setChildFrame(rv, 3);
    }
    else {
      // xxx not sure needed
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
      console.log(this+' do break returning to parent '+this.parent);
      return this.returnToParent(UNDEF);
    }
  }
};
*/

function I_facall(ndata, env) {
  return cont(new EF_FAcall(ndata, env), 0);
}

//exports.FAcall = makeINCtor(I_facall);
exports.FAcall = function(...args) {
  return {
    exec: I_facall,
    ndata: args,
    __oni_dis: token_dis
  }
};


//----------------------------------------------------------------------
// If : instruction node for executing 'if'

// structure of ndata array:
#define NDATA_IF_TEST() ndata[0]
#define NDATA_IF_CONSEQUENT() ndata[1]
#define NDATA_IF_ALTERNATIVE() ndata[2]

/*
  continuation index:
   0 : start
   1 : returning from test evaluation
*/

#ifdef DEBUG_VM
var if_counter = 0;
#endif

function EF_If(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++if_counter;
#endif
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_If.prototype={});
#ifdef EF_TYPES
EF_If.prototype.type = "If";
#endif

EF_If.prototype.cont = function(idx, val) {
  switch (idx) {
  case 0:
  //  LOG("IF: exec test")
  val = execIN(this.NDATA_IF_TEST(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

  //  LOG("IF: test execed:"+val)
  case 1:
  if (is_cfx(val) || this.aborted) {
    // XXX CLEAN UP CHILD FRAME
    break;
  }
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  // tail calls:
  if (val)
    val = execIN(this.NDATA_IF_CONSEQUENT(), this.env);
  else
    val = execIN(this.NDATA_IF_ALTERNATIVE(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
      }
    }
  break;
  default:
  val = new CFException("i", "invalid state in EF_If");
  }
  return this.returnToParent(val);
};

function I_if(ndata, env) {
  return cont(new EF_If(ndata, env), 0);
}

//exports.If = makeINCtor(I_if);
exports.If = function(...args/*t,c,a*/) {
  return {
    exec: I_if,
    ndata: args, //[t,c,a],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Switch: instruction node for executing 'switch() { case/default }'

// exported objected designating a 'default' clause:
var Default = {};
exports.Default = Default;

// structure of ndata array:
#define NDATA_SWITCH_EXP() ndata[0]
#define NDATA_SWITCH_CLAUSES() ndata[1]

/*
  continuation index:

phase 0: (evaling switch exp)

   0    : start
   1    : returning from switch expression evaluation

phase 1: (testing clause exp)
   -1   : entering from switch exp evaluation
   0..n : returning from given clause exp 


phase 2: (executing clause code)

   0...n : next clause to run
*/

function EF_Switch(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.phase = 0;
}
setEFProto(EF_Switch.prototype={});
#ifdef EF_TYPES
EF_Switch.prototype.type = "Switch";
#endif

EF_Switch.prototype.cont = function(idx, val) {
  switch (this.phase) {
  case 0: // evaluate switch expression
  if (idx == 0) {
    val = execIN(this.NDATA_SWITCH_EXP(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  if (is_cfx(val) || this.aborted) {
    // XXX CLEAN UP CHILD FRAME
    return this.returnToParent(val);
  }
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  this.phase = 1;
  this.testval = val;
  idx = -1;
  case 1: // test clauses until we find a matching one
  while (true) {
    if (idx > -1) { // returning from evaluation of clause test idx
      if (is_cfx(val)) return this.returnToParent(val);
      if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
      else if (val == Default || val == this.testval)
        break; // go into phase 2!
    }
    if (++idx >= this.NDATA_SWITCH_CLAUSES().length)
      return this.returnToParent(null); // all done; no matching clause found
    // test next clause:
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 21
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][0], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  this.phase = 2;
  val = 0;
  case 2: // run clauses
  while (true) {
    if (is_ef(val)) {
      this.setChildFrame(val, idx);
      return this;
    }
    if (is_cfx(val)) {
      if (val.type == "b") {
        val = val.val;
      }
      return this.returnToParent(val);
    }
    if (idx >= this.NDATA_SWITCH_CLAUSES().length) {
      return this.returnToParent(val);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 22
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][1], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
    ++idx;
  }
  default:
  throw new Error("Invalid phase in Switch SJS node");
  }
};

function I_switch(ndata, env) {
  return cont(new EF_Switch(ndata, env), 0);
}

//exports.Switch = makeINCtor(I_switch);
exports.Switch = function(...args/*exp, clauses*/) {
  return {
    exec: I_switch,
    ndata: args, //[exp, clauses],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Try : instruction node for try/catch/finally

// structure of ndata array:
// ndata[0] contains flags.
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE TRY_FLAG_'s in kernel-sjs.js.in
#define NDATA_TRY_FLAG_NONE 0
#define NDATA_TRY_FLAG_AUGMENTED_FINALLY 1

#define NDATA_TRY_FLAGS() ndata[0]
#define NDATA_TRY_TRY_BLOCK() ndata[1]
#define NDATA_TRY_CATCH_FUNC() ndata[2]
#define NDATA_TRY_FINALLY_BLOCK() ndata[3]
#define NDATA_TRY_RETRACT_BLOCK() ndata[4]

/*
  continuation index not used, we use this.state instead (since we
  need to know the state when we get an abort):

  0 : start
  1 : returning from try block
  2 : returning from catch
  3 : returning from retract
  4 : returning from finally

*/

#ifdef DEBUG_VM
var try_counter = 0;
#endif

function EF_Try(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++try_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.state = 0;
}
setEFProto(EF_Try.prototype={});
#ifdef EF_TYPES
EF_Try.prototype.type = function() { return "Try("+this.state+")" };
#endif

EF_Try.prototype.cont = function(idx, val) {
  //console.log(this+'.cont('+idx+','+val+', state='+this.state+')');
  if (is_ef(val)) {
    this.setChildFrame(val, this.state);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      // ensure correct reentrant aborting:
      // XXX not sure if this is negatively impacting call-stack copying
      this.child_frame = UNDEF; 
    }

    switch (this.state) {
    case 0:
    this.state = 1;
    val = execIN(this.NDATA_TRY_TRY_BLOCK(), this.env);

    if (is_ef(val)) {
      this.setChildFrame(val);
      return this;
    }
    case 1:
      // returning from try block
      this.state = 2;
      if (this.NDATA_TRY_CATCH_FUNC() &&
          (is_cfx(val) && val.type == "t")) {
        var v;
        v = val.val;
        val = this.NDATA_TRY_CATCH_FUNC()(this.env, v);
        
        // Check for a reentrant abortion triggered by our catch() block
        // see sjs-2-tests.sjs: reentrant abortion from catch()
        if (this.aborted && is_ef(val)) {
          val.quench();
          val = val.abort(this.pseudo_abort);
        }

        // tail-call optimization:
        // The !(aborted&&is_ef) check is important because cont() is called from EF_Try::abort, and 
        // we don't want to be replaced by a child frame.
        if (!this.NDATA_TRY_RETRACT_BLOCK() && 
            !this.NDATA_TRY_FINALLY_BLOCK() && 
            !(this.aborted && is_ef(val))) {
          return this.returnToParent(val);
        }
        
        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 23
          return this;
        }
      }
    case 2:
    // returning from try/catch
    this.state = 3;
    // save value from catch/try:
    this.rv = val;
    if (((this.aborted && !this.pseudo_abort) || (is_cfx(val) && val.type==='blb')) && this.NDATA_TRY_RETRACT_BLOCK()) {
      val = execIN(this.NDATA_TRY_RETRACT_BLOCK(), this.env);

      // tail-call optimization:
      // XXX this breaks sjs-testsuite2:51
      //if (!this.NDATA_TRY_FINALLY_BLOCK())
      //  return this.returnToParent(val);


      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 3:
    // returning from try/catch/retract
    this.state = 4;

    // make sure exceptions from retract get passed through:
    if (is_cfx(val) && val.type === "t") {
      this.rv = val;
    }

    if (this.NDATA_TRY_FINALLY_BLOCK()) {
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        // Can pass in `this.parent` below, for debugging purposes:
        // `try { hold(0); } finally(e) { console.log(e[4]); throw e; }`
        // gives the current ef.
        var v = is_cfx(this.rv) ?
          [this.rv, true, !!this.aborted, !!this.pseudo_abort, this.parent] :
          [this.rv, false, !!this.aborted, !!this.pseudo_abort, this.parent];
        val = this.NDATA_TRY_FINALLY_BLOCK()(this.env, v);
      }
      else {
        val = execIN(this.NDATA_TRY_FINALLY_BLOCK(), this.env);
      }
      // we can't tail-call this, because we might have to return
      // the stored rv (if it is an exception)
      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 4:
      // returning from finally
      
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        if (!is_cfx(val)) {
          val = new CFException("t", new Error("augmented finally(){} block needs to throw a value"));
        }
        else {
          // we expect 'throw' in an augmented finally(e){} to rethrow
          // 'e' (or an array with a value - exception or otherwise - as 
          // first argument). 
          // We also want to be able to cope with 'real' exceptions thrown
          // if e.g. there is a logic error in the finally block, so we
          // only resolve to val.val[0] if val.val is an array:
          if (Array.isArray(val.val))
            val = val.val[0];
        }
      }
      else {
        // override res with stored exception (from try or catch) if
        // val isn't an exception
        // It would make sense to never override a real exception thrown in try with
        // a 'return' or 'break' from finally, but - alas - js parity compels us to do so.
        if (!is_cfx(val)) {
          val = this.rv;
          //else if (this.aborted)
          //  val = UNDEF;
        }
        else if (is_cfx(this.rv) && this.rv.type === 't' && this.rv !== val) { // val is an exception and we have a pending exception from try/catch
          // while we cannot override finally's exception, we can log the fact that we are 
          // swallowing an exception:
          var msg; 
          if (val.type === 't')
            msg = "Exception '"+val.val+"' thrown";
          else
            msg = CFETypes[val.type];
          msg += " in finally{} clause overriding try/catch exception '"+this.rv.val+"'";
          if (console.error) console.error(msg);
          else console.log(msg);
        }
      }
    break;
    default:
    val = new CFException("i", "invalid state in CF_Try");
    }
    return this.returnToParent(val);
  }
};

EF_Try.prototype.quench = function() {
  if (this.child_frame && this.state !== 4 && this.state !== 3) // don't quench inside finally or retract blocks
    this.child_frame.quench();
};

EF_Try.prototype.abort = function(pseudo_abort) {
  //console.log(this + ' ABORT, parent = '+this.parent);
#ifdef DEBUG_VM
  if (this.aborted) {
    console.log('ERROR: '+this + ' redundant abort');
    ASSERT(!this.aborted); // sanity check; aborted before
  }
#endif
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;

  if (!this.child_frame) return this; // reentrant abort

  ASSERT(this.state !== 3) // sanity check; aborted before
  if (this.state !== 4) { // don't abort finally block
    var val = this.child_frame.abort(this.pseudo_abort); 
    if (is_ef(val)) {
      // we need to wait for the try or catch block, and then let
      // cont() proceed with retract/finally:
      this.setChildFrame(val);
    }
    else {
      // attempt to execute catch/retract/finally blocks synchronously:

      // Leftover from old abort code. Not sure what the logic was here.
      // prevent continuation from ending up at parent, we want to feed
      // it to the abortee directly:
      // this.parent = UNDEF;

      // temporarily need to turn off async flag, so that 'returnToParent' doesn't attempt to 
      // return to non-existing parent, which would cause exceptions to go uncaught
      this.async = false;
      var rv = cont(this, 0, val);
      ASSERT(!is_ef(rv) || rv === this);
      if (rv !== this) {
        // XXX this would override any finally(e) clauses.
        //if (!is_cfx(rv))
        //  rv = val;
        //console.log(this+' abort returning '+rv);
        return rv;
      }
      else {
        this.rv = val; // XXX not sure this is necessary, since we passed 'val' to 'cont', above
        this.async = true;
      }
      // & fall through. we need to block
    }
  }
  return this;
};

function I_try(ndata, env) {
  return cont(new EF_Try(ndata, env), 0);
}

//exports.Try = makeINCtor(I_try);
exports.Try = function(...args) {
  return {
    exec: I_try,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Loop : instruction node for looping constructs

// structure of ndata array:
#define NDATA_LOOP_INIT_STATE() ndata[0]
#define NDATA_LOOP_TEST() ndata[1]
#define NDATA_LOOP_INC() ndata[2]
#define NDATA_LOOP_BODY(i) ndata[i+1]

/*
  continuation index:
   0 : perform test next
   2 - ndata.length+2 : perform body NDATA_LOOP_BODY+i-2 next
   1 : perform inc next 
*/

function EF_Loop(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Loop.prototype={});
#ifdef EF_TYPES
EF_Loop.prototype.type = "Loop";
#endif

EF_Loop.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (this.aborted) {
    if (is_cfx(val)) {
      if (val.type === 'c' || val.type === 'b') val = UNDEF;
    }
    return this.returnToParent(val);
  }
  else {
    while (true) {
      // test:
      if (idx === 0) {
        if (is_cfx(val) || this.aborted) {
          // maybe return value from body here
          return this.returnToParent(val);
        }
        // perform loop test
        val = execIN(this.NDATA_LOOP_TEST(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying; stack-tests 26
          return this;
        }
        idx = 2; // body next
      }
      // body:
      if (idx > 1) {
        if (idx === 2) {
          // examine return value from loop test:
          if (!val || is_cfx(val) || this.aborted) {
            // maybe return value from body here
            return this.returnToParent(val);
          }
        }
        while (1) {
          if (idx > 2) {
            if (is_cfx(val)) {
              if (val.type === 'blb_old' && this.env.blscope && val.eid === this.env.blscope.sid) {
                // blocklambda return
                val = UNDEF;
              }
              else {
                if (val.type === "b") {
                  // break statement
                  val = UNDEF;
                }
                else if (val.type === "c") {
                  // continue statement
                  val = UNDEF;
                  // break out of the loop; pick up again at increment:
                  break;
                }
                return this.returnToParent(val);
              }
            }
            if (idx >= this.ndata.length)
              break; // pick up at increment
          }
            
          // perform body
          if (this.child_frame) {
            this.child_frame.parent = UNDEF;
            this.child_frame = UNDEF; // ensure correct reentrant aborting & prevent callstack copying 
          }
          val = execIN(this.NDATA_LOOP_BODY(idx), this.env);
          if (this.aborted) {
            // a reentrant abortion
            if (is_ef(val)) {
              val.quench(); // not sure this is needed here XXX
              val = val.abort(this.pseudo_abort);
              // the is_ef check is crucial here, because the frame might still produce 'break's which the loop
              // must see - (see sjs-2-tests 'blocking finally clause in loop is abort point' ?)
              if (!is_ef(val))
                return this.returnToParent(val);
            }
          }
          ++idx;
          if (is_ef(val)) {
            this.setChildFrame(val, idx);
            return this;
          }
        }
        idx = 1;
      }
      // this point will be reached directly if idx = 1
      if (this.NDATA_LOOP_INC())  {
        // perform inc
        val = execIN(this.NDATA_LOOP_INC(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 27
          return this;
        }
      }
      idx = 0;
    }
  }
};

function I_loop(ndata, env) {
  return cont(new EF_Loop(ndata, env), NDATA_LOOP_INIT_STATE(), true);
}

//exports.Loop = makeINCtor(I_loop);
exports.Loop = function(...args) {
  return {
    exec: I_loop,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// ForIn : instruction node for 'for-in' loops

// structure of ndata array
#define NDATA_FORIN_OBJ()  ndata[0]
#define NDATA_FORIN_LOOPF() ndata[1]

/*
  continuation index:
   0   : start
   1   : returning from evalution of forin obj
   2   : returning from loopf
*/

function EF_ForIn(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_ForIn.prototype={});
#ifdef EF_TYPES
EF_ForIn.prototype.type = "ForIn";
#endif

EF_ForIn.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == 0) {
      val = execIN(this.NDATA_FORIN_OBJ(), this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          return this.returnToParent(val);
        }
      }

      if (is_ef(val)) {
        this.setChildFrame(val, 1, true); // prevent callstack copying
        return this;
      }
      idx = 1;
    }
    if (idx == 1) {
      // returning from evaluation of forin obj
      if (is_cfx(val) || this.aborted)
        return this.returnToParent(val);
      var for_in_obj = val;
      for (var x in for_in_obj) {
        if (typeof this.remainingX === 'undefined') {
          val = this.NDATA_FORIN_LOOPF()(this.env,x);
          if (is_cfx(val)) {
              if (val.type == "b") {
                // break statement
                val = UNDEF;
              }
              else if (val.type == "c") {
                // continue
                val = UNDEF;
                continue;
              }
            return this.returnToParent(val);
          }
          if (is_ef(val)) {
            this.remainingX = [];
            this.for_in_obj = for_in_obj;
          }
        }
        else
          this.remainingX.push(x);
      }
      if (is_ef(val)) {
        if (!this.remainingX) this.remainingX = [];
        this.setChildFrame(val, 2, true); // prevent callstack copying
        return this;
      }
      // all done
      return this.returnToParent(val);
    }
    if (idx == 2) {
      while (1) {
        // returning from evaluation of loop
        if (is_cfx(val) || this.aborted) {
            if (val.type == "b") {
              // break
              val = UNDEF;
            }
            else if (val.type == "c") {
              // continue
              val = UNDEF;
              if (this.remainingX.length)
                continue;
            }            
          return this.returnToParent(val);
        }
        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying
          return this;
        }
        var arg;
        while (true) {
          if (!this.remainingX.length) {
            this.for_in_obj = undefined;
            return this.returnToParent(val);
          }
          arg = this.remainingX.shift();
          if (arg in this.for_in_obj)
            break;
        }
        val = this.NDATA_FORIN_LOOPF()(this.env, arg);
        // go round the loop again
      }
    }
  }
};

function I_forin(ndata, env) {
  return cont(new EF_ForIn(ndata, env), 0);
}

//exports.ForIn = makeINCtor(I_forin);
exports.ForIn = function(...args/*obj,loop*/) {
  return {
    exec: I_forin,
    ndata: args, //[obj,loop],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Par : stratified par construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/


// helper for Par & Alt & Reified:
function mergeExceptions(new_exception, original_exception) { 

  if (is_cfx(new_exception)) {
    if (!is_cfx(original_exception)) {
      return new_exception;
    }
    // else... competing exceptions
    // we'll replace any existing exception only if the new exception is a 'true' exception:
    if (new_exception.type !== 't') return original_exception;
    if (console) {
      // XXX not sure what to do. Create a new exception with two sub-exceptions??
      var msg;
      if (original_exception.type === 't')
        msg = "Multiple exceptions from sub-strata. Swallowing "+original_exception.val;
      else
        msg = "Swallowing control-flow exception of type '"+original_exception.type+"' because it is overridden by a true exception";
      if (console.error) console.error(msg);
      else console.log(msg);
    }
    return new_exception;
  }
  else {
    return original_exception;
  }
}

#ifdef DEBUG_VM
var par_counter = 0;
#endif

function EF_Par(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++par_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Par.prototype={});
#ifdef EF_TYPES
EF_Par.prototype.type = "Par";
#endif

EF_Par.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        val = execIN(this.ndata[i], this.env);
        exports.current_dyn_vars = parent_dyn_vars;
        if (this.inner_aborted) {
          // this check is to catch the case of reentrant abortion through
          // suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else if (is_cfx(val)) {
          // an exception aborts all other pending branches:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      }
      // we clear ndata here to:
      //   (a) serve as an indication that we're done with kicking off all children. If ndata is not
      //       UNDEF, we know that we're being called reentrantly - not used yet: see also comment at start of
      //       returnToParent
      //   (b) to aid garbage collection
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension or called reentrantly from a branch that is continued by another branch
      --this.pending;
      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted && 
          !(val.type === 'blb_old' && this.env.blscope && val.eid === this.env.blscope.sid)) {
        // an exception aborts all other pending branches: (but only
        // if it is not a blb break targetted at us - this can happen
        // when a break is tail-called: see "sjs-2-tests:tailcalled blocklambda break / par edge case")
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending < 2) {
      if (this.pendingCFE === undefined) {
        // 'normal' return path:
        
        if (this.pending === 0)
          return this.returnToParent(val);
        // make a tail-call if there is only one last pending child:
        var return_child;
        for (var i=0; i<this.children.length; ++i)
          if ((return_child = this.children[i])) { 
            // We must NOT delete the child array here
            // to prevent a reentrancy case (see sjs-2-tests:par-reentrant-tailcall-edgecase)
            // this.children = undefined;
            return this.returnToParent(return_child);
          }
        return this.returnToParent(new CFException("i", "invalid state in Par"));
      }
      else {
        // There is a pending control flow exception which we need to return.
        // Therefore we can't do a tail call.

        // make sure a real exception overrides a normal control flow exception
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        if (this.pending === 0)
          return this.returnToParent(this.pendingCFE);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Par.prototype.quench = quenchPar;

EF_Par.prototype.abort = function(pseudo_abort) {
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    return this;
    //return this.pendingCFE;
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  return this.abortInner();
};

EF_Par.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a
  // branch excepts)
  // Note that it can be called multiple times in case of reentrant aborts
//  console.log(this+'EF_Par pending before child abort:'+this.pending);
  this.inner_aborted = true;
  for (var i=0; i<this.children.length; ++i)
    if (this.children[i]) {
      var val = this.children[i].abort(this.pseudo_abort);
      if (is_ef(val)) // need to wait on this one...
        this.setChildFrame(val, i);
      else {
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        // aid gc, but note that this will mask any superfluous (and
        // incorrect) cont-calls from the child:
        //this.children[i].parent = UNDEF;

        --this.pending;
        this.children[i] = UNDEF;
      }
    } 

  if (!this.pending) // all done
    return this.pendingCFE; // if there is no pending cfe, pendingCFE is undefined
  // we need to wait:
  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Par.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/and: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.push(['WAITFOR/AND', child_trees]);
    return st;
  };
#endif

EF_Par.prototype.setChildFrame = setChildFramePar;

function I_par(ndata, env) {
  return cont(new EF_Par(ndata, env), -1);
}

//exports.Par = makeINCtor(I_par);
exports.Par = function(...args) {
  return {
    exec: I_par,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Alt : stratified alt construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/

#ifdef DEBUG_VM
var alt_counter = 0;
#endif

function EF_Alt(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++alt_counter;
#endif
  this.ndata = ndata;
  this.env = env;

  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Alt.prototype={});
#ifdef EF_TYPES
EF_Alt.prototype.type = function() {return "Alt(aborted="+!!this.aborted+")"};
#endif

EF_Alt.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        // create a new environment for 'collapse' support
        // XXX it sucks that we have to create a new environment for each branch here 
        var env = copyEnv(this.env);
        env.fold = this;
        env.branch = i;
        val = execIN(this.ndata[i], env);
        exports.current_dyn_vars = parent_dyn_vars;
                     
        if (this.inner_aborted) {
          // the check for !aborted here is to catch the case of
          // reentrant abortion through suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          return this.pendingRV;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else {
          // an exception or real value aborts all other pending branches:
          this.pendingRV = val;
          this.quench();
          return this.abortInner();
        }
        if (this.collapsed) break; // don't start any other branches
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension. 
      --this.pending;
      this.children[idx] = UNDEF;
      this.pendingRV = mergeExceptions(val, this.pendingRV);

      if (this.collapsing) {
        // we're returning from an async abort after collapsing
        // (uncommon case; see comment below)
        if (this.pending == 1) {
          // only our collapsing branch is left; continue with it
          var cf = this.collapsing.cf;
          this.collapsing = UNDEF;
          cont(cf, 1);
        }
        return;
      }
      else {
        // 'normal' case

        // abort all pending branches
        if (!this.inner_aborted) {
          if (this.pendingRV === undefined)
            this.pendingRV = val;
          this.quench();
          return this.returnToParent(this.abortInner());
        }
        if (this.pending == 0)
          return this.returnToParent(this.pendingRV);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Alt.prototype.quench = function(except) {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench'.
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally

  if (this.collapsing) {
    // we're being quenched after a collapse; just quench the collapsing branch
    this.children[this.collapsing.branch].quench();
  }
  else {
    // common case, quench all branches (possibly except 'except')
    for (var i=0; i<this.children.length; ++i) {
      if (i!== except && this.children[i])
        this.children[i].quench();
    }
  }
};

EF_Alt.prototype.abort = function(pseudo_abort) {
  // XXX not sure what the rationale was here
  //this.parent = UNDEF;
  if (this.aborted) {
    //XXX not sure what the rationale was here
    //this.pendingRV = UNDEF;
    return this;
  }

  this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  var rv;
  if (!this.inner_aborted) {
    rv = this.abortInner();
  }
  else if (this.pending)
    rv = this;

  this.pendingRV = this.pendingRV;
  if (rv !== this && !is_cfx(rv)) rv = this.pendingRV;
  return rv;
};

EF_Alt.prototype.abortInner = function() {
//  ASSERT(!this.inner_aborted);

  // see Par::abortInner for more details
  this.inner_aborted = true;
  if (this.collapsing) {
    // we're being aborted after a collapse; just need to abort the collapsing branch
    var branch = this.collapsing.branch;
    this.collapsing = UNDEF;
    var val = this.children[branch].abort(this.pseudo_abort);
    if (is_ef(val)) // need to wait
      this.setChildFrame(val, branch);
    else {
      --this.pending;
      this.children[branch] = UNDEF;
    }
  }
  else {
    // common case: abort all branches
    for (var i=0; i<this.children.length; ++i)
      if (this.children[i]) {
        var val = this.children[i].abort(this.pseudo_abort);
        if (is_ef(val)) // need to wait
          this.setChildFrame(val, i);
        else {
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          --this.pending;
          this.children[i] = UNDEF;
        }
      }
  }
  if (!this.pending)
    return this.pendingRV;
  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Alt.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/or: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.concat([['WAITFOR/OR', child_trees]]);
    return st;
  },
#endif

EF_Alt.prototype.setChildFrame = setChildFramePar;

EF_Alt.prototype.docollapse = function(branch, cf) {
  this.collapsed = true;
  var have_async_branch_retract = false;
  // abort all children apart from 'branch'
  this.quench(branch);
  for (var i=0; i<this.children.length; ++i) {
    if (i == branch) continue;
    if (this.children[i]) {
      var val = this.children[i].abort();
      if (is_ef(val)) { // need to wait
        have_async_branch_retract = true;
        this.setChildFrame(val, i);
      }
      else {
        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  }
  if (!have_async_branch_retract) {
    ASSERT(this.pending <= 1); // =0 for sync case, =1 for async case 
    return true;
  }
  // ... else we need to wait
  // this happens if there is an asynchronous retract or finally clause 
  // in one of the aborted branches 
  this.collapsing = { branch:branch, cf:cf};
  return false;
};

function I_alt(ndata, env) {
  return cont(new EF_Alt(ndata, env), -1);
}

//exports.Alt = makeINCtor(I_alt);
exports.Alt = function(...args) {
  return {
    exec: I_alt,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// WfW: stratified waitfor-while construct
/*
   ndata[0] = controlled branch / children[0]
   ndata[1] = controlling branch / children[1]

   continuation index:
   -1: start
*/

function EF_WfW(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(2);
}
setEFProto(EF_WfW.prototype={});
#ifdef EF_TYPES
EF_WfW.prototype.type = function() {return "WfW(aborted="+!!this.aborted+")"};
#endif

EF_WfW.prototype.cont = function(idx, val) {
  //console.log("wfw cont("+idx+","+val+",pending="+this.pending+")");
  if (is_ef(val)) {
    // child frame being replaced
    this.setChildFrame(val, idx);
  }
  else {
    if (idx === -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off children
      for (var i=0; i<2;++i) {
        val = execIN(this.ndata[i], this.env);
        exports.current_dyn_vars = parent_dyn_vars;
        if (this.inner_aborted) {
          if (is_ef(val)) {
            // reentrant abortion through suspend/resume
            // (sjs-3-tests:'waitfor/while:reentrant quench',
            //  sjs-3-tests:'reentrant edge case')
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else if (is_cfx(val) || i===1) {
          // an exception in either branch or a 'normal' exit from the 
          // second branch aborts the WfW:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension (or called reentrantly from a branch that is continued by
      // another branch)
      --this.pending;

      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted &&
          !(val.type === 'blb_old' && this.env.blscope && val.eid === this.env.blscope.sid)) {
        // an exception aborts all other pending branches: (but only
        // if it is not a blb break targetted at us - this can happen
        // when a break is tail-called: "see sjs-3-tests:tailcalled blocklambda break / wfw edge case")
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    
    if (this.pending === 1) {
      if (this.pendingCFE === undefined && this.children[1]) {
        // we can make a tailcall:
        return this.returnToParent(this.children[1]);
      }
      else if (this.children[0]) {
        // we only have the controlled branch left; abort it:
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending === 0) {
      // XXX do we need the mergeExceptions call here?
      return this.returnToParent(mergeExceptions(val, this.pendingCFE));
    }

    this.async = true;
    return this;
  }
};

EF_WfW.prototype.quench = quenchPar;

EF_WfW.prototype.abort = function(pseudo_abort) {
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    return this;
    //return this.pendingCFE;
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.pendingCFE = this.pendingCFE;
  this.aborted = true;
  return this.abortInner();
};

EF_WfW.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a 
  // branch excepts or when the 2nd branch returns)
  this.inner_aborted = true;
  // we always want to abort the second branch before the first
  if (this.children[1]) {
    var val = this.children[1].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      //XXXUN this.setChildFrame(val, 1);
      this.async = true;
      return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[1] = UNDEF;
    } 
  }
  if (this.children[0]) {
    var val = this.children[0].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      //XXXUN this.setChildFrame(val, 0);
      this.async = true;
     return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[0] = UNDEF;
    }
  }
  // assert this.pending === 0
  return this.pendingCFE;
};

EF_WfW.prototype.setChildFrame = setChildFramePar;

function I_wfw(ndata, env) {
  return cont(new EF_WfW(ndata, env), -1);
}
exports.WfW = function(...args) {
  return { exec: I_wfw,
           ndata: args,
           __oni_dis: token_dis };
};

//----------------------------------------------------------------------
// Suspend: stratified suspend operation

#ifdef ASYNC_RESUME
var ResumeQueue = {
  messages: [],
  pickup_pending: false,
  post: function(resume_struct) {
    this.messages.push(resume_struct);
    if (!this.pickup_pending) {
      this.pickup_pending = true;
#ifdef CLIENTSIDE
      setTimeout(function() { ResumeQueue.pickup(); }, 0);
#else
      callAsync(function() { ResumeQueue.pickup(); });
#endif
    }
  },
  pickup: function() {
    this.pickup_pending = false;
    var ms = this.messages;
    this.messages = [];
    for (var i=0; i<ms.length; ++i) {
      var m = ms[i];
      cont(m[0],m[1],m[2]);
    }
  }
};
exports.Q = ResumeQueue;
#endif

// structure of ndata array:
#define NDATA_SUSPEND_SUSPENDFUNC() ndata[0]
#define NDATA_SUSPEND_RETURNFUNC() ndata[1]

/*
  continuation index:
  0: start
  1: returning from execution of suspend function
  2: returning from execution of resume function
  3: returning from abortion of suspend function

  state variables:
  returning: resume function has been called or suspend threw
  suspendCompleted: suspend block has executed completely
  retvals: return values as passed into resume function
*/

function EF_Suspend(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Suspend.prototype={});
#ifdef EF_TYPES
EF_Suspend.prototype.type = "Suspend";
#endif

EF_Suspend.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    ASSERT(idx == 1 || idx == 3) //(others shouldn't rebase)
    this.setChildFrame(val, idx);
  }
  else {
    switch (idx) {
    case 0:
    try {
      var ef = this;
      this.dyn_vars = exports.current_dyn_vars;
#ifdef ASYNC_RESUME
      var resumefunc = function(...args) { ResumeQueue.post([ef,2,args]); };
#else
  // XXX We could return something from resumefunc
  var resumefunc = function(...args) {
    try {
      var caller_dyn_vars = exports.current_dyn_vars;
      exports.current_dyn_vars = ef.dyn_vars;
      cont(ef, 2, args);
    }
    catch(e) {
      var s = function() { throw e; };
#if defined (CLIENTSIDE)
      setTimeout(s, 0);
#elif defined (NODEJS)
      process.nextTick(s);
#else
      callAsync(s);
#endif
    }
    finally {
      ef.dyn_vars = undefined; // aid gc
      exports.current_dyn_vars = caller_dyn_vars;
    }
  };

#endif
      // XXX If we want to enable the 'clearOrphanedBLR' functionality in the bridge
      // then we need to reflect the execution frame onto the resume function here:
      //resumefunc.ef = ef; 

      //      LOG("executing suspend")
      val = this.NDATA_SUSPEND_SUSPENDFUNC()(this.env, resumefunc);
    }
    catch (e) {
      // XXX is this required??
      val = new CFException("t", e);
    }
    //    LOG('done executing suspend')
    // At this point we might have received a reentrant callback
    // from the resume function!!
    if (this.returning) {
      //      LOG('reentrant cb')
      if (is_ef(val)) {
        ASSERT(!this.child_frame)
        // processing up to here has been synchronous; we still need to abort
        this.setChildFrame(val, /* not relevant */0);
        this.quench();
        val = val.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          // get parent to wait for us:
          this.async = true;
          return this;
        }
        // ... else fall through
      }
      return cont(this, 3, null);
    }
    
    if (is_ef(val)) {
      this.setChildFrame(val, 1);
      return this;
    }
    case 1:
    // returning from execution of suspend function
    if (is_cfx(val)) {
      this.returning = true;
      break;
    }
    this.suspendCompleted = true;
    // suspend:
    this.async = true;
    return this;
    case 2:
    // returning from execution of resume function.        
    // Note that this might happen reentrantly, while we're still
    // processing the suspend block!!!
    if (this.returning) {
      // this is a trailing resume which we can safely ignore
      return;
    }
    this.returning = true;
    if (is_cfx(val)) {
      // sanity check
      // this shouldn't happen
      val = new CFException("i", "Suspend: Resume function threw ("+val.toString()+")");
      break;
    }
    this.retvals = val;
    if (!this.suspendCompleted) {
      // abort the suspend block:
      if (!this.child_frame) {
        // The suspend block is still executing synchronously.
        // This is a reentrant invocation of 'resume'.
        // We'll pick up with processing again when the suspend block is done
        this.returning = true;
        return;
      }
      else {
        this.quench();
        val = this.child_frame.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          return this;
        }
        // ... else fall through to case 3
        //        LOG('synchronous abortion')
          }
    }
    case 3:
    // set values with return function:
    try {
      this.NDATA_SUSPEND_RETURNFUNC().apply(this.env, this.retvals);
      val = UNDEF;
    }
    catch (e) {
      val = new CFException("i", "Suspend: Return function threw ("+e+")");
    }
    break;
    case 4:
      // return from external abort
      // fall through to returnToParent
      break;
    default:
    val = new CFException("i", "Invalid state in Suspend ("+idx+")");
    }
    return this.returnToParent(val);
  }
};

EF_Suspend.prototype.quench = function() {
  this.returning = true; // prevent resume() calls from having any effect
  if (!this.suspendCompleted)
    this.child_frame.quench();
};

EF_Suspend.prototype.abort = function(pseudo_abort) {
  //  LOG('SUSPEND abort (childf='+this.child_frame+')')
  exports.current_dyn_vars = this.dyn_vars;
  this.returning = true;
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  if (!this.suspendCompleted) {
    var abort_val = this.child_frame.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      this.setChildFrame(abort_val, 4);
      return this; // need to stay in picture, because abort must not return child frame
    }
    else {
      return abort_val;
    }
  }
  return UNDEF;
};

function I_sus(ndata, env) {
  return cont(new EF_Suspend(ndata, env), 0);
}

//exports.Suspend = makeINCtor(I_sus);
exports.Suspend = function(...args/*s,r*/) {
  return {
    exec: I_sus,
    ndata: args, //[s,r],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// _task

// structure of ndata array:
#define NDATA_TASK_LINE() ndata[0]
#define NDATA_TASK_EXP() ndata[1]

// continuation index:
// 0: start
// 1: returning from async execution
// 2: returning from async parent stratum abortion during block lambda return

#ifdef DEBUG_VM
var task_counter = 0;
#endif
  
function EF_Task(ndata, env, notifyAsync, notifyVal, notifyAborted) {
#ifdef DEBUG_VM
  this.id = ++task_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.notifyAsync = notifyAsync;
  this.notifyVal = notifyVal;
  this.notifyAborted = notifyAborted;
}
setEFProto(EF_Task.prototype={});
#ifdef EF_TYPES
EF_Task.prototype.type = "Task";
EF_Task.prototype.toString = function() { return "<Task"+this.id+"@"+this.env.file.substr(-20)+":"+this.ndata[0]+'>' };
#endif

EF_Task.prototype.cont = function(idx, val) {

  if (idx == 0) {
    // Set this.abort_path to the spawned stratum (if any) that we were started from.
    // We'll use this information to resolve abort cycles across strata:
    this.abort_path = exports.current_dyn_vars ? exports.current_dyn_vars.__oni__spawned_stratum : null;
    this.parent_dyn_vars = exports.current_dyn_vars;
    // Inject ourselves as the new spawned stratum into the dynamic vars seen by our stratum's 
    // code:
    exports.current_dyn_vars = Object.create(this.parent_dyn_vars);
    exports.current_dyn_vars.__oni__spawned_stratum = this;
    val = execIN(this.NDATA_TASK_EXP(), this.env);
    // Reset dyn vars:
    exports.current_dyn_vars = this.parent_dyn_vars;
    if (is_cfx(val) && (val.type === 'blb_old' || (val.type === 'r' && val.eid))) {
      return val;
    }
  }
  else if (idx === 2) {
    // returning from waiting for an aborted frame
    if (is_ef(val)) {
      this.setChildFrame(val, 2);
      return this.returnToParent(this);
    }
    else if (!is_cfx(val) || ((val.type !== 'r' || !val.eid) && val.type !== 'blb_old')) {
      // For blocklambda breaks and returns we fall through to the cfx handling below, so that they
      // get propagated appropriately.
      this.in_abortion = false;
      this.done = true;
      this.abort_path = undefined; // aid gc

      this.notifyVal(this.return_val, true);
      this.notifyAborted(val);

// XXX not sure what this is for
//      if (this.aborted && !is_cfx(this.return_val)) {
//        this.return_val = UNDEF;
//      }

      return this.returnToParent(this.return_val);
    }
  }

  if (is_cfx(val)) {
    if (val.type === 'r' && val.eid) {
      // we have a blocklambda return
      // As we don't have a parent to abort, we abort this.env.blrref and
      // arrange for the return value to be passed on to this.env.blrref's parent:
      var frame_to_abort = this.env.blrref;

      if (!frame_to_abort.parent || frame_to_abort.unreturnable /*|| frame_to_abort.aborted*/) {
        this.done = true;
        this.notifyVal(new CFException("t",
                                       new Error("Blocklambda return from spawned stratum to inactive scope"),
                                       this.NDATA_TASK_LINE(),
                                       this.env.file));
        this.notifyAborted(UNDEF);
        return;
      }

      // mark us unabortable:
      this.in_abortion = true;

      // inject ourselves:
      this.parent = frame_to_abort.parent;
      this.parent_idx = frame_to_abort.parent_idx;

      // tell parent about ourselves, so that we get any reentrant abort calls
      cont(this.parent, this.parent_idx, this);
      // for safety, make sure frame_to_abort doesn't send any returns
      // to this.parent. We're taking that role
      frame_to_abort.parent = UNDEF;

      // Abort the frame ('false' will execute 'retract' clauses)
      frame_to_abort.quench();

#ifdef DEBUG_VM
      if (frame_to_abort.aborted) {
        console.log('blk ret trying to abort already aborted frame '+frame_to_abort+'. child_frame = '+frame_to_abort.child_frame);
      }
#endif
      var aborted_target = frame_to_abort.abort(true);
      if (is_ef(aborted_target)) {
        // make sure our aborted target's parent gets the return value:
        this.return_val = val;
        this.setChildFrame(aborted_target, 2);

        // return value to ef & listeners:
        this.notifyVal(UNDEF, true);
        this.notifyAborted(UNDEF);

        // no reason to call notifyAsync here; we've already done that in a previous cont() call
        this.returnToParent(this);
        return;
      }

      this.in_abortion = false;
      this.done = true;


      // return value to ef & listeners:
      this.notifyVal(UNDEF, true);
      this.notifyAborted(UNDEF);

      // return the blr to our aborted target's parent synchronously:
      return this.returnToParent(val.eid === frame_to_abort.sid ? val.val : val);
    }
    else if (val.type === 'blb_old') {
      // we have a blocklambda break
      // As we don't have a parent to abort, we abort this.env.blrref and
      // arrange for the blb to be passed on to this.env.blrref's parent:
      var frame_to_abort = this.env.blrref;

      if (!frame_to_abort.parent || frame_to_abort.unreturnable || frame_to_abort.aborted) {
        this.done = true;
        this.notifyVal(new CFException("t",
                                       new Error("Blocklambda break from spawned stratum to invalid or inactive scope"),
                                       this.NDATA_TASK_LINE(),
                                       this.env.file));
        this.notifyAborted(UNDEF);
        return;
      }

      // mark us unabortable:
      this.in_abortion = true;

      // inject ourselves:
      this.parent = frame_to_abort.parent;
      this.parent_idx = frame_to_abort.parent_idx;
      // tell parent about ourselves, so that we get any reentrant abort calls
      cont(this.parent, this.parent_idx, this);
      // for safety, make sure frame_to_abort doesn't send any returns
      // to this.parent. We're taking that role
      frame_to_abort.parent = UNDEF;

#ifdef DEBUG_VM
      if (frame_to_abort.aborted) {
        console.log('blk brk trying to abort already aborted frame '+frame_to_abort+'. child_frame = '+frame_to_abort.child_frame);
      }
#endif
      // Abort the frame:
      frame_to_abort.quench();
      var aborted_target = frame_to_abort.abort(true);
      if (is_ef(aborted_target)) {
        // make sure our aborted target's parent gets the blb:
        this.return_val = val;
        this.setChildFrame(aborted_target, 2);

        // return value to ef & listeners:
        this.notifyVal(UNDEF, true);
        this.notifyAborted(UNDEF);

        // no reason to call notifyAsync here; we've already done that in a previous cont() call
        this.returnToParent(this);
        return;
      }

      this.in_abortion = false;
      this.done = true;


      // return value to ef & listeners:
      this.notifyVal(UNDEF, true);
      this.notifyAborted(UNDEF);

      // return the blb to our aborted target's parent synchronously:
      return this.returnToParent(val);
    }
  } // is_cfx(val)
  
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    if (idx == 0)
      this.notifyAsync();
  }
  else {
    this.parent_dyn_vars = undefined; // aid gc
    this.in_abortion = false;
    this.done = true;
    this.notifyVal(val);
  }
};

EF_Task.prototype.abort = function(pseudo) {
  // This function is only called by stratum.abort, below, or when we receive a reentrant abort after
  // notifying listeners.
  // We don't need to deal with notifyAsync/notifyVal, because all value listeners 
  // will already have been called.
  if (this.in_abortion) return this;
  if (this.done) return UNDEF;

  this.in_abortion = true;
  if (this.child_frame) {
    this.child_frame.quench();
    var val = this.child_frame.abort(pseudo); 
    if (is_ef(val)) {
      // we need to wait
      this.setChildFrame(val, 2);
      return this;
    }
    else {
      this.in_abortion = false;
      this.done = true;
      return val;//UNDEF;
    }
  }
};

function EF_TaskWaitFrame(waitarr) {
  this.dyn_vars = exports.current_dyn_vars;
  this.waitarr = waitarr;
  waitarr.push(this);
}
setEFProto(EF_TaskWaitFrame.prototype={});
#ifdef EF_TYPES
EF_TaskWaitFrame.prototype.type = "Stratum.value()";
#endif
EF_TaskWaitFrame.prototype.quench = dummy;
EF_TaskWaitFrame.prototype.abort = function() {
  var idx = this.waitarr.indexOf(this); // assert != -1
  this.waitarr.splice(idx, 1);
  return UNDEF;
}
EF_TaskWaitFrame.prototype.cont = function(val) {
  if (this.parent) {
    var current_dyn_vars = exports.current_dyn_vars;
    exports.current_dyn_vars = this.dyn_vars;
    this.dyn_vars = undefined; // aid gc

    if (is_annotated_oni_cfx(val)) {
      // we need to clone the exception, because there might be several value listeners which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      val = cloneAnnotatedCFX(val);

      // append callstack leading out of this `.value()` call:
      if (this.callstack)
        val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
    }

    cont(this.parent, this.parent_idx, val);
    exports.current_dyn_vars = current_dyn_vars;
  }
}

function EF_TaskAbortFrame(waitarr, task_frame) {
  this.dyn_vars = exports.current_dyn_vars;
  this.waitarr = waitarr;
  waitarr.push(this);
  var me = this;
  nextTick(function() { me.resolveAbortCycle(task_frame); });

}
setEFProto(EF_TaskAbortFrame.prototype={});
#ifdef EF_TYPES
EF_TaskAbortFrame.prototype.type = "Stratum.abort()";
#endif
EF_TaskAbortFrame.prototype.quench = dummy;
EF_TaskAbortFrame.prototype.abort = function() {
  // to ensure proper sequencing of finally clauses, abort is unabortable
  this.aborted = true;
  return this;
}
EF_TaskAbortFrame.prototype.cont = function(val) {
  if (this.done) return;
  if (this.parent) {
    var current_dyn_vars = exports.current_dyn_vars;
    exports.current_dyn_vars = this.dyn_vars;
    this.dyn_vars = undefined; // aid gc
    this.done = true;
    if (this.aborted && !is_cfx(val) && this.parent.aborted)
      val = UNDEF;

    if (is_annotated_oni_cfx(val)) {
      // we need to clone the exception, because there might be several abort() calls which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      val = cloneAnnotatedCFX(val);

      // append callstack leading out of this `.abort()` call:
      if (this.callstack) {
        val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
      }
    }


    cont(this.parent, this.parent_idx, val);
    exports.current_dyn_vars = current_dyn_vars;
  }
  else if (is_cfx(val) && (val.type === 't' || val.val instanceof Error)){
    // make sure exceptions end up somewhere
    hold0(function() { val.mapToJS(true); });
  }
}
EF_TaskAbortFrame.prototype.resolveAbortCycle = function(task_frame) {
  if (this.done) return;
  var parent = this.parent;
  while (parent) {
    if (task_frame === parent) {
// Turn this warning off, as we use cyclic aborts quite frequently
//      var msg = "Warning: Cyclic stratum.abort() call from within stratum." + stack_to_string(this.callstack);
//      if (console) {
//        if (console.error) console.error(msg);
//        else console.log(msg);
//      }
      this.cont(UNDEF);
      return;
    }
    // If parent is null, we'll try 'abort_path', which will be set on EF_Task frames
    // that were started from other EF_Task's. It allows abort cycles across strata.
    parent = parent.parent || parent.abort_path;
  }
};


function TaskStratumProto() {}
exports.TaskStratumProto = TaskStratumProto;

// waitforValue deprecated:
TaskStratumProto.prototype.waitforValue = function() { return this.value() };
TaskStratumProto.prototype.toString = function() {return "[object TaskStratum]"; };


function I_task(ndata, env) {
  var val, async, have_val, picked_up=false;
  var value_waitarr = [];
  var abort_waitarr = [];

  // copy environment and reset blocklambda scope/refs, so that we 
  // don't get GC reference cycles
  env = copyEnv(env);
  env.blscope = null;
  env.blbref = null;
  // we need blrref for routing blb breaks from the spawned stratum; see EF_Task.prototype.cont
  // see also sjs-2-tests::'detached async blocklambda break 1'
  //env.blrref = null;


  var stratum = new TaskStratumProto();
  stratum.abort = function(pseudo) {
    var dyn_vars = exports.current_dyn_vars;
    
    if (ef.done) return UNDEF;

    // the 'in_abortion' check is important, or we might end up with deadlock, when an abort() call
    // in a finally clause is waiting for the task frame and vice versa, as in:
    // try { stratum = _task ({||hold(0); return})(); stratum.value(); }finally { stratum.abort() }
    if (ef.in_abortion) {
      return new EF_TaskAbortFrame(abort_waitarr, ef);
    }

    // we abort synchronously (i.e. abort() will block for any blocking finally clauses,
    // but any value listeners will receive a 'stratum aborted' notification immediately
    var rv = ef.abort(pseudo);

    exports.current_dyn_vars = dyn_vars;
    
    async = false;

    // value listeners will get a 'stratum aborted' exception'
    // any 'real' exception thrown during abortion will only go to the abort call itself.
    val =  new CFException("t",
                           new StratumAborted(),
                           NDATA_TASK_LINE(),
                           env.file);
    while (value_waitarr.length)
      cont(value_waitarr.shift(), val);
    
    if (is_ef(rv)) {
      return new EF_TaskAbortFrame(abort_waitarr, ef);
    }
    
    if (!is_cfx(rv))
      rv = UNDEF;
    notifyAborted(rv);


    if (is_annotated_oni_cfx(rv)) {
      // we need to clone the exception, because there might be several abort() calls which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      rv = cloneAnnotatedCFX(rv);
      // throw the value (rather than returning), so that the callstack gets amended by the 
      // calling code:
      throw rv.val;
    }

    return rv;
  };

  stratum.value = function() {
    if (!async) { 
      picked_up=true; 
      if (is_annotated_oni_cfx(val)) {
        // we need to clone the exception, because there might be several value listeners which
        // all get their stack amended differently.
        // See also note at top of definition of `is_annotated_oni_cfx`
        var v = cloneAnnotatedCFX(val);
        // throw the value (rather than returning), so that the callstack gets amended by the
        // calling code:
        throw v.val;
      }
      return val; 
    }
    return new EF_TaskWaitFrame(value_waitarr);
  };
    
  stratum.running = function() { return async; };

  stratum.waiting = function() {
    return value_waitarr.length;
  };
     
  // Undocumented '_adopt' feature:
  // _adopt is used to embed a stratum in a different scope for blreturns/breaks.
  // It is used for continuation buffers. 
  // See unit/sjs-3-tests:'return via different scope with _adopt'.
  // XXX There is probably a better way to expose this feature, therefore it is 
  // undocumented at this point.
  stratum._adopt = function(blrref) {
    //console.log(this+" adopting "+blrref+" as blrref. Was: "+ef.env.blrref);
    ef.env.blrref = blrref;
  };

  function notifyAsync() {
    async = true;
  }
  function notifyVal(_val, have_caller) {
    if (val !== undefined) // this guard is important so that a
      return;              // reentrant 'stratum aborted' exception
                           // doesn't get overwritten by a later result
    val = _val;
    async = false;
    if (!have_caller && !value_waitarr.length) {
      // make sure exceptions that noone is waiting on get reported in
      // console. Only report stray control flow exceptions & exceptions that
      // are instanceof Error;
      // IE shows a popup for uncaught exceptions, and exceptions
      // without linenumbers etc are very confusing
      if (is_cfx(val) && (val.type != 't' || val.val instanceof Error)) {
        // XXX unfortunately stray control flow exceptions, such as
        // e.g. returns from blocklambdas, will not have line numbers
        // attached. Maybe we shouldn't report them?
        //
        // It is essential that we throw the exception *asynchronously*
        // when async = false. Otherwise it will end up at our
        // caller. For simplicity we always throw asynchronously:
        setTimeout(function() { 
          // We only throw if the value hasn't been picked up in the
          // meanwhile. This is for cases where we have:
          //   var stratum = _task synchronous_throw_here;
          //   stratum.value();
          // We want to prevent the exception feeding to the user twice in this case
          if (!picked_up)
            val.mapToJS(true); 
        }, 0);
      }
    }
    else {
      while (value_waitarr.length)
        cont(value_waitarr.shift(), val);
    }
    
  }
  function notifyAborted(_val) {
    if (!is_cfx(_val) || _val.type !== 't')
      _val = UNDEF;
    while (abort_waitarr.length)
      cont(abort_waitarr.shift(), _val);
  }

  var ef = new EF_Task(ndata, env, notifyAsync, notifyVal, notifyAborted);

  // pass through control flow exceptions, or return stratum:
  return cont(ef, 0) || stratum;
}
  
//exports.Task = makeINCtor(I_task);
exports.Task = function(...args/*line, exp*/) {
  return {
    exec: I_task,
    ndata: args, //[line, exp],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// collapse

// structure of ndata array:
#define NDATA_COLLAPSE_LINE() ndata

// continuation index:
// 0: start
// 1: returning from async execution
  
function EF_Collapse(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Collapse.prototype={});
#ifdef EF_TYPES
EF_Collapse.prototype.type = "Collapse";
#endif

// mark us as a collapse frame
EF_Collapse.prototype.__oni_collapse = true;

EF_Collapse.prototype.cont = function(idx, val) {
  if (idx == 0) {
    var fold = this.env.fold;
    if (!fold)
      return new CFException("t", new Error("Unexpected collapse statement"),
                             this.NDATA_COLLAPSE_LINE(), this.env.file);
    if (fold.docollapse(this.env.branch, this))
      return true;
    // else ... we're going async
    this.async = true;
    return this;
  }
  else if (idx == 1) // returning from collapsing
    return this.returnToParent(true);
  else 
    return this.returnToParent(new CFException("t", "Internal error in SJS runtime (collapse)",
                                               this.NDATA_COLLAPSE_LINE(), this.env.file));
};

// don't need to do anything for quenching/aborting. we'll never be prodded by upstream after an abort.
EF_Collapse.prototype.quench = dummy;
EF_Collapse.prototype.abort = function() { this.aborted = true; return UNDEF};

function I_collapse(ndata, env) {
  return cont(new EF_Collapse(ndata, env), 0);
}
  
//exports.Collapse = makeINCtor(I_collapse);
exports.Collapse = function(line) {
  return {
    exec: I_collapse,
    ndata: line,
    __oni_dis: token_dis
  }
};
  
//----------------------------------------------------------------------
// builtin strict functions

// setTimeout has a minimum delay of 4ms; we want hold(0) to be faster
// see e.g. https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
var hold0, clear0;
// Note: we cannot use process.nextTick, because hold(0) must not stall I/O. 
// It would e.g. break 'require-tests:non-circular reference waits for the full module'
// See also https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
if (exports.G.setImmediate) {
  hold0 = exports.G.setImmediate;
  clear0 = exports.G.clearImmediate;
}
/*
similarly to process.nextTick, this will stall I/O:
else if (false && exports.G.Promise) {
  hold0 = function(cb) { Promise.resolve().then(cb); }
  clear0 = function(id) { }
}
*/
else if (exports.G.postMessage && !exports.G.importScripts) {
  var postMessageIsAsync = true;
  var oldOnMessage = exports.G.onmessage;
  exports.G.onmessage = function() {
    postMessageIsAsync = false;
  };
  exports.G.postMessage("", "*");
  exports.G.onmessage = oldOnMessage;
  if (postMessageIsAsync) {
    // install an event handler on `global` for the `message` event;
    // draws heavily from https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
    var MESSAGE_PREFIX = "com.onilabs.hold0" + Math.random();

    var tasks = {};

    function onGlobalMessage(event) {
      if (event.source === exports.G && 
          typeof event.data === 'string' &&
          event.data.indexOf(MESSAGE_PREFIX) === 0) {
        var id = event.data.substring(MESSAGE_PREFIX.length);
        var f;
        if ((f = tasks[id])) {
          delete tasks[id];
          f();
        }
      }
    }

    if (exports.G.addEventListener) {
      exports.G.addEventListener("message", onGlobalMessage, false);
    }
    else {
      exports.G.attachEvent("onmessage", onGlobalMessage);
    }

    var id_counter = 1;

    var hold0 = function(f) {
      var id = id_counter++;
      tasks[id] = f;
      exports.G.postMessage(MESSAGE_PREFIX + id, "*");
      return id;
    };
    
    var clear0 = function(id) {
      delete tasks[id];
    };
  }
}

if (!hold0) {
  hold0 = function(co) { return setTimeout(co, 0) };
  clear0 = clearTimeout;
}

exports.Hold = function(duration_ms) {
  var dyn_vars = exports.current_dyn_vars;

  function abort() {
    //console.log('HOLD ABORT sus.parent='+(sus ? sus.parent:'undef'));
    // restore dyn vars for finally clauses
    exports.current_dyn_vars = dyn_vars;
    return UNDEF;
  }
  
  if (duration_ms === UNDEF)
    return { 
#ifdef EF_TYPES
             toString: function() { return "<HOLD()>"; },
#endif
             __oni_ef: true,
             wait: function() { return this; },
#ifdef DEBUG_VM
             gatherSuspensionTree: function() { return [this.toString()] },
#endif
             quench: dummy,
             abort: abort
           };

  if (duration_ms === 0) {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD(0)>"; },
#endif
                __oni_ef: true, 
                wait: function() { return this },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
                quench: function() { sus = null; clear0(this.co); },
                co: hold0(function() {
                  if (sus && sus.parent) {
                    exports.current_dyn_vars = dyn_vars;
                    cont(sus.parent, sus.parent_idx, UNDEF);
                    exports.current_dyn_vars = null;
                  }
                })
              };
    return sus;
  }
  else {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD("+duration_ms+"ms)>"; },
#endif
                __oni_ef: true,
                wait: function() { return this },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
#if defined (CLIENTSIDE) || defined (NODEJS)
                quench: function() { sus = null; clearTimeout(this.co); }
#else
                quench: function() { sus = null; this.co.cancel(); }
#endif
              };
    sus.co = setTimeout(
      function() {
        if (sus && sus.parent) {
          exports.current_dyn_vars = dyn_vars;
          cont(sus.parent, sus.parent_idx, UNDEF);
          exports.current_dyn_vars = null;
        }
      },
      duration_ms);
    return sus;
  }
};

exports.Throw = function(exp, line, file) { return new CFException("t", exp, line, file); };

exports.Arr = function(...args) { return args };

exports.ArrS = function(spreads, ...args) {
  var rv = [];
  for (var i=0; i<args.length; ++i) {
    if (spreads[0] === i) {
      rv = rv.concat(args[i]);
      spreads.shift();
    }
    else
      rv.push(args[i]);
  }
  return rv;
};

exports.Obj = function(...args) {
  // note comment in kernel-sjs.js.in::ph_obj_lit about the way props
  // are encoded into arguments object
  var obj = new Object();
  for (var i=0; i<args[0].length; ++i)
    obj[args[0][i]] = args[i+1];
  return obj;
};

function QuasiProto(parts) {this.parts=parts;}
exports.QuasiProto = QuasiProto;

exports.Quasi = function(...args) {
  return new QuasiProto(args);
};

exports.Return = function(exp) {
  return new CFException("r", exp);
};

exports.Break = function(lbl) {
  return new CFException("b", lbl);
};

exports.Cont = function(lbl) {
  return new CFException("c", lbl);
};

exports.BlBreakOld = function(env, lbl) {
//  return new CFException('blb');
  var e = new CFException('blb_old', lbl);
  if (!env.blbref) {
    console.log(env);
    throw new Error("Internal runtime error; no reference frame in BlBreak");
  }
  if (env.blbref.unreturnable && !env.blbref.toplevel) // the return scope is not active anymore!
    throw new Error("Blocklambda break to inactive scope");
  e.eid = env.blbref.sid;
  return e;
};

exports.BlReturn = function(exp) {
  var e = new CFException('r', exp);
  if (!this.blrref) throw new Error("Internal runtime error; no reference frame in BlReturn");
  if (this.blrref.unreturnable) { 
    if (this.blrref.toplevel)
      throw new Error("Invalid blocklambda 'return' statement; 'return' is only allowed in blocklambdas that are nested in functions");
    else {
      // return scope not active anymore!
      throw new Error("Blocklambda return to inactive function");
    }
  }
  e.eid = this.blrref.sid;
  return e;
};

exports.With = function(exp, bodyf) {
  return bodyf(this, exp);
};

exports.join_str = function(...args) {
  var rv = '';
  for (var i=0,l=args.length;i<l;++i)
    rv += args[i];
  return rv;
};

exports.infix = {
  '+':   function(a,b) { return a+b; },
  '-':   function(a,b) { return a-b; },
  '*':   function(a,b) { return a*b; },
  '/':   function(a,b) { return a/b; },
  '%':   function(a,b) { return a%b; },
  '<<':  function(a,b) { return a<<b; },
  '>>':  function(a,b) { return a>>b; },
  '>>>': function(a,b) { return a>>>b; },
  '<':   function(a,b) { return a<b; },
  '>':   function(a,b) { return a>b; },
  '<=':  function(a,b) { return a<=b; },
  '>=':  function(a,b) { return a>=b; },
  '==':  function(a,b) { return a==b; },
  '!=':  function(a,b) { return a!=b; },
  '===': function(a,b) { return a===b; },
  '!==': function(a,b) { return a!==b; },
  '&':   function(a,b) { return a&b; },
  '^':   function(a,b) { return a^b; },
  '|':   function(a,b) { return a|b; },
  ',':   function(a,b) { return a,b; },
  'instanceof':
         function(a,b) { return a instanceof b; },
  'in':  function(a,b) { return a in b; }
};

#if defined (CLIENTSIDE)
//----------------------------------------------------------------------
// UA sniffing
var UA = navigator.userAgent.toLowerCase();
if (UA.indexOf(" chrome/") >= 0)
  UA = "chrome";
 else if (UA.indexOf(" firefox/") >= 0)
   UA = "firefox";
 else if (UA.indexOf(" safari/") >= 0)
   UA = "safari";
 else if (UA.indexOf(" msie ") >= 0)
   UA = "msie";
 else
   UA = "unknown";
exports.hostenv = "xbrowser";
#elif defined (NODEJS)
var UA = "nodejs";
exports.hostenv = "nodejs";
#endif
exports.UA = UA;

