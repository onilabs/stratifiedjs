/*
 * VM1 Stratified JavaScript Virtual Machine
 *
 * Part of StratifiedJS
 * http://onilabs.com/stratifiedjs
 *
 * (c) 2011-2013 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/*
Preprocessor flags:

define CLIENTSIDE    : for browser-based VM (as opposed to rocket-hosted)
define NODEJS        : for nodejs VM (as opposed to rocket/clientside)

define DEBUG_VM      : VM debugging

define HOTPATH       : don't build execution frames unless we have to

OBSOLETE FLAGS:
    verbose exceptions are always on now; not predicated on this flag anymore:
define VERBOSE_EXCEPTIONS : add line/file/stack members to exceptions
                             (requires compiling c1 with VERBOSE_EXCEPTIONS to
                              get correct values)
                             XXX We should actually only amend Error objects
                             where they are *created*. This code is possibly a
                             bit flaky with exceptions that are thrown by
                             JS code and caught/rethrown by SJS.

*/
#define DEBUG_VM 1
//#define DEBUG_DYNVARS 1
//#define DEBUG_STACK 1
//#define DEBUG_MULTIVM 1

#ifdef DEBUG_VM
function dumpExecutionFrameParents(ef, indent) {
  indent = indent || 0;
  if (ef && ef.parent)
    dumpExecutionFrameParents(ef.parent, indent+1);
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<NULL>';
  console.log(str);
}
function dumpExecutionFrameChildren(ef, indent) {
  indent = indent || 0;
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<NULL>';
  console.log(str);
  if (ef && ef.child_frame)
    dumpExecutionFrameChildren(ef.child_frame, indent+1);
  else if (ef && ef.children) {
    for (var i = 0; i<ef.children.length; ++i) {
      dumpExecutionFrameChildren(ef.children[i], indent+1);
    }
  }
}
#define EF_TYPES
#define LOG(x) console.log(x);
// XXX figure out why normal CPP stringification is screwed
#define ASSERT(X) if(!(X)) { console.log("Assertion failed: " + "X"); throw new Error("Assertion failed: " + "X")}
#define WHENDEBUG(X) X
#else
#define ASSERT(X)
#define LOG(x)
#define WHENDEBUG(X)
#endif

// we don't want to rely on the global 'undefined' symbol; see
// https://groups.google.com/d/msg/oni-apollo/fNMz2W8S5mU/sYCgrriYj1MJ
var UNDEF; // == undefined

// on firefox this seems to help, on v8 it doesn't :-/
//define HOTPATH 1

// maximum size of callstack that we'll record in tail-recursive scenarios:
#define MAX_CALLSTACK 20


function dummy() {}


//----------------------------------------------------------------------

// XXX could consolidate the VMID generation code with sjs:string/sjs:crypto
var random64;
#if defined (CLIENTSIDE)
exports.G = window;
exports.VMID = "X";
var bytes = new Uint8Array(8);
window.crypto.getRandomValues(bytes);
random64 = window.btoa(String.fromCharCode(...bytes));
#elif defined (NODEJS)
exports.G = global;
exports.VMID = "N";
random64 = require('crypto').randomBytes(8).toString('base64');
#endif
exports.VMID += random64.replace(/\//g,'_').replace(/\+/g, '-').replace(/=/g, '');

// XXX
var nextTick;
if (exports.G.process && exports.G.process.nextTick) {
  nextTick  = exports.G.process.nextTick;
}
else if (exports.G.Promise) {
 nextTick = function(cb) { Promise.resolve().then(cb); };
}
else throw new Error("host environment not supported - need 'Promise' or 'nextTick'");


//----------------------------------------------------------------------
// Control Flow Exceptions

/*
{
  __oni_cfx: true,
  type:      "i"(internal)|"r"(return)|"b"(break)|"c"(continue)|"t"(thrown)|"blb"(blklambda break)|
             "blr"(blocklambda return),
  val:       value
}
*/

// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_cfx(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_cfx)
// define is_cfx(obj) (obj instanceof CFException)
/*function is_cfx(obj) {
  return obj && obj.__oni_cfx;
}*/

function stack_to_string(stack) {
  var rv = '';
  if (stack) {
    for (var i=0; i<stack.length; ++i) {
      var line = stack[i];
      if (line.length == 1)
        line = line[0];
      else
        line = '    at ' + line.slice(0,2).join(':');
      rv += '\n' + line;
    }
  }
  return rv;
}

function CFException_toString() {
  return this.name+": "+this.message + stack_to_string(this.__oni_stack);
}

function adopt_native_stack(e, caller_module) {
  if(!e.stack)
    return;
  var stack = String(e.stack);
  // Remove default toString() output, which can take form:
  // - <msg>
  // - <type>
  // - <type>: <msg>
  var firstColon = stack.indexOf(': ');
  var msgStart = (firstColon === -1) ? 0 : firstColon + 2;
  
  // if firstColon appears after a newline, it's not the one we want
  if (stack.lastIndexOf('\n', msgStart) !== -1) msgStart = 0;

  var msg = String(e.message);
  if (msg && stack.lastIndexOf(msg, msgStart) == msgStart) {
    stack = stack.slice(msgStart + msg.length);
  } else {
    // remove sole <type>, assuming type ends with 'Error'
    stack = stack.replace(/^\w*Error/, '');
  }
  delete e.stack;
  var lines = stack.split("\n");
  var i;
  for (i=0; i<lines.length; i++) {
    var line = lines[i];
    if (!line.length) continue;
    // TODO: make this check more reliable
    if((caller_module && line.indexOf(caller_module) !== -1) ||
       line.indexOf(".app!bundle") !== -1 ||
       line.indexOf("stratified-node.js") !== -1 ||
       line.indexOf("stratified.js") !== -1 ) {
      // we've hit an sjs stack line.
      break;
    }
    e.__oni_stack.push([line]);
  }
}

var token_oniE = {}; // oni-modified exception
function CFException(type, value, line, file) {
  this.type = type;
  this.val = value;
  // XXX checking for "value instanceof Error" alone doesn't work for some errors on firefox
  if (type === "t" && 
      (value instanceof Error || (typeof value === 'object' && value != null && value.message))) {
    if (value._oniE !== token_oniE) {
      // annotate the exception object with our oni-special fields:
      value._oniE = token_oniE;
      value.__oni_stack = value.__oni_stack || [];
      value.line = line;
      value.file = file || "unknown SJS source";

      adopt_native_stack(value, file);

      if (!value.hasOwnProperty('toString')) value.toString = CFException_toString;
    }

    // push current line/file onto stack (if provided):
    if (line)
      value.__oni_stack.push([file || 'unknown SJS source', line]);
  }
  // this.eid = UNDEF;  // 'execution frame' tag for targetted return/break/continue
}

var CFETypes = { r:"return", b:"break", c:"continue", blb: "blocklambda break", blr: "blocklambda return"};
CFException.prototype = {
  __oni_cfx : true,
  toString : function() {
    if (this.type in CFETypes)
      return "Unexpected "+CFETypes[this.type]+" statement";
    else
      return "Uncaught internal SJS control flow exception ("+this.type+":: "+this.val+")";
  },
  mapToJS : function(uncaught) {
    if (this.type == "t") {
#if defined (CLIENTSIDE)
      // 'uncaught' means we know this exception won't be caught by SJS.
      // We could throw a plain JS error, but browsers have terrible reporting.
      // Instead, we emulate a good browser's onError handling, with full stack
      // logging on an unhandled error.
      // See https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror
      // XXX is there anything browsers do internally to handle errors other than calling onerror?
      if (uncaught && this.val != null && this.val.__oni_stack) {
        var handler = window.onerror;
        var handled = false;
        var msg = this.val.toString();

        if (handler) {
          // we could probably extract a proper url & lineno here,
          // but who cares when we have the entire stacktrace?
          handled = handler.call(window,
              msg,
              "", // url
              0,  // lineno
              0,  // column
              this.val); // exception
        }
        if (!handled) {
          if (console) {
            if (console.error) console.error(msg);
            else console.log(msg);
          }
        }
      }
      else
#endif // CLIENTSIDE
        throw this.val;
    }
    else if (!this.aid && !this.eid) // XXX DO WE NEED THIS???
      throw new Error(this.toString());
    else // this is a 'blb' or 'blr' tunneling through a JS functions:
      throw this;
  }
};

// exported for use in bridge, to remote blbreaks:
exports.CFException = CFException;

#define is_annotated_oni_cfx(obj) (is_cfx(obj) && obj.type === 't' && obj.val != null && obj.val._oniE === token_oniE)

//----------------------------------------------------------------------
// Dynamic variable support:

// current_dyn_vars is a global variable holding dynamic variable
// bindings for the currently stratum. 
// We cannot use 'Env' for this, because environments get reset at every function
// boundary (to support SJS being callable from JS)

// The bindings can be amended for a given stratum with `withDynVarContext`, which creates
// a new dyn vars object with the current dyn vars as parent.
// When a stratum blocks (at a hold() or waitfor() { resume }), the blocking EF will store the
// current dynvar context.
// When a blocking EF resumes (or is aborted), it pages in the stored dynvar context again.
// A blocking EF also pages in the root dynvar context when blocking and returning up the stack.
// This is done so that any external asynchronous invocations (such as via a setTimeout or
// addEventListener) always see the root dynvar context. EFs that continue excuting code after one of
// their child EFs has blocked need to store the current dynvar context before executing their 
// children and page it back in before resuming with the next child.

// current dynvar context will be remembered and paged back in when the stratum resumes. Furthermore,
// the context will be remembered and reset whenever there is a parallel continuation (Par, Alt, WfW, spawn).

// Dynamic variable contexts are also used to maintain a chain of blocklambda anchors:
// EF_FAcall hands its arguments an amended context with __oni_anchor_route set to its parent 
// context and __oni_anchor set to itself.

/*

Some context switching guidelines:

(1) We need to *start* an EF with the correct DC
(2) If we execute something right after calling cont()/execIN, we need to restore the correct EF. Special care has to be taken when running JS code that continues on to SJS code, such as in apollo-sys-common::spawn, or cutil::Waitable.emit. See comments there
(3) On blocking (i.e. if we return an EF), we need to return the root DC - whether for cont or abort
(4) On resuming a blocked EF, we need to restore the original DC
(5) On aborting a blocked EF, we need to restore the original DC
(6) Reified is special: Because of adoption, its parent DC might not be its own DCs:
  (a) whenever a child stratum calls cont() on a Reified, the Reified must restore its own context (i), or the root context (ii), depending on whether the Reified returns to its parent (i) or not (ii).
  (b) whenever a child stratum is aborted, the Reified parent must restore its own context
  (c) when a reifiedseq is reentrantly being adopted, we must restore the original DC
(7) FAcall calls its parameters' EFs with a new context. It must restore its parent context:
  (a) when we are done with parameter EFs
  (b) when a parameter EF is aborted 
*/


#ifdef DEBUG_VM
var dynvar_ctx_counter = 0;
#define ASSERTDYNVARSROOT(LBL) if (exports.current_dyn_vars !== root_dyn_vars) { console.log('Dynvars('+exports.current_dyn_vars.id+') !== root ('+LBL+')'); throw new Error('Dynvars('+exports.current_dyn_vars.id+') !== root ('+LBL+')'); }
#else
#define ASSERTDYNVARSROOT(LBL)
#endif

#ifdef DEBUG_DYNVARS
#ifdef DEBUG_MULTIVM
#define SETDYNVARS(NEW,LBL) if (exports.current_dyn_vars !== NEW)  { if (String(LBL).indexOf('verifiedxx') == -1) console.log(exports.VMID+":DV("+LBL+")>",exports.current_dyn_vars.id,">",NEW.id); exports.current_dyn_vars = NEW; }
#else
#define SETDYNVARS(NEW,LBL) if (exports.current_dyn_vars !== NEW)  { if (String(LBL).indexOf('verifiedxx') == -1) console.log("DV("+LBL+")>",exports.current_dyn_vars.id,">",NEW.id); exports.current_dyn_vars = NEW; }
#endif /* MULTIVM */
#else
#define SETDYNVARS(NEW,LBL) exports.current_dyn_vars = NEW;
#endif

function createDynVarContext(proto_context) {
#ifdef DEBUG_VM
  var ctx = Object.create(proto_context);
  ctx.id = proto_context.id + '/' + (++dynvar_ctx_counter);
  return ctx;
#else
  return Object.create(proto_context);
#endif
}
exports.createDynVarContext = createDynVarContext;

var root_dyn_vars = { id: '0' };
exports.root_dyn_vars = root_dyn_vars;
exports.current_dyn_vars = root_dyn_vars;



//----------------------------------------------------------------------
// Callstack support:

// current_call is set to [file,lineno] for every Fcall, FACall & I_call 
// This is used to extract stack information for stratum calls (spawn/adopt):
exports.current_call = null;

//----------------------------------------------------------------------
// Execution Frames

/*
  Note on `ReturnToParentContinuation` & global `cont` function

  In SJS, we can (asynchronously) build large execution frame trees in
  a tail-safe way. To ensure that we we can also unravel these trees
  without blowing the JS stack (by a long chain of
  cont-returnToParent-cont-returnToParent-... calls), we need to code
  calls that tear down a tree in continuation passing style.

  Grep the code for ReturnToParentContinuation for more notes.

*/
#define is_returnToParent(obj) (obj && obj.__oni_rtpc)
function ReturnToParentContinuation(frame, idx, val) {
  this.frame = frame;
  this.idx = idx;
  this.val = val;
}
ReturnToParentContinuation.prototype = {
  __oni_rtpc: true,
  execute: function() { return this.frame.cont(this.idx, this.val) }
};

/*
  Execution frames' `cont` methods should never be called directly,
  but always be through this global function. It takes care of
  executing any `ReturnToParentContinuation`s that the callee might
  return.
*/
function cont(frame, idx, val) {
  var rv = frame.cont(idx, val);
  while (is_returnToParent(rv)) {
    rv = rv.execute();
  }
  return rv;
}

// Execution frames are tied to a particular VM (e.g. they don't work across iframes).
// This is because dynamic variable contexts don't work across VMs:
var ONI_EF = {};

exports.is_ef = function(obj) {
  return obj && obj.__oni_ef === ONI_EF;
}
// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_ef(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_ef===ONI_EF)

function setEFProto(t) { for (var p in EF_Proto) t[p] = EF_Proto[p]; }
//function setEFProto(t) { t.__proto__ = EF_Proto; }


// helper to merge callstacks of two execution frames:
function mergeCallstacks(target_ef, src_ef) {
  // prevent duplication of the callstack if the frames are the same:
  if (target_ef === src_ef) return;
  if (target_ef.callstack) {
    // stack-tests 17
    
    // concat stacks; potentially dropping frames in the middle if
    // we go above MAX_CALLSTACK:
    target_ef.callstack = target_ef.callstack.concat(src_ef.callstack);
    if (target_ef.callstack.length > MAX_CALLSTACK)
      target_ef.callstack.splice(MAX_CALLSTACK/2, 
                                 target_ef.callstack.length-MAX_CALLSTACK+1, 
                                 ['    ...(frames omitted)']);
  }
  else {
    // stack-tests 16
    target_ef.callstack = src_ef.callstack;
  }
}

// base prototype object for execution frames
var EF_Proto = {
#ifdef EF_TYPES
  toString: function() { var rv = "<"+(typeof(this.type) === 'function' ? this.type() : this.type)+""+(this.id ? this.id:'')+((this.env && this.env.file) ? '@'+this.env.file.substr(-20): '')+">";
                         if (this.callstack)
                           rv += '[' + this.callstack.join(' > ') + ']';
#ifdef DEBUG_MULTIVM
                         rv = exports.VMID + rv;
#endif
                         return rv;
 },
#else
  toString: function() { return "<suspended SJS>"; },
#endif
  __oni_ef : ONI_EF,

  wait: function() { 
    SETDYNVARS(root_dyn_vars, this+':wait')
    return this; 
  },

#ifdef DEBUG_VM
  gatherSuspensionTree: function() {
    try {
    return (this.callstack||[]).concat(this.child_frame ? this.child_frame.gatherSuspensionTree() : []);
    }
    catch (e) {
      console.log("ERROR GATHERING SUSPENSION TREE FOR "+this.child_frame);
      throw e;
    }
  },
#endif

  setChildFrame: function(ef, idx, prevent_callstack_copy) {
    ASSERTDYNVARSROOT(this+'::setchildframe('+ef+')')
    if (this.child_frame) {
      if (prevent_callstack_copy !== true && this.child_frame.callstack) {
        // merge callstacks of old & new childframes:
        mergeCallstacks(ef, this.child_frame);
      }
      this.child_frame.parent = UNDEF;
    }
    this.async = true;
    this.child_frame = ef;
    ef.parent = this;
    ef.parent_idx = idx;
  },

  // quench reentrant resume calls.
  // This signal is issued before abort() calls, to prevent any resume() calls in our
  // call tree from firing, in case they are reentrantly executed by finally-code 
  // in our call tree. See also the tertiary waitfor/and/or sjs-testsuite testcases
  // 153-156.
  quench: function() {
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'abort'
    if (this.child_frame) 
      this.child_frame.quench();
  },

  // abort must either return 'this' (if we need to wait), or a controlflow exception
  abort: function(pseudo_abort) {
#ifdef DEBUG_VM
    if (this.aborted) {
      console.log('ERROR: '+this + ': redundant abort');
    }
    // leave the assert, so that the process exits:
    ASSERT(!this.aborted)
#endif
    this.aborted = true;
    this.pseudo_abort = pseudo_abort;
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'quench'
    if (!this.child_frame) {
      // reentrant abortion
      SETDYNVARS(root_dyn_vars, 'reentrant abort // (3)')
      return this;
    }
    else {
      var abort_val = this.child_frame.abort(pseudo_abort);
      if (is_ef(abort_val)) {
        return this; // need to stay in picture because abort must not return child frame
      }
      else {
        if (is_annotated_oni_cfx(abort_val) && this.callstack) {
#ifdef DEBUG_STACK
          console.log(this+" 1 adding ",this.callstack," to "+abort_val.val);
#endif
          abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }

        // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
        this.unreturnable = true;
        return abort_val;
      }
    }
  },

  returnToParent: function(val) { 
//    if (String(this).indexOf("Reified") !== -1) {
//      console.log(this+":RTP "+val+" --- "+(is_cfx(val) && val.type==='r'?val.val:''));
//      console.log('swallow_r='+this.swallow_r);
//      console.log('parent = '+this.parent);
//      this.DDD = true;
//      console.log('async = '+this.async);
//    }
#ifdef DEBUG_VM_X
    // We currently call returnToParent prematurely under various reentrancy scenarios in
    // Alt, Par, and Spawn.
    // XXX This is wrong and extremely fragile and needs a rewrite at some point.
    if (this.__rtp_called) {
      console.log(this + ": redundant call to returnToParent("+val+")");
    }
    else {
      this.__rtp_called = true;
    }
#endif

    if(is_cfx(val) && val.type == 't' && this.callstack && val.val!=null && val.val.__oni_stack) {
#ifdef DEBUG_STACK
      console.log(this+" 2 adding ",this.callstack," to "+val.val);
#endif
      val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
    }
//    if (is_cfx(val) && val.type === 'r' && (val.val === 'toplevel' || val.val === 'inner' || val.val === 'outer')) console.log(this+":RTP "+val.val+' async:'+this.async+" swallow="+this.swallow_r);
    if (this.swallow_r) {
      if (is_cfx(val)) {
        if (val.type === "r") {
          if (true || !val.eid || val.eid === this.sid) {
            val = val.val;
            if (this.swallow_r === 3) {
              // we've received a tail-called 'return' that shouldn't
              // be returned via the present function. see also notes below
              val = UNDEF;
            }
          }
        }
      }
      else if (is_ef(val)) {
        // we're tailcalling the ef 'val' through ef 'this'. I.e. ef
        // 'this' is dropping out of the picture.

        // We have to ensure that ef 'val' gets a 'swallow_r' policy consistent with that of ef 'this'.
        // In particular, we want 'val' to have the same 'swallow_r' as 'this', with the exception where
        // 'this' is a tail-called function (this.tailcall === true) that is set to return proper 
        // returns only (this.swallow_r === 1) and val is *also* already set up to swallow returns (i.e. it is/was a functional context too). In this case we want to convert any 'returns' emitted
        // by ef 'val' to undef (i.e. set val.swallow_r to 3).
        // The swallow_r special casing fixes sjs-2-tests.sjs:async return propagation and
        // sjs-2-tests.sjs:return propagation from suspended blocklambda

        if (this.swallow_r === 1 && val.swallow_r && this.tailcall) {
          val.swallow_r = 3;
        }
        else {
          val.swallow_r = this.swallow_r; // just pass down flag to child
        }
      }
      else if (this.swallow_r !== 2) {
        val = UNDEF; // only 'return' returns a value to parent
      }
    }
  
    // Mark this frame as unreturnable. This is used by
    // blocklambdas to determine if the lexical function container is
    // still alive.
    this.unreturnable = true;

    // a little cleanup which might aid GC:
    // XXX this breaks function-tests.sjs:exclusive
    // this.env = UNDEF;

    if (this.async) {
      if (this.parent) {
        // we would like to call 
        //   this.parent.cont(this.parent_idx, val) 
        // here, but this might blow the JS stack.
        // We encode in continuation-passing style instead; the topmost `cont`
        // parent of this code path knows how to handle 
        // ReturnToParentContinuation
        return new ReturnToParentContinuation(this.parent, this.parent_idx, val);

        // remove parent to aid gc; we can only do this if val != this
        // (par and alt call through returnToParent via abortInner, which in the 
        // async case returns their own EF)
        // XXX empirically this doesn't seem to help much 
        // if (val !== this) this.parent = UNDEF;
      }
      else // noone waiting for result; make sure exceptions get reported
        if (is_cfx(val)) {
          val.mapToJS(true);
//          var v = val;
//          nextTick(function() { v.mapToJS(true); });
        }
    }
    else // sync context
      return val;
  }

};
//EF_Proto.__proto__ = null;


//----------------------------------------------------------------------
// 'overrides' for parallel execution nodes (EF_Par, EF_Alt, EF_WfW, EF_Reified):
// XXX these should really be refactored into a separate 'EF_ParProto' baseclass
// XXX only works for array children (not Map)

// quenchPar works for array
function quenchPar() {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench', sjs-3-tests:'waitfor/while:reentrant quench'
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally
  for (var child of this.children) {
    if (child)
      child.quench();
  }

};

// parallel setChildFrame version
function setChildFramePar(ef, idx) {
  if (this.children[idx]) {
    if (this.children[idx].callstack) {
      // merge callstacks of old & new childframes (stack-tests 28,29)
      mergeCallstacks(ef, this.children[idx]);
    }
    this.children[idx].parent = UNDEF;
  }
  this.children[idx] = ef;
  ef.parent = this;
  ef.parent_idx = idx;
}




//----------------------------------------------------------------------
// Instruction nodes

// Token which identifies an object as an instruction node
// dispatcher (obj.__oni_dis == token_dis)
var token_dis = {};

// execute an instruction node without mapping exceptions:
function execIN(node, env) {
  if (!node || node.__oni_dis != token_dis) {
    return node; // a literal value
  }
  return node.exec(node.ndata, env);
}
exports.ex = execIN;

// function bodies: create a seq and exec it. map exceptions.
// short for __oni_rt.exec(__oni_rt.Seq(...), aobj, thisobj, file)
// aobj: effective `arguments`
// tobj: effective `this`
exports.exseq = function(aobj,tobj,file, args) {
  var rv = I_seq(args, new Env(aobj,tobj,file));
//  var rv = (new EF_Seq(args, new Env(aobj,tobj,file))).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS(); // throw exceptions, so that we can call this from normal js
  return rv;
};

// reified function body:
exports.exrseq = function(aobj,tobj,file,args) {
  var rv = I_reifiedseq(args, new Env(aobj,tobj,file));
  if (is_cfx(rv))
    return rv.mapToJS(); // throw exceptions, so that we can call this from normal js
  return rv;
};

// block lambda bodies: create a blseq and exec it.
// short for __oni_rt.exec(__oni_rt.Seq(...), env)
// we need to map exceptions for cases where a blocklambda return tunnels through a
// js function. See sjs-tests:'{||} in JS forEach'
exports.exbl = function(env, args) {
  var rv = I_blseq(args, env);
//  var rv = (new EF_Seq(args, env)).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS();
  return rv;
};

//   exec: instruction executor function
//   returns IN constructor function which returns a instruction object
// For some reason instruction objects created directly without makeINCtor execute slightly faster on chrome and ff 
// -> removing use of makeINCtor
//
//function makeINCtor(exec) {
//  return function(/* ndata */) {
//    return {
//      exec: exec,
//      ndata: arguments,
//      __oni_dis: token_dis
//    };
//  }
//}


//----------------------------------------------------------------------
// Execution environment
/*

  {
    aobj: 'arguments' object,
    tobj: 'this' object,
    file: filename,
    blrref: function execution frame that blocklambda returns should
            target in current environment
    blanchor: blocklambda anchor call (ef of type 'EF_FAcall' - valid in argument children of EF_FAcall)
    bl: blocklambda execution frame (valid within children of a bl execution frame)

    XXX ONLY PROPAGATE blanchor to _arguments_

  }

*/

function Env(aobj, tobj, file, blrref, fold, branch, blanchor, reifiedstratum) { 
  this.aobj = aobj; // 'arguments' object
  this.tobj = tobj; // 'this' object
  this.file = file; // filename
  this.blrref = blrref;
  this.fold = fold; // place where 'alt' forks
  this.branch = branch; // id of fork branch. XXX should be merged with 'fold'
  this.blanchor = blanchor; // blocklambda anchor
  this.reifiedstratum = reifiedstratum;
}

function copyEnv(e) {
  return new Env(e.aobj, e.tobj, e.file, e.blrref, e.fold, e.branch, e.blanchor, e.reifiedstratum);  
}

//----------------------------------------------------------------------
// C : instruction node for function calls with non-blocking args
// Calls the given function with 'this' set to current environment 

// structure of ndata array:
#define NDATA_CALL_JSFUNC() ndata[0]
#define NDATA_CALL_LINENO() ndata[1]
function I_call(ndata, env) {
  try {
    current_call = [env.file, NDATA_CALL_LINENO()];
    var rv = (NDATA_CALL_JSFUNC()).call(env);
    if (is_ef(rv)) {
      // collect callstack on the execution frame:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([env.file, NDATA_CALL_LINENO()]);
    }
    return rv;
  }
  catch (e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_CALL_LINENO(), env.file);
    }
    return e;
  }
}
//exports.C = makeINCtor(I_call);
exports.C = function(...args/*f, line*/) {
  return {
    exec: I_call,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Nb : instruction node for non-blocking, argument-less javascript code 
// Calls the given function with 'this' set to current environment.

// structure of ndata array:
#define NDATA_NBLOCK_JSFUNC() ndata[0]
#define NDATA_NBLOCK_LINENO() ndata[1]
function I_nblock(ndata, env) {
  try {
    return (NDATA_NBLOCK_JSFUNC()).call(env);
  }
  catch (e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_NBLOCK_LINENO(), env.file);
    }
    return e;
  }
}
//exports.Nb = makeINCtor(I_nblock);
exports.Nb = function(...args/*f, line*/) {
  return {
    exec: I_nblock,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  };
};


//----------------------------------------------------------------------
// Seq : instruction node for sequential execution of child nodes

// ndata[0] contains flags.
#define NDATA_SEQ_FLAGS() ndata[0]
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE SEQ_FLAG_'s in kernel-sjs.js.in
#define NDATA_SEQ_FLAG_NONE 0
#define NDATA_SEQ_FLAG_FUNCTION 1
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_OR 2
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_AND 4
#define NDATA_SEQ_FLAG_NOTAILCALL 8
#define NDATA_SEQ_FLAG_UNRETURNABLE 16
#define NDATA_SEQ_FLAG_IMPLICIT_RETURN 32 
// ndata[1..end] contains sequence of instruction nodes

/*
  continuation index:
  1      : start
  2..end : returning from ndata[n-1] (last one tail-called)  
 */

var seq_counter = 0;

function EF_Seq(ndata, env) {
  // 'sid' is an id used in blocklambda break and return references
  this.sid = ++seq_counter;
#ifdef DEBUG_VM
  this.id = this.sid; 
#endif
  this.ndata = ndata;
  this.env = env;

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) {
    // No need to copy env here, because we are (by implication) a non-blocklambda function or the top-level
    ASSERT(!!(NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_FUNCTION|NDATA_SEQ_FLAG_UNRETURNABLE)))
    ASSERT(env.blrref === undefined)
    ASSERT(env.fold === undefined)
    ASSERT(env.branch === undefined)
    env.blrref = this;
  }
  else if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
#ifdef DEBUG_VM
    // assert that we're a 'normal' function with a fresh env:
    ASSERT(env.blrref === undefined)
    ASSERT(env.fold === undefined)
    ASSERT(env.branch === undefined)
    // i.e. no need to copy env!
#endif // DEBUG_VM
  }

  this.tailcall = !(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == 0    : returns tunnel through us
  // swallow_r == 1    : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  // swallow_r == 3    : 'catch' a tailcalled Return(exp) that should not be returned (i.e. convert to undefined)
  this.swallow_r = (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION == NDATA_SEQ_FLAG_FUNCTION) ? 1 : 0;
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

  // is this a top-level seq (one that can't be return'ed to?)
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE) {
    this.unreturnable = true;
    // mark it as toplevel, for correct error messages and to allow
    // blocklambda breaks to target this frame:
    this.toplevel = true; 
  }
}
setEFProto(EF_Seq.prototype={});
#ifdef EF_TYPES
EF_Seq.prototype.type = function() { 
  var rv = "Seq";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION)
    rv += "(fun)";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    rv += "(notail)";

  return rv;
};
#endif
EF_Seq.prototype.cont = function(idx, val) {
#ifdef DEBUG_VM_XX
  var getType = function(val) {
    var sub = val && val.type;
    return "Seq/" + (sub || "??");
  };
  LOG("EF_Seq.prototype.cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "]) @ " + this.env.file);
#endif
 // console.log(this+"cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "])");

  if (is_ef(val)) {
    // child frame being replaced:
    this.setChildFrame(val, idx);
  }
  else {
    if (is_cfx(val) || this.aborted) {
      // pass through exceptions/abort
      // some cleanup first:
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF;
      }
      
      return this.returnToParent(val);
    }
    while (idx<this.ndata.length) {
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF; // ensures correct reentrant aborting
      }
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          if (!is_ef(val)) {
            return this.returnToParent(val);
          }
        }
      }
      if (++idx == this.ndata.length && this.tailcall) {
        // tail call optimization: 
        break;
      }
      if (is_cfx(val)) {
        break;
      }
      else if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
    return this.returnToParent(val);
  }
};

#ifdef HOTPATH
function I_seq(ndata, env) {
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    return cont(new EF_Seq(ndata, env), 1);

  var sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 
  var idx = 1;
  var val;
  var l = ndata.length;
  while (idx<l) {
    val = execIN(ndata[idx++], env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

    if (is_cfx(val)) break;
    if (is_ef(val)) {
      // need to create an execution frame for ourselves... 
      var ef = new EF_Seq(ndata, env);
      ef.setChildFrame(val, idx);
      return ef;
    }
    if (sc) {
      if (sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
        if (val) break; // returns val
      }
      else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
        if (!val) break; // returns val
      }
    }
  }

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
    if (is_cfx(val)) {
      if (val.type === "r") { 
        if (!val.eid) 
          val = val.val;
      }
    }
    else
      val = UNDEF;
  }
  return val;
}
#else /* !HOTPATH */
function I_seq(ndata, env) {
  return cont(new EF_Seq(ndata, env), 1);
}
#endif /* HOTPATH */
//exports.Seq = makeINCtor(I_seq);
exports.Seq = function(...args) {
  return {
    exec: I_seq,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// EF_Reified is not directly exported - instead it is being called by 'exrseq' in blocklambda code

function createReifiedStratum(ef) {
  var RS = {
    toString: function() { return "[object Stratum '"+ef.id+"']"; },
    wait: function() {
      if (ef.done) return RS;
      var wef = {
#ifdef EF_TYPES
        toString: function() { return "<wait on stratum "+ef.id+">"; },
#endif
        wait: function() { 
          SETDYNVARS(root_dyn_vars, wef+':wait')
          return wef; 
        },
        quench: function() { ef.wait_frames.delete(wef); },
        abort: function() { 
          SETDYNVARS(wef.__oni_dynvars, 'abort[stratum.wait] //(5) -- verified')
          //to aid gc; check if this is possible: wef.__oni_dynvars = UNDEF;
          return UNDEF;
        },
        __oni_ef: ONI_EF,
        __oni_dynvars: exports.current_dyn_vars
      };

      ef.wait_frames.add(wef);

      SETDYNVARS(root_dyn_vars, 'block[stratum.wait] // (3) -- verified')
      return wef;
    },
    running: true,
    spawn: function(f) { return spawnSubStratum(f, ef) },
    join: function() { 
      if (ef.pending < 2) return; // no sub strata
      //console.log(ef+": JOIN ON "+ef.pending);
      var jef = {
#ifdef EF_TYPES
        toString: function() { return "<join on stratum "+ef.id+">"; },
#endif
        wait: function() { 
          SETDYNVARS(root_dyn_vars, jef+':wait')
          return jef; 
        },
        quench: function() { ef.join_frames.delete(jef); },
        abort: function() { 
          //console.log("ABORT JOIN FRAME for "+ef);  
          SETDYNVARS(jef.__oni_dynvars, "abort[stratum.join] //(5) -- verified")
          //XXX to aid gc; check if this is ok: jef.__oni_dynvars = UNDEF;
          return UNDEF; 
        },
        __oni_ef: ONI_EF,
        __oni_dynvars: exports.current_dyn_vars
      };

      ef.join_frames.add(jef);

      SETDYNVARS(root_dyn_vars, "block[stratum.join] // (3) -- verified")
      return jef;

    },
    abort: function() { 
      if (!RS.aborted) { 
        ef.quench(); 
        var dyn_vars = exports.current_dyn_vars;
        if ((ef.abort() !== ef) && ef.parent) {
          cont(ef.parent, ef.parent_idx, ef.pending_rv); 
        }
        SETDYNVARS(dyn_vars, "stratum.abort() call // (2) -- verified")
      }; 
      return RS; 
    },
    capture: function() {
      return exports.sys.captureStratum(RS);
    },
    adopt: function(s) { 
      if (s._ef.done || s._ef.parent === ef) return s; // stratum is already done; no need to adopt
      var ef_to_adopt = s._ef;

      // see unit/stack-tests spawn/adopt tests
      if (ef_to_adopt.callstack) { 
#ifdef DEBUG_STACK
        console.log(this+'::adopt pushing callstack 1 ',current_call);
#endif
        ef_to_adopt.callstack.push(current_call);
      }
      else {
        // for reentrant adoption of non-spawned stratum, we won't have a callstack, but
        // we will have 'pending_caller' set:
        ASSERT(ef_to_adopt.pending_caller)
#ifdef DEBUG_STACK
        console.log(this+'::adopt pushing callstack 2 ',current_call, ef_to_adopt.pending_caller);
#endif
        ef_to_adopt.callstack = [ current_call, ef_to_adopt.pending_caller ];
      }
      // ef_to_adopt might not have a parent if it is reentrantly adopted 
      var old_parent = s._ef.parent;
      var old_parent_idx = s._ef.parent_idx;
      //console.log(ef+' adopting '+ef_to_adopt+' with parent='+old_parent+', '+old_parent_idx);
      var id = ++ef.substratumid;
      ef_to_adopt.id += '~'+ef.id+'/'+id;
      ++ef.pending;
      ef_to_adopt.async = true;

      var dynvars = exports.current_dyn_vars;

      if (old_parent) {
        cont(old_parent, old_parent_idx, UNDEF);
        ASSERT(exports.current_dyn_vars === dynvars || exports.current_dyn_vars === root_dyn_vars)
      }
//      else {
        //console.log("---------- ADOPT WITH NO PARENT");
        // mark as adopted, so that we don't hook up to parent in `spawn`:
      // XXX this flag is ALWAYS needed if we are adopted; not only for `spawn`
        ef_to_adopt.adopted = true;
//      }

      ef_to_adopt.dynvars.__oni_anchor_route = ef.dynvars;

      // this needs to come after cont(old_parent,...), because that code might set child_frame.parent=UNDEF
      cont(ef, -2, [id,ef_to_adopt]);
      SETDYNVARS(dynvars, "stratum.adopt() // (2) -- verified")
      return ef_to_adopt.reifiedstratum;
    },
    _ef:ef,
    __oni_stratum: true
  };
  return RS;
}

function spawnSubStratum(f, parent_ef) {
  if (parent_ef.done) throw new Error("Cannot spawn stratum with inactive parent");
  var parent_dynvars = exports.current_dyn_vars;
  var id = ++parent_ef.substratumid;
  var reified_ef = new EF_Reified(parent_ef.id+'/'+id, parent_ef.dynvars);

  SETDYNVARS(reified_ef.dynvars, "spawnSubStratum // (1)")

  //console.log("!spawn "+reified_ef);
  ++reified_ef.pending;
  ++parent_ef.pending;
#ifdef DEBUG_STACK
        console.log(reified_ef+'::spawnSubStratum setting callstack ',current_call);
#endif
  reified_ef.callstack = [ current_call ];
  var val;
  try {
    // start executing substratum:
    val = f(reified_ef.reifiedstratum);
  }
  catch(e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, 0, ''); // XXX call info
    }
    val = e;
  }
  // initialize substratum execution frame with main thread rv:

  var substratum_val = cont(reified_ef,-1,val);
  if (!reified_ef.adopted) {
    // hook up to parent stratum:
    cont(parent_ef, -2, [id,substratum_val]);
  }
  else {
    console.log("NOT HOOKING UP ADOPTED STRATUM IN .SPAWN (parent="+reified_ef.parent+")");
    // need to clear pending: (XXX might be able to do this by direct setting?)
    cont(parent_ef, -2, [id, UNDEF]);
  }
  SETDYNVARS(parent_dynvars, 'spawn //(2) -- verified')
  return reified_ef.reifiedstratum;
}

function EF_Reified(id, anchor_route) {
  // inject stratum interface
  this.id = id;
  this.reifiedstratum = createReifiedStratum(this);
  this.dynvars = createDynVarContext(exports.current_dyn_vars);
  this.dynvars.__oni_anchor = UNDEF;
  this.dynvars.__oni_anchor_route = anchor_route;
  //console.log(this+" dynvars = ",this.dynvars);
  this.pending = 0;
  this.substratumid = 0;
  this.pending_rv = UNDEF;
  this.main_child = UNDEF;
  this.strata_children = new Map();
  this.strata_children_aborted = false;
  this.wait_frames = new Set();
  this.join_frames = new Set();
}
setEFProto(EF_Reified.prototype = {});
#ifdef EF_TYPES
EF_Reified.prototype.type = function() { 
  var rv = "Reified";
  return rv;
};
#endif

/*
  idx:
   -1: main branch start
   -2: new stratum

*/
EF_Reified.prototype.contOUTERDEBUG = function(idx, val) {
  try {
    if (String(this) === "<Reified32>") console.log("<<<<<<<<<< "+this+".cont("+idx+", "+val+", pending="+this.pending+",parent="+this.parent+")");
    return this.cont_inner(idx, val);
  }
  finally {
if (String(this) === "<Reified32>") console.log(">>>>>>>>>> "+this+".cont("+idx+", "+val+", pending="+this.pending+",parent="+this.parent+")");
  }
};

EF_Reified.prototype.cont = function(idx, val) {
  //console.log(">> "+this+".cont("+idx+", "+val+", pending="+this.pending+",parent="+this.parent+")");
  ASSERT(idx <= 0 || this.strata_children.has(idx))

  if (idx === -1) {
    // main stratum setup
    // xxx note we might get child strata before this
    idx = 0; // this becomes the index for the child frame
    if (is_ef(val)) {
      if (this.aborted) {
        // reentrant abortion
        val.quench();
        val = val.abort();
      }
    }
  }
  else if (idx === -2) {
    idx = val[0];
    val = val[1];
    // new sub-stratum setup
    // val can be an execution frame or a value or exception
    if (is_ef(val)) {
      if (this.strata_children_aborted) {
        // reentrant abortion
        val.quench();
        val = val.abort();
      }
    }
  }
  if (is_ef(val)) {
    if (idx === 0) 
      this.async = true;
    this.setChildFrame(val, idx);
    return this;
  }
  else {
    //console.log(this+"--PENDING(idx "+idx+") IN CONT >"+(this.pending-1));
    --this.pending;
    if (idx === 0) {
      this.main_child = UNDEF;
    }
    else {
      var child = this.strata_children.get(idx);
      if (child) {
        child.parent = UNDEF;
        this.strata_children.delete(idx);
      }
    }

    if (idx === 0) {
      //console.log(this+' setting pending_rv to '+val);
      if (this.pending_rv === UNDEF) 
        this.pending_rv = val;
      else
        this.pending_rv = mergeExceptions(val, this.pending_rv);
      //console.log(this+' pending_rv='+this.pending_rv);
      this.aborted = true;
      if (!this.strata_children_aborted)
        this.abort_child_strata();
    }
    else if (is_cfx(val)) {
      if (!this.aborted) {
//        console.log(this+' merge pending_rv '+this.pending_rv+' to '+val);
        this.pending_rv = mergeExceptions(val, this.pending_rv);
//        console.log(this+' pending_rv='+this.pending_rv);
        this.quench();
        this.abort();
        if (this.done) return this.returnToParent(this.pending_rv);
        else return this;
      }
      else if (val.type === 't') {
        this.pending_rv = mergeExceptions(val, this.pending_rv);
      }
      else {
        var msg = "Swallowing control-flow exception '"+val+"' from aborted sub-stratum";
        if (console.error) console.error(msg);
        else console.log(msg);
      }
    }
  }
  
  if (this.pending <= 1) {
    if (this.flushing) {
      return;
    }
    else {
      this.flushing = true;
      this.flush_join_frames();
      this.flushing = false;
    }
  }

  if (this.pending===0) {
    if (this.done) {
      console.log(this+" WE ARE SO DONE WITH THIS");
      process.exit(1);
    }
    this.done = true;
    this.reifiedstratum.running = false;

    if (this.wait_frames.size) {
      var me = this;
      nextTick(function() { me.flush_wait_frames(); });
    }

    //console.log(this+".rtp ASYNC = "+this.async+', returning: '+this.pending_rv);

    SETDYNVARS(this.dynvars.__oni_anchor_route, this+".cont // (6)(a)(i), val="+this.pending_rv)

    return this.returnToParent(this.assertRoutable(this.pending_rv));
  }
  else if (idx === 0) {
    this.async = true;
    // under certain abort scenarios (e.g. still need to wait for child frame), we haven't got the 
    // the right dynvars, so need to reset here:
    SETDYNVARS(root_dyn_vars, this+".cont // (3) -- verified")
    //console.log(this + " RET THIS, parent="+this.parent+" pending="+this.pending);
    return this;
  }
  else {
    // this was a cont() for a child stratum; we need to reset the dyn vars:
    SETDYNVARS(root_dyn_vars, this+".cont // (6)(a)(ii) -- verified")
  }
};

EF_Reified.prototype.flush_join_frames = function() {
  if (this.join_frames.size === 0) return;
  var frames = this.join_frames;
  this.join_frames = new Set();
  var current_dyn_vars = exports.current_dyn_vars;
  for (var join_frame of frames) {
    if (join_frame.parent) {
      SETDYNVARS(join_frame.__oni_dynvars, "join[child] // (3) -- verified")
      cont(join_frame.parent, join_frame.parent_idx, UNDEF);
      //XXX to aid gc; check if this is possible: join_frame.__oni_dynvars = UNDEF;
    }
  }
  // we continue on with processing in EF_Reified::cont or ::abort:
};

EF_Reified.prototype.flush_wait_frames = function() {
  ASSERTDYNVARSROOT('reified::flush_wait_frames')
  var frames = this.wait_frames;
  this.wait_frames = new Set(); // XXX UNNECESSARY?
  for (var wait_frame of frames) {
    if (wait_frame.parent) {
      SETDYNVARS(wait_frame.__oni_dynvars, "wait[child] // (3) -- verified")
//      console.log("CONT "+wait_frame.parent+" from "+this);
      cont(wait_frame.parent, wait_frame.parent_idx, this.reifiedstratum);
      // cont(.) should restore the root DC in all cases, because we are always called async
    }
    // this doesn't always hold when we call SJS through JS and let the 
    // continuation go nowhere:
    // ASSERTDYNVARSROOT('reified::flush_wait_frames:2')
    SETDYNVARS(root_dyn_vars, "reified::flush_wait_frames:2")
    //XXX to aid gc; check if this is possible: wait_frame.__oni_dynvars = UNDEF;
  }
}

EF_Reified.prototype.abort_child_strata = function() {
//  console.log(this+' aborting child strata');
  ASSERT(!this.strata_children_aborted);

  /* we need to be careful about how to quench&abort our children, since a still-running child
     can re-adopt another child */
  this.strata_children_aborted = true;
  if (this.strata_children.size === 0) return;

  for (var child of this.strata_children) {
    //console.log(this+' abort child '+child[0]);
    if (child[1].parent === this) {
      child[1].quench();
      var abort_val = child[1].abort(); // XXX do we need support for pseudo-abort?
      if (is_ef(abort_val)) {
        //console.log(this + ' need to wait for '+child[0]+': '+abort_val);
        //XXXUNN this.setChildFrame(abort_val, child[0]);
      }
      else {
        child[1].parent = UNDEF;
        //console.log(this+"--PENDING(CHILD "+child[1]+") IN ABORT >"+(this.pending-1));
        this.strata_children.delete(child[0]);
        --this.pending;
        // XXX check this is correct:
        if (is_annotated_oni_cfx(abort_val) && this.callstack) {
#ifdef DEBUG_STACK
          console.log(this+" 3 adding ",this.callstack," to "+abort_val.val);
#endif
          abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }
        //console.log(this+' on child abort: merging '+abort_val);
        this.pending_rv = mergeExceptions(abort_val, this.pending_rv);
        //console.log(this+' pending_rv='+this.pending_rv);
      }
    }
    else {
      //console.log(this + " not aborting re-adopted child "+child[1]);
      this.strata_children.delete(child[0]);
    }
  }
};

EF_Reified.prototype.abort = function(pseudo_abort) {
//  console.log(this+".ABORT pending = "+this.pending+", aborted="+this.aborted+", done="+this.done+", main_child="+this.main_child+" parent="+this.parent);
  // allow redundant aborts. this could be engineered better, but we're using 'aborted' also as 
  // a flag in cont() to note that the main thread has ended. If a child stratum blocks, we can still
  // get an abort() from the upstream.
  if (this.aborted) {
    SETDYNVARS(root_dyn_vars, 'redundant abort')
    return this;//this.done ? UNDEF : this; <- probably unnecessary (unless there are delays somewhere - xxx bridge)
  }
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  if (!this.main_child) { 
    // reentrant abortion; we need to wait
    SETDYNVARS(root_dyn_vars, 'reified::redundant abort')
    return this; 
  }
  else {
    var abort_val = this.main_child.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      ASSERTDYNVARSROOT('reified::abort:2')
      return this;
    }
    else {
      this.main_child = UNDEF;
      //console.log(this+"--PENDING(MAIN CHILD) IN ABORT >"+(this.pending-1));
      --this.pending;
      // XXX check this is correct:
      if (is_annotated_oni_cfx(abort_val) && this.callstack) {
#ifdef DEBUG_STACK
        console.log(this+" 4 adding ",this.callstack," to "+abort_val.val);
#endif
        abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }
      this.pending_rv = mergeExceptions(abort_val, this.pending_rv);
      //console.log(this+' pending_rv='+this.pending_rv);
      this.abort_child_strata();
      // dynvars after this call will be undetermined
    }

    if (this.pending <= 1) {
      this.flush_join_frames();
      // dynvars after this will be undetermined
    }
    //console.log(this+" after abort, pending="+this.pending);
    if (this.pending) {
      SETDYNVARS(root_dyn_vars, "reified::abort:3 -- verified")
      return this; // need to stay in picture because abort must not return child frame
    }
    
    // XXX consolidate this code with the equivalent in 'cont':
    this.done = true;
    this.reifiedstratum.running = false;

    if (this.wait_frames.size) {
      var me = this;
      nextTick(function() { me.flush_wait_frames(); });
    }

    // XXX check if this is still an issue:
    // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
    this.unreturnable = true;
    SETDYNVARS(this.dynvars.__oni_anchor_route, 'reified::abort // (6)(b)')
    //console.log(this+" ABORT DONE & RETURNING: "+this.pending_rv);
    return this.assertRoutable(this.pending_rv);
  }
};

// XXX consolidate this with the code in EF_Try
EF_Reified.prototype.assertRoutable = function(rv) {
  if (is_cfx(rv) && (rv.type === 'blb' || rv.type === 'blr')) {
//    console.log(this+"::assertRoutable (2nd line)");
//    console.log(this.dynvars.__oni_anchor_route);

    var node = this.dynvars.__oni_anchor_route;

    while (node) {
//      console.log(node.__oni_anchor+' --- '+rv.aid);
      if (node.__oni_anchor === rv.aid) {
//        console.log("ANCHOR FOUND");
        return rv;
      }
      node = node.__oni_anchor_route;
    }
    console.log(this+"::assertRoutable (2nd line) ANCHOR "+rv.aid+" NOT FOUND!!!");
    return new CFException("t", new Error("Unroutable blocklambda break/return"));
  }
  return rv;
};

// XXX can't use quenchPar here, because we have to use a Map for children:
EF_Reified.prototype.quench = function() {
  //console.log(this+'quench');
  // XXX figure out quench logic
  if (this.main_child) this.main_child.quench();
  // don't quench child strata here; they might still be re-adopted as part of 
  // abortion
  //for (var child of this.strata_children) {
  //  if (child[1])
  //    child[1].quench();
  //}
};

// XXX can't use setChildFramePar here, because we have to use a Map for children:
EF_Reified.prototype.setChildFrame = function(ef, idx) {
  // NOTE: The following assert DOES NOT hold for EF_Reified when adopting:
  //ASSERTDYNVARSROOT("EF_Reified::setChildFrame")
  //console.log(this+'.setchildframe('+ef+','+idx+' parent='+this.parent+')');
  if (idx === 0) {
    if (this.main_child) {
      if (this.main_child.callstack) {
        // merge callstacks of old & new childframes (stack-tests 28,29)
        mergeCallstacks(ef, this.main_child);
      }
      this.main_child.parent = UNDEF;
    }
    this.main_child = ef;
  }
  else {
    if (this.strata_children.has(idx)) {
      if (this.strata_children.get(idx).callstack) {
        // merge callstacks of old & new childframes (stack-tests 28,29)
        mergeCallstacks(ef, this.strata_children.get(idx));
      }
      this.strata_children.get(idx).parent = UNDEF;
    }
    this.strata_children.set(idx,ef);
  }
  ef.parent = this;
  ef.parent_idx = idx;
}

var reified_counter = 0;
function I_reifiedseq(ndata, env) {
  var dynvars = exports.current_dyn_vars;
  var reified_ef = new EF_Reified(++reified_counter/*inner_ef.type()*/, dynvars);

  SETDYNVARS(reified_ef.dynvars, "I_reifiedseq // (1)")

  var inner_ef = new EF_Seq(ndata, env);
  // we're setting pending_caller, in case there is a reentrant adopt:
  // - see also unit/stack-tests:'function abort'
  reified_ef.pending_caller = current_call;
  //console.log("!seq "+reified_ef);
  ++reified_ef.pending;
  // inject stratum interface:
  inner_ef.env.reifiedstratum = reified_ef.reifiedstratum;


  // start inner seq:
  var val = cont(inner_ef, 0);

  if(!(exports.current_dyn_vars === root_dyn_vars || exports.current_dyn_vars === reified_ef.dynvars)) {
    console.log("XXXXXXXXXXXXXXXXX current dynvars = "+exports.current_dyn_vars.id+" / expected=root or "+reified_ef.dynvars.id);
  }

  // initialize stratum ef & return:
  var rv = cont(reified_ef,-1,val);

  ASSERT(exports.current_dyn_vars === root_dyn_vars || exports.current_dyn_vars === reified_ef.dynvars.__oni_anchor_route)

  ASSERT(exports.current_dyn_vars === root_dyn_vars || exports.current_dyn_vars === dynvars)
  if (reified_ef.adopted) {
    SETDYNVARS(dynvars, "I_reifiedseq // (6)(c)")
    return UNDEF;
  }
  else {
    return rv;
  }
}

//----------------------------------------------------------------------
// Bl : instruction node for block lambdas
/*

  Semantics:

  - Blocklambda throws exception if anchor call is finished

*/


// EF_BlSeq is not directly exported - instead it is being called by 'exbl' in blocklambda code

// ndata[0] contains flags - same as for seq
//var blseq_counter = 0;

function EF_BlSeq(ndata, env) {
//  this.blsid = ++blseq_counter;
  this.sid = ++seq_counter;
#ifdef DEBUG_VM
//  this.id = this.blsid; 
  this.id = this.sid;
#endif

  ASSERT(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION)
  ASSERT(!(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE))
  ASSERT(env.blanchor)

  this.ndata = ndata;
  this.env = copyEnv(env);
  
//  this.env.bl = this;

  this.blanchor = env.blanchor;
  this.env.blanchor = undefined;


  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) {
    this.env.blrref = env.blrref;
  }
  else {
    // we're a blocklambda but NOT a scope for any `break`s in child frames (otherwise the compiler would
    // have marked us 'notailcall'). clear blscope so that targeted `break` calls that travel down the call tree will
    // find their way to the correct scope (we need the `break` to 'tunnel' through these non-targeted functions)
    // XXX could equally set this to 'this'
    // this.env.blscope = null;
  }

  this.tailcall = false; //!(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == 0    : returns tunnel through us
  // swallow_r == 1    : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  // swallow_r == 3    : 'catch' a tailcalled Return(exp) that should not be returned (i.e. convert to undefined)

  // we swallow returns, because 'continue's are encoded as returns:
//  this.swallow_r = 1;
//  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
//    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

}
setEFProto(EF_BlSeq.prototype={});
#ifdef EF_TYPES
EF_BlSeq.prototype.type = function() { 
  var rv = "BlSeq";
  return rv;
};
#endif
EF_BlSeq.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    // child frame being replaced:
    this.setChildFrame(val, idx);
  }
  else {
    if (is_cfx(val) || this.aborted) {
      // pass through exceptions/abort
      if (is_cfx(val)) val = this.translateCFEs(val);
      
      // some cleanup first:
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF;
      }
      
      return this.returnToParent(val);
    }
    while (idx<this.ndata.length) {
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF; // ensures correct reentrant aborting
      }
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench();
          val = val.abort(this.pseudo_abort);
          if (!is_ef(val)) {
            if (is_cfx(val)) val = this.translateCFEs(val);
            return this.returnToParent(val);
          }
        }
        //XXX needed? -> No, this leads to the wrong aborting behavior:
        //if (!is_cfx(val) && !is_ef(val)) val = UNDEF;
        //console.log(this + ' returning '+val+' to '+this.parent);
        //return this.returnToParent(val);
      }
      ++idx;
//      if (++idx == this.ndata.length && this.tailcall) {
//        // tail call optimization: 
//        break;
//      }
      if (is_cfx(val)) {
        val = this.translateCFEs(val);
        break; // bail out of while loop
      }
      else if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
//    console.log(this+' returning '+val);
    return this.returnToParent(val);
  }
};

EF_BlSeq.prototype.translateCFEs = function(val) {
//  console.log(this+":translateCFEs: "+val);
  switch(val.type) {
  case 'b':
    // a break inside a blocklambda becomes a blocklambda break, which will be caught by the FAcall 'blanchor':
    val = new CFException('blb');
    break;
  case 'r':
    // a return inside a blocklambda becomes a blocklambda return, which will be caught by the FAcall 'blanchor':
    val = new CFException('blr', val.val);
    break;
  case 'c':
    return UNDEF;
  default:
    return val;
  }

  // we have a blb or blr:
  val.aid = this.blanchor.aid;

  // check routability:
//  console.log(this+"::assertRoutable");
//  console.log(exports.current_dyn_vars);
  var node = exports.current_dyn_vars;
  while (node) {
//    console.log(node.__oni_anchor+' --- '+val.aid);
    if (node.__oni_anchor === val.aid) {
//      console.log("ANCHOR FOUND");
      return val;
    }
    node = node.__oni_anchor_route;
  }

  console.log(this+"::assertRoutable ANCHOR NOT FOUND!!!");
  return new CFException("t", new Error("Unroutable blocklambda break/return"));
};

EF_BlSeq.prototype.abort = function(pseudo_abort) {
#ifdef DEBUG_VM
  if (this.aborted) {
    console.log('ERROR: '+ this + ': redundant abort');
  }
  // leave the assert, so that the process exits:
  ASSERT(!this.aborted)
#endif
  this.aborted = true;
  if (this.breaking) return UNDEF;
  this.pseudo_abort = pseudo_abort;
  // see sjs-2-test 'reentrant quench/abort' for why we need to
  // check for 'this.child_frame' here and in 'quench'
  if (!this.child_frame) {
    //console.log(this+ ' reentrant abort');
    // reentrant abortion
    SETDYNVARS(root_dyn_vars, 'blseq::reentrant abort')
    return this;
  }
  else {
//    console.log(this + ' abort child frame:'+this.child_frame);
    var abort_val = this.child_frame.abort(pseudo_abort);
//    console.log(this + ' abort  val = '+abort_val);
    if (is_ef(abort_val)) {
      return this; // need to stay in picture because abort must not return child frame
    }
    else {
      if (is_cfx(abort_val)) abort_val = this.translateCFEs(abort_val);
      if (is_annotated_oni_cfx(abort_val) && this.callstack) {
#ifdef DEBUG_STACK
        console.log(this+" 5 adding ",this.callstack," to "+abort_val.val);
#endif
        abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
      }
      
      // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
      this.unreturnable = true;
      return abort_val;
    }
  }
};
/*
EF_BlSeq.prototype.do_break = function() {
  // XXX abort the blseq
//  console.log(this + ' do_break');
  this.breaking = true;
  return this.blanchor.do_break();
};
*/
// called only by 'exbl':
function I_blseq(ndata, env) {
  ASSERT(env.blanchor)
  if (env.blanchor.unreturnable) return new CFException("t", new Error("Blocklambda anchor at "+env.file+":"+env.blanchor.ndata[1]+" is inactive."));
  return cont(new EF_BlSeq(ndata, env), 1);
}


// structure of ndata array:
#define NDATA_BLOCKLAMBDA_JSFUNC() ndata
function I_blocklambda(ndata, env) {
  return NDATA_BLOCKLAMBDA_JSFUNC().bind(env);
}
//exports.Bl = makeINCtor(I_blocklambda);
exports.Bl = function(f) {
  return {
    exec: I_blocklambda,
    ndata: f,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Reify (executed by 'reifiedStratum' builtin)

// no execution frame needed, but we need access to 'env'
// could also encode this as a strict function:
// kernel-sjs: nblock, 'return __oni_rt.Reify(this)'

function I_reify(ndata, env) {
  var s = env.reifiedstratum;
  if (!s) return new CFException("t", new Error("Context is not reifiable"));
  return s;
};

exports.Reify = function() {
  return {
    exec: I_reify,
    ndata: undefined,
    __oni_dis: token_dis
  };
};

//----------------------------------------------------------------------
// Sc : simple strict function call
//
// executes env.SC_L(arg1, arg2, ...) where arg1..n are strictly
// evaluated instruction nodes


// structure of ndata array:
#define NDATA_SC_LINE() ndata[0]
#define NDATA_SC_L() ndata[1]
#define NDATA_SC_ARGS_OFFSET 2
// ndata[NDATA_SC_ARGS_OFFSET..end] : sc args

/*
  continuation index:
   0 : start
   1 : returning from args evaluation
*/

function EF_Sc(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_SC_ARGS_OFFSET;
  this.pars = [];
}
setEFProto(EF_Sc.prototype={});
#ifdef EF_TYPES
EF_Sc.prototype.type = "Sc";
EF_Sc.prototype.toString = function() {
  return "<Sc@"+this.env.file.substr(-20)+':'+this.ndata[0]+'>';
};
#endif

EF_Sc.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }
    return this.returnToParent(val);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 20
    }
    if (idx == 1) {
      // handle a result that has been passed in
      this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1);
        return this;
      }
      this.pars.push(rv);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the pars, let's do the call:
    try {
        rv = this.NDATA_SC_L().apply(this.env, this.pars);
    }
    catch (e) {
      rv = new CFException("t", e,
                           this.NDATA_SC_LINE(),
                           this.env.file);
    }
    return this.returnToParent(rv);
  }
};

function I_sc(ndata, env) {
  return cont(new EF_Sc(ndata, env), 0);
}

//exports.Sc = makeINCtor(I_sc);
exports.Sc = function(...args) {
  return {
    exec: I_sc,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Fcall : instruction node for calling a function 

// IE-safe helper to determine if something is a function
function testIsFunction(f) {
  if (typeof f == "function") return true;
  // ... else, the IE/Safari workarounds (some things like
  // document.getElementById are not functions)
  // try 1:
//  return ((""+f).indexOf("[native code]") != -1) ||
//    ((""+f).indexOf("Constructor]") != -1);
  // try 2: (doesn't catch "[object ...]")
//  return ((""+f).indexOf("[") != -1 )
  // try 3:
  // don't catch things like: html::Element[div] (stringification of mho:surface html primitives) 
  return /(^| )\[[^o]/.test(""+f);
}  

// structure of ndata array:
// mode: 0: normal call, 1: reference call, 2: 'new' call
#define FCALL_MODE_NORMAL    0
#define FCALL_MODE_REFERENCE 1
#define FCALL_MODE_NEW       2
#define FCALL_FLAGS_MODE_MASK 3
#define FCALL_FLAG_SPREAD 4
#define NDATA_FCALL_FLAGS() ndata[0]
#define NDATA_FCALL_LINE() ndata[1]
#define NDATA_L_INDEX 2
#define NDATA_FCALL_L() ndata[2]
#define NDATA_FCALL_ARGS_OFFSET 3
// ndata[NDATA_FCALL_ARGS_OFFSET..end] : fcall args
// if FCALL_FLAG_SPREAD is set, then last arg is array of 0-based indices of args that should be spread (...)
/*
  continuation index:
   0 : start
   1 : returning from l/pars evaluation
   2 : returning from 'new' call (need to return 'this.o') 
*/

function EF_Fcall(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];

}
setEFProto(EF_Fcall.prototype={});
#ifdef EF_TYPES
EF_Fcall.prototype.type = "Fcall";
EF_Fcall.prototype.toString = function() { return "<Fcall@"+this.env.file.substr(-20)+":"+this.NDATA_FCALL_LINE()+">"};
#endif

EF_Fcall.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    // XXX CLEANUP childframe
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // returning from a 'new' call
    return this.returnToParent(typeof val === 'object' ? val : this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i===NDATA_FCALL_ARGS_OFFSET) {
        this.l = val;
      }
      else
        this.pars.push(val);
    }
    var rv;
    var args_length = this.ndata.length;
    if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) --args_length;
    while (this.i<args_length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1, true); // prevent unnecessary callstack copying
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    }
    
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the left side + pars, let's do the call:
    try {
      var pars;

      if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) {
        pars = [];
        var spreads = this.ndata[this.ndata.length-1];
        for (var i=0; i<this.pars.length;++i) {
          if (spreads[0] === i) {
            pars = pars.concat(this.pars[i]);
            spreads.shift();
          }
          else
            pars.push(this.pars[i]);
        }
      }
      else 
        pars = this.pars;

      current_call = [this.env.file, this.NDATA_FCALL_LINE()];

      switch (this.NDATA_FCALL_FLAGS() & FCALL_FLAGS_MODE_MASK) {
      case FCALL_MODE_NORMAL:
      // 'normal' call
      if (typeof this.l == "function") {
        rv = this.l(...pars);
      } 
      else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        //        var command = "this.l(";
        //        for (var i=0; i<pars.length; ++i) {
        //          if (i) command +=",";
        //          command += "pars["+i+"]";
        //        }
        //        command += ")";
        try {
          this.l(...pars);
        //          rv = eval(command);
        }
        catch (e) {
          // we have a bit of a problem now... the command could have
          // failed because the "function" wasn't a function after
          // all, or because running the builtin failed. As this is
          // mainly a problem on windows (maybe also safari?) we'll
          // take a punt and replace the (cryptic) exception we get
          // ("this.l isn't a function") by a saner one:
          rv = new CFException("t",
                               new Error("'"+this.l+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_REFERENCE:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA !== "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<pars.length; ++i) {
          if (i) command +=",";
          command += "pars["+i+"]";
        }
        command += ")";

        try {
          rv = eval(command);
        }
        catch (e) {
          // as above, we have a bit of a problem now... the command
          // could have failed because the "function" wasn't a
          // function after all, or because running the builtin
          // failed. As this is mainly a problem on windows (maybe
          // also safari?) we'll take a punt and replace the (cryptic)
          // exception we get ("this.l isn't a function") by a saner
          // one:
          rv = new CFException("t",
                               new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_NEW:
        // 'new' call
        var ctor = this.l;
        rv = new ctor(...pars);
        if (is_ef(rv)) {
          if (!rv.env) throw new Error("Invalid constructor function (no environment)");
          this.o = rv.env.tobj;
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      if (is_cfx(e)) {
        rv = e;
      }
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }
    if (is_ef(rv)) {
      if (this.aborted) {
        // reentrant abortion
        rv = rv.abort(this.pseudo_abort);
        return this.returnToParent(rv);
      }

      // the call is blocking -> insert ourselves into callstack:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([this.env.file, this.NDATA_FCALL_LINE()]);
    }
    return this.returnToParent(rv);
  }
};

function I_fcall(ndata, env) {
  return cont(new EF_Fcall(ndata, env), 0);
}

//exports.Fcall = makeINCtor(I_fcall);
exports.Fcall = function(...args) {
  return {
    exec: I_fcall,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// FAcall: Fcall that is an anchor for a blocklambda
// same ndata format as fcall, but in addition we have:
/*
  continuation index:

    3: returning from waiting for function call result (we're never tail-called)
*/

var facall_counter = 0;

function EF_FAcall(ndata, env) {
  // this.aid is an id used in blocklambda break and return references.
  this.aid = ++facall_counter;

  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];

  // inject ourselves into environment:
  this.env = copyEnv(env);
  this.env.blanchor = this;

  this.parent_dynvars = exports.current_dyn_vars;
  this.facall_dynvars = createDynVarContext(exports.current_dyn_vars);
  this.facall_dynvars.__oni_anchor_route = exports.current_dyn_vars;
  this.facall_dynvars.__oni_anchor = this.aid;
}
setEFProto(EF_FAcall.prototype={});
#ifdef EF_TYPES
EF_FAcall.prototype.type = "FAcall";
EF_FAcall.prototype.toString = function() { return "<FAcall@"+this.env.file.substr(-20)+":"+this.NDATA_FCALL_LINE()+">"};
#endif

EF_FAcall.prototype.cont = function(idx, val) {
//console.log(this+'.cont('+idx+','+val+')');
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val) || this.aborted) {
    if (is_cfx(val)) val = this.translateCFEs(val);
    // XXX CLEAN UP CHILDFRAME
    ASSERT(!is_ef(val))
    SETDYNVARS(this.parent_dynvars, "FAcall::cont(cfx/abort) //(7)(b)")
    return this.returnToParent(val);
  }
  else if (idx === 3) {
    ASSERT(!is_ef(val))
    SETDYNVARS(this.parent_dynvars, "FAcall::cont(idx3) //(7)(b)")
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // XXX can this go?
    // returning from a 'new' call
    if (exports.current_dyn_vars !== this.parent_dynvars) console.log(">>>>>>>>>>>>> HIT 1/2");
    SETDYNVARS(this.parent_dynvars, "FAcall::cont(idx2) //(7)(b)")
    return this.returnToParent(typeof val === 'object' ? val : this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i===NDATA_FCALL_ARGS_OFFSET) {
        this.l = val;
      }
      else
        this.pars.push(val);
    }
    var rv;
    var args_length = this.ndata.length;
    if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) --args_length;
    while (this.i<args_length) {
//      if (this.i === NDATA_FCALL_ARGS_OFFSET) { SETDYNVARS(this.facall_dynvars, "FAcall<"+this+"> arg //(7)") }
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          if (exports.current_dyn_vars !== this.parent_dynvars) console.log(">>>>>>>>> HIT 2");
          if (!is_ef(rv)) {
            SETDYNVARS(this.parent_dynvars, "FAcall.cont[reent par abort] //(7)(b)")
          }
          else {
            ASSERTDYNVARSROOT('facall 3321')
          }
          // XXX can we return child ef here??? TESTCASE
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) {
        if (exports.current_dyn_vars !== this.parent_dynvars) console.log(">>>>>>>>>>> HIT 3");
        SETDYNVARS(this.parent_dynvars, "FAcall.cont[par cfx] //(7)(a)")
        return this.returnToParent(rv);
      }
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1, true); // prevent unnecessary callstack copying
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    } // while
  
//    ASSERT(this.facall_dynvars === exports.current_dyn_vars)
    SETDYNVARS(this.facall_dynvars, "FAcall.cont[call]")

    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the left side + pars, let's do the call:
    try {
      var pars;

      if (this.NDATA_FCALL_FLAGS() & FCALL_FLAG_SPREAD) {
        pars = [];
        var spreads = this.ndata[this.ndata.length-1];
        for (var i=0; i<this.pars.length;++i) {
          if (spreads[0] === i) {
            pars = pars.concat(this.pars[i]);
            spreads.shift();
          }
          else
            pars.push(this.pars[i]);
        }
      }
      else 
        pars = this.pars;

      current_call = [this.env.file, this.NDATA_FCALL_LINE()];

      switch (this.NDATA_FCALL_FLAGS() & FCALL_FLAGS_MODE_MASK) {
      case FCALL_MODE_NORMAL:
      // 'normal' call
      if (typeof this.l == "function") {
        rv = this.l(...pars);
      } 
      else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        //        var command = "this.l(";
        //        for (var i=0; i<pars.length; ++i) {
        //          if (i) command +=",";
        //          command += "pars["+i+"]";
        //        }
        //        command += ")";
        try {
          this.l(...pars);
        //          rv = eval(command);
        }
        catch (e) {
          // we have a bit of a problem now... the command could have
          // failed because the "function" wasn't a function after
          // all, or because running the builtin failed. As this is
          // mainly a problem on windows (maybe also safari?) we'll
          // take a punt and replace the (cryptic) exception we get
          // ("this.l isn't a function") by a saner one:
          rv = new CFException("t",
                               new Error("'"+this.l+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_REFERENCE:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA !== "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        // XXX is this still a thing?
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<pars.length; ++i) {
          if (i) command +=",";
          command += "pars["+i+"]";
        }
        command += ")";

        try {
          rv = eval(command);
        }
        catch (e) {
          // as above, we have a bit of a problem now... the command
          // could have failed because the "function" wasn't a
          // function after all, or because running the builtin
          // failed. As this is mainly a problem on windows (maybe
          // also safari?) we'll take a punt and replace the (cryptic)
          // exception we get ("this.l isn't a function") by a saner
          // one:
          rv = new CFException("t",
                               new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case FCALL_MODE_NEW:
        // 'new' call
        var ctor = this.l;
        rv = new ctor(...pars);
        if (is_ef(rv)) {
          if (!rv.env) throw new Error("Invalid constructor function (no environment)");
          this.o = rv.env.tobj;
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
//      console.log(this + " caught "+e);
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      if (is_cfx(e)) {
        rv = this.translateCFEs(e);
       //see below rv = this.translateCFEs(e);
      }
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }

    if (is_ef(rv)) {
      ASSERTDYNVARSROOT('facall 23266')
      if (this.aborted) {
        // reentrant abortion
        rv = rv.abort(this.pseudo_abort);
        if (!is_ef(rv)) {
          if (is_cfx(rv)) rv = this.translateCFEs(rv);
          SETDYNVARS(this.parent_dynvars, "FAcall::cont[reset 1]")
          return this.returnToParent(rv);
        }
      }
      if (rv) {
        // the call is blocking -> insert ourselves into callstack:
        if (!rv.callstack) rv.callstack = [];
        rv.callstack.push([this.env.file, this.NDATA_FCALL_LINE()]);
      }
    }

    // make sure we're not tail-called:
    if (is_ef(rv)) {
      ASSERTDYNVARSROOT('facall 232ds66')
      this.setChildFrame(rv, 3);
      return this;
    }
    else {
      SETDYNVARS(this.parent_dynvars, "FAcall::cont[reset 2]")
      return this.returnToParent(rv);
    }
  }
};

EF_FAcall.prototype.translateCFEs = function(val) {
//  console.log(this+"::translateCFEs:"+val);
  if (val.type === 'blb' && val.aid === this.aid) {
    val = UNDEF;
  }
  else if (val.type === 'blr' && val.aid === this.aid) {
    val = new CFException('r', val.val);
  }
  return val;
};

  // abort must either return 'this' (if we need to wait), or a controlflow exception
EF_FAcall.prototype.abort = function(pseudo_abort) {
#ifdef DEBUG_VM
  if (this.aborted) {
    console.log('ERROR: '+this + ': redundant abort');
  }
  // leave the assert, so that the process exits:
  ASSERT(!this.aborted)
#endif
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  // see sjs-2-test 'reentrant quench/abort' for why we need to
  // check for 'this.child_frame' here and in 'quench'
  if (!this.child_frame) {
    // reentrant abortion
    SETDYNVARS(root_dyn_vars, 'facall::redundant abort')
    return this;
  }
  else {
    var abort_val = this.child_frame.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      ASSERTDYNVARSROOT('FACall::abort 23')
      return this; // need to stay in picture because abort must not return child frame
    }
    else {
      if (is_annotated_oni_cfx(abort_val) && this.callstack) {
#ifdef DEBUG_STACK
        console.log(this+" 6 adding ",this.callstack," to "+abort_val.val);
#endif
        abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
      }
      
      // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
      // XXX needed?
      this.unreturnable = true;

      if (is_cfx(abort_val)) abort_val = this.translateCFEs(abort_val);

      ASSERT(!is_ef(abort_val))
      SETDYNVARS(this.parent_dynvars, "FAcall::abort // (7)(b)")

      return abort_val;
    }
  }
};


function I_facall(ndata, env) {
  return cont(new EF_FAcall(ndata, env), 0);
}

//exports.FAcall = makeINCtor(I_facall);
exports.FAcall = function(...args) {
  return {
    exec: I_facall,
    ndata: args,
    __oni_dis: token_dis
  }
};


//----------------------------------------------------------------------
// If : instruction node for executing 'if'

// structure of ndata array:
#define NDATA_IF_TEST() ndata[0]
#define NDATA_IF_CONSEQUENT() ndata[1]
#define NDATA_IF_ALTERNATIVE() ndata[2]

/*
  continuation index:
   0 : start
   1 : returning from test evaluation
*/

#ifdef DEBUG_VM
var if_counter = 0;
#endif

function EF_If(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++if_counter;
#endif
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_If.prototype={});
#ifdef EF_TYPES
EF_If.prototype.type = "If";
#endif

EF_If.prototype.cont = function(idx, val) {
  switch (idx) {
  case 0:
  //  LOG("IF: exec test")
  val = execIN(this.NDATA_IF_TEST(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

  //  LOG("IF: test execed:"+val)
  case 1:
  if (is_cfx(val) || this.aborted) {
    // XXX CLEAN UP CHILD FRAME
    break;
  }
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  // tail calls:
  if (val)
    val = execIN(this.NDATA_IF_CONSEQUENT(), this.env);
  else
    val = execIN(this.NDATA_IF_ALTERNATIVE(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
      }
    }
  break;
  default:
  val = new CFException("i", "invalid state in EF_If");
  }
  return this.returnToParent(val);
};

function I_if(ndata, env) {
  return cont(new EF_If(ndata, env), 0);
}

//exports.If = makeINCtor(I_if);
exports.If = function(...args/*t,c,a*/) {
  return {
    exec: I_if,
    ndata: args, //[t,c,a],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Switch: instruction node for executing 'switch() { case/default }'

// exported objected designating a 'default' clause:
var Default = {};
exports.Default = Default;

// structure of ndata array:
#define NDATA_SWITCH_EXP() ndata[0]
#define NDATA_SWITCH_CLAUSES() ndata[1]

/*
  continuation index:

phase 0: (evaling switch exp)

   0    : start
   1    : returning from switch expression evaluation

phase 1: (testing clause exp)
   -1   : entering from switch exp evaluation
   0..n : returning from given clause exp 


phase 2: (executing clause code)

   0...n : next clause to run
*/

function EF_Switch(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.phase = 0;
}
setEFProto(EF_Switch.prototype={});
#ifdef EF_TYPES
EF_Switch.prototype.type = "Switch";
#endif

EF_Switch.prototype.cont = function(idx, val) {
  switch (this.phase) {
  case 0: // evaluate switch expression
  if (idx == 0) {
    val = execIN(this.NDATA_SWITCH_EXP(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  if (is_cfx(val) || this.aborted) {
    // XXX CLEAN UP CHILD FRAME
    return this.returnToParent(val);
  }
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  this.phase = 1;
  this.testval = val;
  idx = -1;
  case 1: // test clauses until we find a matching one
  while (true) {
    if (idx > -1) { // returning from evaluation of clause test idx
      if (is_cfx(val)) return this.returnToParent(val);
      if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
      else if (val == Default || val == this.testval)
        break; // go into phase 2!
    }
    if (++idx >= this.NDATA_SWITCH_CLAUSES().length)
      return this.returnToParent(null); // all done; no matching clause found
    // test next clause:
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 21
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][0], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  this.phase = 2;
  val = 0;
  case 2: // run clauses
  while (true) {
    if (is_ef(val)) {
      this.setChildFrame(val, idx);
      return this;
    }
    if (is_cfx(val)) {
      if (val.type == "b") {
        val = val.val;
      }
      return this.returnToParent(val);
    }
    if (idx >= this.NDATA_SWITCH_CLAUSES().length) {
      return this.returnToParent(val);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 22
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][1], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
    ++idx;
  }
  default:
  throw new Error("Invalid phase in Switch SJS node");
  }
};

function I_switch(ndata, env) {
  return cont(new EF_Switch(ndata, env), 0);
}

//exports.Switch = makeINCtor(I_switch);
exports.Switch = function(...args/*exp, clauses*/) {
  return {
    exec: I_switch,
    ndata: args, //[exp, clauses],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Try : instruction node for try/catch/finally

// structure of ndata array:
// ndata[0] contains flags.
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE TRY_FLAG_'s in kernel-sjs.js.in
#define NDATA_TRY_FLAG_NONE 0
#define NDATA_TRY_FLAG_AUGMENTED_FINALLY 1

#define NDATA_TRY_FLAGS() ndata[0]
#define NDATA_TRY_TRY_BLOCK() ndata[1]
#define NDATA_TRY_CATCH_FUNC() ndata[2]
#define NDATA_TRY_FINALLY_BLOCK() ndata[3]
#define NDATA_TRY_RETRACT_BLOCK() ndata[4]

/*
  continuation index not used, we use this.state instead (since we
  need to know the state when we get an abort):

  0 : start
  1 : returning from try block
  2 : returning from catch
  3 : returning from retract
  4 : returning from finally

*/

#ifdef DEBUG_VM
var try_counter = 0;
#endif

function EF_Try(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++try_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.state = 0;
}
setEFProto(EF_Try.prototype={});
#ifdef EF_TYPES
EF_Try.prototype.type = function() { return "Try("+this.state+")" };
#endif

EF_Try.prototype.cont = function(idx, val) {
  //console.log(this+'.cont('+idx+','+val+', state='+this.state+')');
  if (is_ef(val)) {
    this.setChildFrame(val, this.state);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      // ensure correct reentrant aborting:
      // XXX not sure if this is negatively impacting call-stack copying
      this.child_frame = UNDEF; 
    }

    switch (this.state) {
    case 0:
    this.state = 1;
    val = execIN(this.NDATA_TRY_TRY_BLOCK(), this.env);

    if (is_ef(val)) {
      this.setChildFrame(val);
      return this;
    }
    case 1:
      // returning from try block
      this.state = 2;

/* XXX NOT SURE THIS IS NEEDED AFTER ALL
      // XXX consolidate this with the code in EF_Reified
      
      if (is_cfx(val) && (val.type === 'blb' || val.type === 'blr')) {
        console.log(this+"::assertRoutable (3rd line)");
        var node = exports.current_dyn_vars;
        while (node) {
          if (node.__oni_anchor === val.aid) break;
          node = node.__oni_anchor_route;
        }
        if (!node) val = new CFException("t", new Error("Unroutable blocklambda break/return"));
      }
*/
      if (this.NDATA_TRY_CATCH_FUNC() &&
          (is_cfx(val) && val.type == "t")) {
        var v;
        v = val.val;
        val = this.NDATA_TRY_CATCH_FUNC()(this.env, v);
        
        // Check for a reentrant abortion triggered by our catch() block
        // see sjs-2-tests.sjs: reentrant abortion from catch()
        if (this.aborted && is_ef(val)) {
          val.quench();
          val = val.abort(this.pseudo_abort);
        }

        // tail-call optimization:
        // The !(aborted&&is_ef) check is important because cont() is called from EF_Try::abort, and 
        // we don't want to be replaced by a child frame.
        if (!this.NDATA_TRY_RETRACT_BLOCK() && 
            !this.NDATA_TRY_FINALLY_BLOCK() && 
            !(this.aborted && is_ef(val))) {
          return this.returnToParent(val);
        }
        
        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 23
          return this;
        }
      }
    case 2:
    // returning from try/catch
    this.state = 3;
    // save value from catch/try:
    this.rv = val;
    if (((this.aborted && !this.pseudo_abort) || (is_cfx(val) && (val.type==='blb'||val.type==='blr'))) && this.NDATA_TRY_RETRACT_BLOCK()) {
      val = execIN(this.NDATA_TRY_RETRACT_BLOCK(), this.env);

      // tail-call optimization:
      // XXX this breaks sjs-testsuite2:51
      //if (!this.NDATA_TRY_FINALLY_BLOCK())
      //  return this.returnToParent(val);


      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 3:
    // returning from try/catch/retract
    this.state = 4;

    // make sure exceptions from retract get passed through:
    if (is_cfx(val) && val.type === "t") {
      this.rv = val;
    }

    if (this.NDATA_TRY_FINALLY_BLOCK()) {
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        // Can pass in `this.parent` below, for debugging purposes:
        // `try { hold(0); } finally(e) { console.log(e[4]); throw e; }`
        // gives the current ef.
        var v = is_cfx(this.rv) ?
          [this.rv, true, !!this.aborted, !!this.pseudo_abort, this.parent] :
          [this.rv, false, !!this.aborted, !!this.pseudo_abort, this.parent];
        val = this.NDATA_TRY_FINALLY_BLOCK()(this.env, v);
      }
      else {
        val = execIN(this.NDATA_TRY_FINALLY_BLOCK(), this.env);
      }
      // we can't tail-call this, because we might have to return
      // the stored rv (if it is an exception)
      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 4:
      // returning from finally
      
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        if (!is_cfx(val)) {
          val = new CFException("t", new Error("augmented finally(){} block needs to throw a value"));
        }
        else {
          // we expect 'throw' in an augmented finally(e){} to rethrow
          // 'e' (or an array with a value - exception or otherwise - as 
          // first argument). 
          // We also want to be able to cope with 'real' exceptions thrown
          // if e.g. there is a logic error in the finally block, so we
          // only resolve to val.val[0] if val.val is an array:
          if (Array.isArray(val.val))
            val = val.val[0];
        }
      }
      else {
        // override res with stored exception (from try or catch) if
        // val isn't an exception
        // It would make sense to never override a real exception thrown in try with
        // a 'return' or 'break' from finally, but - alas - js parity compels us to do so.
        if (!is_cfx(val)) {
          val = this.rv;
          //else if (this.aborted)
          //  val = UNDEF;
        }
        else if (is_cfx(this.rv) && this.rv.type === 't' && this.rv !== val) { // val is an exception and we have a pending exception from try/catch
          // while we cannot override finally's exception, we can log the fact that we are 
          // swallowing an exception:
          var msg; 
          if (val.type === 't')
            msg = "Exception '"+val.val+"' thrown";
          else
            msg = CFETypes[val.type];
          msg += " in finally{} clause overriding try/catch exception '"+this.rv.val+"'";
          if (console.error) console.error(msg);
          else console.log(msg);
        }
      }
    break;
    default:
    val = new CFException("i", "invalid state in CF_Try");
    }
    return this.returnToParent(val);
  }
};

EF_Try.prototype.quench = function() {
  if (this.child_frame && this.state !== 4 && this.state !== 3) // don't quench inside finally or retract blocks
    this.child_frame.quench();
};

EF_Try.prototype.abort = function(pseudo_abort) {
  //console.log(this + ' ABORT, parent = '+this.parent);
#ifdef DEBUG_VM
  if (this.aborted) {
    console.log('ERROR: '+this + ' redundant abort');
    ASSERT(!this.aborted) // sanity check; aborted before
  }
#endif
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;

  if (!this.child_frame) {
    SETDYNVARS(root_dyn_vars, "try::reentrant abort")
    return this; // reentrant abort
  }

  ASSERT(this.state !== 3) // sanity check; aborted before
  if (this.state !== 4) { // don't abort finally block
    var val = this.child_frame.abort(this.pseudo_abort); 
    if (is_ef(val)) {
      // we need to wait for the try or catch block, and then let
      // cont() proceed with retract/finally:
      this.setChildFrame(val);
    }
    else {
      // attempt to execute catch/retract/finally blocks synchronously:

      // Leftover from old abort code. Not sure what the logic was here.
      // prevent continuation from ending up at parent, we want to feed
      // it to the abortee directly:
      // this.parent = UNDEF;

      // temporarily need to turn off async flag, so that 'returnToParent' doesn't attempt to 
      // return to non-existing parent, which would cause exceptions to go uncaught
      this.async = false;
      var rv = cont(this, 0, val);
      ASSERT(!is_ef(rv) || rv === this)
      if (rv !== this) {
        // XXX this would override any finally(e) clauses.
        //if (!is_cfx(rv))
        //  rv = val;
        //console.log(this+' abort returning '+rv);
        return rv;
      }
      else {
        this.rv = val; // XXX not sure this is necessary, since we passed 'val' to 'cont', above
        this.async = true;
      }
      // & fall through. we need to block
    }
  }
  else {
    SETDYNVARS(root_dyn_vars, 'Try::abort state 4')
  }
  ASSERTDYNVARSROOT(this+': Try::abort')
  return this;
};

function I_try(ndata, env) {
  return cont(new EF_Try(ndata, env), 0);
}

//exports.Try = makeINCtor(I_try);
exports.Try = function(...args) {
  return {
    exec: I_try,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Loop : instruction node for looping constructs

// structure of ndata array:
#define NDATA_LOOP_INIT_STATE() ndata[0]
#define NDATA_LOOP_TEST() ndata[1]
#define NDATA_LOOP_INC() ndata[2]
#define NDATA_LOOP_BODY(i) ndata[i+1]

/*
  continuation index:
   0 : perform test next
   2 - ndata.length+2 : perform body NDATA_LOOP_BODY+i-2 next
   1 : perform inc next 
*/

function EF_Loop(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Loop.prototype={});
#ifdef EF_TYPES
EF_Loop.prototype.type = "Loop";
#endif

EF_Loop.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (this.aborted) {
    if (is_cfx(val)) {
      if (val.type === 'c' || val.type === 'b') val = UNDEF;
    }
    return this.returnToParent(val);
  }
  else {
    while (true) {
      // test:
      if (idx === 0) {
        if (is_cfx(val) || this.aborted) {
          // maybe return value from body here
          return this.returnToParent(val);
        }
        // perform loop test
        val = execIN(this.NDATA_LOOP_TEST(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying; stack-tests 26
          return this;
        }
        idx = 2; // body next
      }
      // body:
      if (idx > 1) {
        if (idx === 2) {
          // examine return value from loop test:
          if (!val || is_cfx(val) || this.aborted) {
            // maybe return value from body here
            return this.returnToParent(val);
          }
        }
        while (1) {
          if (idx > 2) {
            if (is_cfx(val)) {
              if (val.type === "b") {
                // break statement
                val = UNDEF;
              }
              else if (val.type === "c") {
                // continue statement
                val = UNDEF;
                // break out of the loop; pick up again at increment:
                break;
              }
              return this.returnToParent(val);
            }
            if (idx >= this.ndata.length)
              break; // pick up at increment
          }
            
          // perform body
          if (this.child_frame) {
            this.child_frame.parent = UNDEF;
            this.child_frame = UNDEF; // ensure correct reentrant aborting & prevent callstack copying 
          }
          val = execIN(this.NDATA_LOOP_BODY(idx), this.env);
          if (this.aborted) {
            // a reentrant abortion
            if (is_ef(val)) {
              val.quench(); // not sure this is needed here XXX
              val = val.abort(this.pseudo_abort);
              // the is_ef check is crucial here, because the frame might still produce 'break's which the loop
              // must see - (see sjs-2-tests 'blocking finally clause in loop is abort point' ?)
              if (!is_ef(val))
                return this.returnToParent(val);
            }
          }
          ++idx;
          if (is_ef(val)) {
            this.setChildFrame(val, idx);
            return this;
          }
        }
        idx = 1;
      }
      // this point will be reached directly if idx = 1
      if (this.NDATA_LOOP_INC())  {
        // perform inc
        val = execIN(this.NDATA_LOOP_INC(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 27
          return this;
        }
      }
      idx = 0;
    }
  }
};

function I_loop(ndata, env) {
  return cont(new EF_Loop(ndata, env), NDATA_LOOP_INIT_STATE(), true);
}

//exports.Loop = makeINCtor(I_loop);
exports.Loop = function(...args) {
  return {
    exec: I_loop,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// ForIn : instruction node for 'for-in' loops

// structure of ndata array
#define NDATA_FORIN_OBJ()  ndata[0]
#define NDATA_FORIN_LOOPF() ndata[1]

/*
  continuation index:
   0   : start
   1   : returning from evalution of forin obj
   2   : returning from loopf
*/

function EF_ForIn(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_ForIn.prototype={});
#ifdef EF_TYPES
EF_ForIn.prototype.type = "ForIn";
#endif

EF_ForIn.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == 0) {
      val = execIN(this.NDATA_FORIN_OBJ(), this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          return this.returnToParent(val);
        }
      }

      if (is_ef(val)) {
        this.setChildFrame(val, 1, true); // prevent callstack copying
        return this;
      }
      idx = 1;
    }
    if (idx == 1) {
      // returning from evaluation of forin obj
      if (is_cfx(val) || this.aborted)
        return this.returnToParent(val);
      var for_in_obj = val;
      for (var x in for_in_obj) {
        if (typeof this.remainingX === 'undefined') {
          val = this.NDATA_FORIN_LOOPF()(this.env,x);
          if (is_cfx(val)) {
              if (val.type == "b") {
                // break statement
                val = UNDEF;
              }
              else if (val.type == "c") {
                // continue
                val = UNDEF;
                continue;
              }
            return this.returnToParent(val);
          }
          if (is_ef(val)) {
            this.remainingX = [];
            this.for_in_obj = for_in_obj;
          }
        }
        else
          this.remainingX.push(x);
      }
      if (is_ef(val)) {
        if (!this.remainingX) this.remainingX = [];
        this.setChildFrame(val, 2, true); // prevent callstack copying
        return this;
      }
      // all done
      return this.returnToParent(val);
    }
    if (idx == 2) {
      while (1) {
        // returning from evaluation of loop
        if (is_cfx(val) || this.aborted) {
            if (val.type == "b") {
              // break
              val = UNDEF;
            }
            else if (val.type == "c") {
              // continue
              val = UNDEF;
              if (this.remainingX.length)
                continue;
            }            
          return this.returnToParent(val);
        }
        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying
          return this;
        }
        var arg;
        while (true) {
          if (!this.remainingX.length) {
            this.for_in_obj = undefined;
            return this.returnToParent(val);
          }
          arg = this.remainingX.shift();
          if (arg in this.for_in_obj)
            break;
        }
        val = this.NDATA_FORIN_LOOPF()(this.env, arg);
        // go round the loop again
      }
    }
  }
};

function I_forin(ndata, env) {
  return cont(new EF_ForIn(ndata, env), 0);
}

//exports.ForIn = makeINCtor(I_forin);
exports.ForIn = function(...args/*obj,loop*/) {
  return {
    exec: I_forin,
    ndata: args, //[obj,loop],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Par : stratified par construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/


// helper for Par & Alt & Reified:
function mergeExceptions(new_exception, original_exception) { 

  if (is_cfx(new_exception)) {
    if (!is_cfx(original_exception)) {
      return new_exception;
    }
    // else... competing exceptions
    // we'll replace any existing exception only if the new exception is a 'true' exception:
    if (new_exception.type !== 't') return original_exception;
    if (console) {
      // XXX not sure what to do. Create a new exception with two sub-exceptions??
      var msg;
      if (original_exception.type === 't')
        msg = "Multiple exceptions from sub-strata. Swallowing "+original_exception.val;
      else
        msg = "Swallowing control-flow exception of type '"+original_exception.type+"' because it is overridden by a true exception";
      if (console.error) console.error(msg);
      else console.log(msg);
    }
    return new_exception;
  }
  else {
    return original_exception;
  }
}

#ifdef DEBUG_VM
var par_counter = 0;
#endif

function EF_Par(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++par_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Par.prototype={});
#ifdef EF_TYPES
EF_Par.prototype.type = "Par";
EF_Par.prototype.toString = function() { return "<Par"+this.id+"@"+this.env.file.substr(-20)+">(aborted="+this.aborted+", inner_aborted="+this.inner_aborted+")"; }
#endif

EF_Par.prototype.cont = function(idx, val) {
//  console.log(this+".cont("+idx+","+val+")");
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        val = execIN(this.ndata[i], this.env);
        if (this.inner_aborted) {
          // this check is to catch the case of reentrant abortion through
          // suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          ASSERTDYNVARSROOT('par:cont')
          this.setChildFrame(val, i);
          if (i<this.ndata.length-1) {
            SETDYNVARS(parent_dyn_vars, "Par::cont[-1] // (2) - verified")
          }
        }
        else if (is_cfx(val)) {
          // an exception aborts all other pending branches:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      }
      // we clear ndata here to:
      //   (a) serve as an indication that we're done with kicking off all children. If ndata is not
      //       UNDEF, we know that we're being called reentrantly - not used yet: see also comment at start of
      //       returnToParent
      //   (b) to aid garbage collection
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension or called reentrantly from a branch that is continued by another branch
      --this.pending;
      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted) {
        // an exception aborts all other pending branches: 
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending < 2) {
      if (this.pendingCFE === undefined) {
        // 'normal' return path:
        
        if (this.pending === 0)
          return this.returnToParent(val);
        // make a tail-call if there is only one last pending child:
        var return_child;
        for (var i=0; i<this.children.length; ++i)
          if ((return_child = this.children[i])) { 
            // We must NOT delete the child array here
            // to prevent a reentrancy case (see sjs-2-tests:par-reentrant-tailcall-edgecase)
            // this.children = undefined;
            SETDYNVARS(root_dyn_vars, "Par::cont[child return] //(3) - verified")
            return this.returnToParent(return_child);
          }
        return this.returnToParent(new CFException("i", "invalid state in Par"));
      }
      else {
        // There is a pending control flow exception which we need to return.
        // Therefore we can't do a tail call.

        // make sure a real exception overrides a normal control flow exception
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        if (this.pending === 0)
          return this.returnToParent(this.pendingCFE);
      }
    }
    SETDYNVARS(root_dyn_vars, "Par::cont[waiting]")
    this.async = true;
    return this;
  }
};

EF_Par.prototype.quench = quenchPar;

EF_Par.prototype.abort = function(pseudo_abort) {
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    SETDYNVARS(root_dyn_vars, "par:redundant abort")
    return this;
    //return this.pendingCFE;
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  return this.abortInner();
};

EF_Par.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a
  // branch excepts)
  // Note that it can be called multiple times in case of reentrant aborts
//  console.log(this+'EF_Par pending before child abort:'+this.pending);
  this.inner_aborted = true;
  for (var i=0; i<this.children.length; ++i)
    if (this.children[i]) {
      var val = this.children[i].abort(this.pseudo_abort);
      if (is_ef(val)) // need to wait on this one...
        this.setChildFrame(val, i);
      else {
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        // aid gc, but note that this will mask any superfluous (and
        // incorrect) cont-calls from the child:
        //this.children[i].parent = UNDEF;

        --this.pending;
        this.children[i] = UNDEF;
      }
    } 

  if (!this.pending) // all done
    return this.pendingCFE; // if there is no pending cfe, pendingCFE is undefined
  // we need to wait:

  SETDYNVARS(root_dyn_vars, "Par::abortInner //(3) - verified")
  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Par.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/and: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.push(['WAITFOR/AND', child_trees]);
    return st;
  };
#endif

EF_Par.prototype.setChildFrame = setChildFramePar;

function I_par(ndata, env) {
  return cont(new EF_Par(ndata, env), -1);
}

//exports.Par = makeINCtor(I_par);
exports.Par = function(...args) {
  return {
    exec: I_par,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Alt : stratified alt construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/

#ifdef DEBUG_VM
var alt_counter = 0;
#endif

function EF_Alt(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++alt_counter;
#endif
  this.ndata = ndata;
  this.env = env;

  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Alt.prototype={});
#ifdef EF_TYPES
EF_Alt.prototype.type = function() {return "Alt(aborted="+!!this.aborted+")"};
#endif

EF_Alt.prototype.cont = function(idx, val) {
//  console.log(this+":ALT("+idx+",val="+val);
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        // create a new environment for 'collapse' support
        // XXX it sucks that we have to create a new environment for each branch here 
        var env = copyEnv(this.env);
        env.fold = this;
        env.branch = i;
        val = execIN(this.ndata[i], env);
                     
        if (this.inner_aborted) {
          // the check for !aborted here is to catch the case of
          // reentrant abortion through suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          return this.pendingRV;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
          if (i < this.ndata.length - 1) {
            SETDYNVARS(parent_dyn_vars, "Alt::cont[-1] //(2) -- verified")
          }
        }
        else {
          // an exception or real value aborts all other pending branches:
          this.pendingRV = val;
          this.quench();
          return this.abortInner();
        }
        if (this.collapsed) break; // don't start any other branches
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension. 
      --this.pending;
      this.children[idx] = UNDEF;
      this.pendingRV = mergeExceptions(val, this.pendingRV);

      if (this.collapsing) {
        // we're returning from an async abort after collapsing
        // (uncommon case; see comment below)
        if (this.pending == 1) {
          // only our collapsing branch is left; continue with it
          var cf = this.collapsing.cf;
          this.collapsing = UNDEF;
          cont(cf, 1);
        }
        return;
      }
      else {
        // 'normal' case

        // abort all pending branches
        if (!this.inner_aborted) {
          if (this.pendingRV === undefined)
            this.pendingRV = val;
          this.quench();
          return this.returnToParent(this.abortInner());
        }
        if (this.pending == 0)
          return this.returnToParent(this.pendingRV);
      }
    }
    this.async = true;
    SETDYNVARS(root_dyn_vars, "EF_Alt final -- needed for sync collapse")
    return this;
  }
};

EF_Alt.prototype.quench = function(except) {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench'.
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally

  if (this.collapsing) {
    // we're being quenched after a collapse; just quench the collapsing branch
    this.children[this.collapsing.branch].quench();
  }
  else {
    // common case, quench all branches (possibly except 'except')
    for (var i=0; i<this.children.length; ++i) {
      if (i!== except && this.children[i])
        this.children[i].quench();
    }
  }
};

EF_Alt.prototype.abort = function(pseudo_abort) {
  // XXX not sure what the rationale was here
  //this.parent = UNDEF;
  if (this.aborted) {
    //XXX not sure what the rationale was here
    //this.pendingRV = UNDEF;
    SETDYNVARS(root_dyn_vars, "alt::redundant abort")
    return this;
  }

  this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  var rv;
  if (!this.inner_aborted) {
    rv = this.abortInner();
  }
  else if (this.pending) {
    SETDYNVARS(root_dyn_vars, "alt::abort")
    rv = this;
  }

  this.pendingRV = this.pendingRV;
  if (rv !== this && !is_cfx(rv)) rv = this.pendingRV;
  return rv;
};

EF_Alt.prototype.abortInner = function() {
//  ASSERT(!this.inner_aborted)

  // see Par::abortInner for more details
  this.inner_aborted = true;
  if (this.collapsing) {
    // we're being aborted after a collapse; just need to abort the collapsing branch
    var branch = this.collapsing.branch;
    this.collapsing = UNDEF;
    var val = this.children[branch].abort(this.pseudo_abort);
    if (is_ef(val)) // need to wait
      this.setChildFrame(val, branch);
    else {
      --this.pending;
      this.children[branch] = UNDEF;
    }
  }
  else {
    // common case: abort all branches
    for (var i=0; i<this.children.length; ++i)
      if (this.children[i]) {
        var val = this.children[i].abort(this.pseudo_abort);
        if (is_ef(val)) // need to wait
          this.setChildFrame(val, i);
        else {
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          --this.pending;
          this.children[i] = UNDEF;
        }
      }
  }
  if (!this.pending)
    return this.pendingRV;

  SETDYNVARS(root_dyn_vars, "Alt::abortInner // (3) - verified")

  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Alt.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/or: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.concat([['WAITFOR/OR', child_trees]]);
    return st;
  },
#endif

EF_Alt.prototype.setChildFrame = setChildFramePar;

EF_Alt.prototype.docollapse = function(branch, cf) {
  this.collapsed = true;
  var have_async_branch_retract = false;
  // abort all children apart from 'branch'
  this.quench(branch);
  for (var i=0; i<this.children.length; ++i) {
    if (i == branch) continue;
    if (this.children[i]) {
      var val = this.children[i].abort();
      if (is_ef(val)) { // need to wait
        have_async_branch_retract = true;
        this.setChildFrame(val, i);
      }
      else {
        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  }
  if (!have_async_branch_retract) {
    ASSERT(this.pending <= 1) // =0 for sync case, =1 for async case 
    return true;
  }
  // ... else we need to wait
  // this happens if there is an asynchronous retract or finally clause 
  // in one of the aborted branches 
  this.collapsing = { branch:branch, cf:cf};
  return false;
};

function I_alt(ndata, env) {
  return cont(new EF_Alt(ndata, env), -1);
}

//exports.Alt = makeINCtor(I_alt);
exports.Alt = function(...args) {
  return {
    exec: I_alt,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// WfW: stratified waitfor-while construct
/*
   ndata[0] = controlled branch / children[0]
   ndata[1] = controlling branch / children[1]

   continuation index:
   -1: start
*/

function EF_WfW(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(2);
}
setEFProto(EF_WfW.prototype={});
#ifdef EF_TYPES
EF_WfW.prototype.type = function() {return "WfW(aborted="+!!this.aborted+")"};
#endif

EF_WfW.prototype.cont = function(idx, val) {
//  console.log("wfw cont("+idx+","+val+",pending="+this.pending+")");
  if (is_ef(val)) {
    // child frame being replaced
    this.setChildFrame(val, idx);
  }
  else {
    if (idx === -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off children
      for (var i=0; i<2;++i) {
        val = execIN(this.ndata[i], this.env);
        if (this.inner_aborted) {
          if (is_ef(val)) {
            // reentrant abortion through suspend/resume
            // (sjs-3-tests:'waitfor/while:reentrant quench',
            //  sjs-3-tests:'reentrant edge case')
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
          if (i === 0) {
            SETDYNVARS(parent_dyn_vars, "WfW::cont[-1] // (2) -- verified")
          }
        }
        else if (is_cfx(val) || i===1) {
          // an exception in either branch or a 'normal' exit from the 
          // second branch aborts the WfW:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension (or called reentrantly from a branch that is continued by
      // another branch)
      --this.pending;

      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted) {
        // an exception aborts all other pending branches: 
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    
    if (this.pending === 1) {
      if (this.pendingCFE === undefined && this.children[1]) {
        // we can make a tailcall:
        SETDYNVARS(root_dyn_vars,'wfm tailcall')
        return this.returnToParent(this.children[1]);
      }
      else if (this.children[0]) {
        // we only have the controlled branch left; abort it:
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending === 0) {
      // XXX do we need the mergeExceptions call here?
      return this.returnToParent(mergeExceptions(val, this.pendingCFE));
    }
    this.async = true;
    return this;
  }
};

EF_WfW.prototype.quench = quenchPar;

EF_WfW.prototype.abort = function(pseudo_abort) {
//  console.log(this+'.abort');
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    SETDYNVARS(root_dyn_vars, "wfw::redundant abort")
    return this;
    //return this.pendingCFE;
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.pendingCFE = this.pendingCFE;
  this.aborted = true;
  return this.abortInner();
};

EF_WfW.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a 
  // branch excepts or when the 2nd branch returns)
  this.inner_aborted = true;
  // we always want to abort the second branch before the first
  if (this.children[1]) {
    var val = this.children[1].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      ASSERTDYNVARSROOT('wfw::abortInner')
      this.async = true;
      return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[1] = UNDEF;
    } 
  }
  if (this.children[0]) {
    var val = this.children[0].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      this.async = true;
      ASSERTDYNVARSROOT('wfw::abortInner:2')
      return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[0] = UNDEF;
    }
  }
  // assert this.pending === 0
  return this.pendingCFE;
};

EF_WfW.prototype.setChildFrame = setChildFramePar;

function I_wfw(ndata, env) {
  return cont(new EF_WfW(ndata, env), -1);
}
exports.WfW = function(...args) {
  return { exec: I_wfw,
           ndata: args,
           __oni_dis: token_dis };
};

//----------------------------------------------------------------------
// Suspend: stratified suspend operation


// structure of ndata array:
#define NDATA_SUSPEND_SUSPENDFUNC() ndata[0]
#define NDATA_SUSPEND_RETURNFUNC() ndata[1]

/*
  continuation index:
  0: start
  1: returning from execution of suspend function
  2: returning from execution of resume function
  3: returning from abortion of suspend function

  state variables:
  returning: resume function has been called or suspend threw
  suspendCompleted: suspend block has executed completely
  retvals: return values as passed into resume function
*/

function EF_Suspend(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Suspend.prototype={});
#ifdef EF_TYPES
EF_Suspend.prototype.type = "Suspend";
#endif

EF_Suspend.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    ASSERT(idx == 1 || idx == 3) //(others shouldn't rebase)
    this.setChildFrame(val, idx);
  }
  else {
    switch (idx) {
    case 0:
    try {
      var ef = this;
      this.dyn_vars = exports.current_dyn_vars;
  // XXX We could return something from resumefunc
  var resumefunc = function(...args) {
    if (ef.returning) {
      LOG("Redundant resume()")
      return;
    }
    try {
      var caller_dyn_vars = exports.current_dyn_vars;
      SETDYNVARS(ef.dyn_vars, "resume // (4)")
      cont(ef, 2, args);
    }
    catch(e) {
      hold0(function() { throw e; });
    }
    finally {
      ef.dyn_vars = undefined; // aid gc
      SETDYNVARS(caller_dyn_vars, "restore[resume] // (2)")
    }
  };

      // XXX If we want to enable the 'clearOrphanedBLR' functionality in the bridge
      // then we need to reflect the execution frame onto the resume function here:
      //resumefunc.ef = ef; 

      //      LOG("executing suspend")
      val = this.NDATA_SUSPEND_SUSPENDFUNC()(this.env, resumefunc);
    }
    catch (e) {
      // XXX is this required??
      val = new CFException("t", e);
    }
    //    LOG('done executing suspend')
    // At this point we might have received a reentrant callback
    // from the resume function!!
    if (this.returning) {
      //      LOG('reentrant cb')
      if (is_ef(val)) {
        ASSERT(!this.child_frame)
        // processing up to here has been synchronous; we still need to abort
        this.setChildFrame(val, /* not relevant */0);
        this.quench();
        val = val.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          // get parent to wait for us:
          this.async = true;
          return this;
        }
        // ... else fall through
      }
      return cont(this, 3, null);
    }
    
    if (is_ef(val)) {
      this.setChildFrame(val, 1);
      return this;
    }
    case 1:
    // returning from execution of suspend function
    if (is_cfx(val)) {
      this.returning = true;
      break;
    }
    this.suspendCompleted = true;
    // suspend:
    this.async = true;

    SETDYNVARS(root_dyn_vars, "suspend // (3) -- verified")
    return this;
    case 2:
    // returning from execution of resume function.        
    // Note that this might happen reentrantly, while we're still
    // processing the suspend block!!!
    if (this.returning) {
      // this is a trailing resume which we can safely ignore
      return;
    }
    this.returning = true;
    if (is_cfx(val)) {
      // sanity check
      // this shouldn't happen
      val = new CFException("i", "Suspend: Resume function threw ("+val.toString()+")");
      break;
    }
    this.retvals = val;
    if (!this.suspendCompleted) {
      // abort the suspend block:
      if (!this.child_frame) {
        // The suspend block is still executing synchronously.
        // This is a reentrant invocation of 'resume'.
        // We'll pick up with processing again when the suspend block is done
        this.returning = true;
        return;
      }
      else {
        this.quench();
        val = this.child_frame.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          return this;
        }
        // ... else fall through to case 3
        //        LOG('synchronous abortion')
          }
    }
    case 3:
    // set values with return function:
    try {
      this.NDATA_SUSPEND_RETURNFUNC().apply(this.env, this.retvals);
      val = UNDEF;
    }
    catch (e) {
      val = new CFException("i", "Suspend: Return function threw ("+e+")");
    }
    break;
    case 4:
      // return from external abort
      // fall through to returnToParent
      break;
    default:
    val = new CFException("i", "Invalid state in Suspend ("+idx+")");
    }
    return this.returnToParent(val);
  }
};

EF_Suspend.prototype.quench = function() {
  this.returning = true; // prevent resume() calls from having any effect
  if (!this.suspendCompleted)
    this.child_frame.quench();
};

EF_Suspend.prototype.abort = function(pseudo_abort) {
  //  LOG('SUSPEND abort (childf='+this.child_frame+')')
  SETDYNVARS(this.dyn_vars, "suspend::abort // (5) -- verified")
  this.returning = true;
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  if (!this.suspendCompleted) {
    var abort_val = this.child_frame.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      this.setChildFrame(abort_val, 4);
      return this; // need to stay in picture, because abort must not return child frame
    }
    else {
      return abort_val;
    }
  }
  return UNDEF;
};

function I_sus(ndata, env) {
  return cont(new EF_Suspend(ndata, env), 0);
}

//exports.Suspend = makeINCtor(I_sus);
exports.Suspend = function(...args/*s,r*/) {
  return {
    exec: I_sus,
    ndata: args, //[s,r],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// collapse

// structure of ndata array:
#define NDATA_COLLAPSE_LINE() ndata

// continuation index:
// 0: start
// 1: returning from async execution
  
function EF_Collapse(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Collapse.prototype={});
#ifdef EF_TYPES
EF_Collapse.prototype.type = "Collapse";
#endif

// mark us as a collapse frame
EF_Collapse.prototype.__oni_collapse = true;

EF_Collapse.prototype.cont = function(idx, val) {
//  console.log('collapse ' + this.env.fold + ".cont idx = "+idx+" val="+val);
  if (idx == 0) {
    var fold = this.env.fold;
    if (!fold)
      return new CFException("t", new Error("Unexpected collapse statement"),
                             this.NDATA_COLLAPSE_LINE(), this.env.file);
    this.restore_dynvars = exports.current_dyn_vars;
    if (fold.docollapse(this.env.branch, this)) {
      SETDYNVARS(this.restore_dynvars, 'collapse 1')
      return true;
    }
    // else ... we're going async
    this.async = true;
    ASSERTDYNVARSROOT('collapse')
    return this;
  }
  else if (idx == 1) { // returning from collapsing
    SETDYNVARS(this.restore_dynvars, 'collapse 2')
    return this.returnToParent(true);
  }
  else 
    return this.returnToParent(new CFException("t", "Internal error in SJS runtime (collapse)",
                                               this.NDATA_COLLAPSE_LINE(), this.env.file));
};

// don't need to do anything for quenching/aborting. we'll never be prodded by upstream after an abort.
EF_Collapse.prototype.quench = dummy;
EF_Collapse.prototype.abort = function() { 
  this.aborted = true; 
  SETDYNVARS(this.restore_dynvars, 'collapse 3')
  return UNDEF;
};

function I_collapse(ndata, env) {
  return cont(new EF_Collapse(ndata, env), 0);
}
  
//exports.Collapse = makeINCtor(I_collapse);
exports.Collapse = function(line) {
  return {
    exec: I_collapse,
    ndata: line,
    __oni_dis: token_dis
  }
};
  
//----------------------------------------------------------------------
// builtin strict functions

// setTimeout has a minimum delay of 4ms; we want hold(0) to be faster
// see e.g. https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
var hold0, clear0;
// Note: we cannot use process.nextTick, because hold(0) must not stall I/O. 
// It would e.g. break 'require-tests:non-circular reference waits for the full module'
// See also https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
if (exports.G.setImmediate) {
  hold0 = exports.G.setImmediate;
  clear0 = exports.G.clearImmediate;
}
/*
similarly to process.nextTick, this will stall I/O:
else if (false && exports.G.Promise) {
  hold0 = function(cb) { Promise.resolve().then(cb); }
  clear0 = function(id) { }
}
*/
else if (exports.G.postMessage && !exports.G.importScripts) {
  var postMessageIsAsync = true;
  var oldOnMessage = exports.G.onmessage;
  exports.G.onmessage = function() {
    postMessageIsAsync = false;
  };
  exports.G.postMessage("", "*");
  exports.G.onmessage = oldOnMessage;
  if (postMessageIsAsync) {
    // install an event handler on `global` for the `message` event;
    // draws heavily from https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
    var MESSAGE_PREFIX = "com.onilabs.hold0" + Math.random();

    var tasks = {};

    function onGlobalMessage(event) {
      if (event.source === exports.G && 
          typeof event.data === 'string' &&
          event.data.indexOf(MESSAGE_PREFIX) === 0) {
        var id = event.data.substring(MESSAGE_PREFIX.length);
        var f;
        if ((f = tasks[id])) {
          delete tasks[id];
          f();
        }
      }
    }

    if (exports.G.addEventListener) {
      exports.G.addEventListener("message", onGlobalMessage, false);
    }
    else {
      exports.G.attachEvent("onmessage", onGlobalMessage);
    }

    var id_counter = 1;

    var hold0 = function(f) {
      var id = id_counter++;
      tasks[id] = f;
      exports.G.postMessage(MESSAGE_PREFIX + id, "*");
      return id;
    };
    
    var clear0 = function(id) {
      delete tasks[id];
    };
  }
}

if (!hold0) {
  hold0 = function(co) { return setTimeout(co, 0) };
  clear0 = clearTimeout;
}

exports.Hold = function(duration_ms) {
  var dyn_vars = exports.current_dyn_vars;
  // reset current_dyn_vars to root dyn vars - see note at definition of current_dyn_vars for rationale:
  SETDYNVARS(root_dyn_vars, "hold("+(duration_ms===UNDEF?"":duration_ms)+") // (3) -- verified")

  function abort() {
    //console.log('HOLD ABORT sus.parent='+(sus ? sus.parent:'undef'));
    // restore dyn vars for finally clauses
    SETDYNVARS(dyn_vars, "hold("+(duration_ms===UNDEF?"":duration_ms)+")::abort // (5)")
    return UNDEF;
  }
  
  if (duration_ms === UNDEF)
    return { 
#ifdef EF_TYPES
             toString: function() { return "<HOLD()>"; },
#endif
             __oni_ef: ONI_EF,
             wait: function() { 
               SETDYNVARS(root_dyn_vars, '<HOLD()>:wait')
               return this; 
             },
#ifdef DEBUG_VM
             gatherSuspensionTree: function() { return [this.toString()] },
#endif
             quench: dummy,
             abort: abort
           };

  if (duration_ms === 0) {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD(0)>"; },
#endif
                __oni_ef: ONI_EF, 
                wait: function() { 
                  SETDYNVARS(root_dyn_vars, sus+':wait')
                  return this;
                },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
                quench: function() { sus = null; clear0(this.co); },
                co: hold0(function() {
                  if (sus && sus.parent) {
                    ASSERTDYNVARSROOT('hold0')
                    SETDYNVARS(dyn_vars, "hold(0) resume // (4)")
                    cont(sus.parent, sus.parent_idx, UNDEF);
                    // this doesn't always hold when we call SJS through JS and let the 
                    // continuation go nowhere:
                    //ASSERTDYNVARSROOT('hold(0):2')
                    SETDYNVARS(root_dyn_vars, "hold(0) reset")
                  }
                })
              };
    return sus;
  }
  else {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD("+duration_ms+"ms)>"; },
#endif
                __oni_ef: ONI_EF,
                wait: function() { 
                  SETDYNVARS(root_dyn_vars, sus+':wait')
                  return this; 
                },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
#if defined (CLIENTSIDE) || defined (NODEJS)
                quench: function() { sus = null; clearTimeout(this.co); }
#else
                quench: function() { sus = null; this.co.cancel(); }
#endif
              };
    sus.co = setTimeout(
      function() {
        if (sus && sus.parent) {
          ASSERTDYNVARSROOT('hold('+duration_ms+")")
          SETDYNVARS(dyn_vars, "hold("+duration_ms+") resume")
 var PPP = sus.parent;
          cont(sus.parent, sus.parent_idx, UNDEF);
          if (exports.current_dyn_vars !== root_dyn_vars) {
            console.log("------ INCORRECT DYNVARS AFTER ASYNC CONT ----");
            console.log('parent:'+PPP);
            dumpExecutionFrameParents(PPP, 10);
          }
          // this doesn't always hold when we call SJS through JS and let the 
          // continuation go nowhere:
          //ASSERTDYNVARSROOT('hold:2('+duration_ms+')')
          SETDYNVARS(root_dyn_vars, 'hold:reset('+duration_ms+')')
        }
      },
      duration_ms);

    return sus;
  }
};

exports.Throw = function(exp, line, file) { return new CFException("t", exp, line, file); };

exports.Arr = function(...args) { return args };

exports.ArrS = function(spreads, ...args) {
  var rv = [];
  for (var i=0; i<args.length; ++i) {
    if (spreads[0] === i) {
      rv = rv.concat(args[i]);
      spreads.shift();
    }
    else
      rv.push(args[i]);
  }
  return rv;
};

exports.Obj = function(...args) {
  // note comment in kernel-sjs.js.in::ph_obj_lit about the way props
  // are encoded into arguments object
  var obj = new Object();
  for (var i=0; i<args[0].length; ++i)
    obj[args[0][i]] = args[i+1];
  return obj;
};

function QuasiProto(parts) {this.parts=parts;}
exports.QuasiProto = QuasiProto;

exports.Quasi = function(...args) {
  return new QuasiProto(args);
};

exports.Return = function(exp) {
  return new CFException("r", exp);
};

exports.Break = function(lbl) {
  return new CFException("b", lbl);
};

exports.Cont = function(lbl) {
  return new CFException("c", lbl);
};

// XXX remove
exports.BlReturn = function(exp) {
  var e = new CFException('r', exp);
  if (!this.blrref) throw new Error("Internal runtime error; no reference frame in BlReturn");
  if (this.blrref.unreturnable) { 
    if (this.blrref.toplevel)
      throw new Error("Invalid blocklambda 'return' statement; 'return' is only allowed in blocklambdas that are nested in functions");
    else {
      // return scope not active anymore!
      throw new Error("Blocklambda return to inactive function");
    }
  }
  e.eid = this.blrref.sid;
  return e;
};

exports.With = function(exp, bodyf) {
  return bodyf(this, exp);
};

exports.join_str = function(...args) {
  var rv = '';
  for (var i=0,l=args.length;i<l;++i)
    rv += args[i];
  return rv;
};

exports.infix = {
  '+':   function(a,b) { return a+b; },
  '-':   function(a,b) { return a-b; },
  '*':   function(a,b) { return a*b; },
  '/':   function(a,b) { return a/b; },
  '%':   function(a,b) { return a%b; },
  '<<':  function(a,b) { return a<<b; },
  '>>':  function(a,b) { return a>>b; },
  '>>>': function(a,b) { return a>>>b; },
  '<':   function(a,b) { return a<b; },
  '>':   function(a,b) { return a>b; },
  '<=':  function(a,b) { return a<=b; },
  '>=':  function(a,b) { return a>=b; },
  '==':  function(a,b) { return a==b; },
  '!=':  function(a,b) { return a!=b; },
  '===': function(a,b) { return a===b; },
  '!==': function(a,b) { return a!==b; },
  '&':   function(a,b) { return a&b; },
  '^':   function(a,b) { return a^b; },
  '|':   function(a,b) { return a|b; },
  ',':   function(a,b) { return a,b; },
  'instanceof':
         function(a,b) { return a instanceof b; },
  'in':  function(a,b) { return a in b; }
};

#if defined (CLIENTSIDE)
//----------------------------------------------------------------------
// UA sniffing
var UA = navigator.userAgent.toLowerCase();
if (UA.indexOf(" chrome/") >= 0)
  UA = "chrome";
 else if (UA.indexOf(" firefox/") >= 0)
   UA = "firefox";
 else if (UA.indexOf(" safari/") >= 0)
   UA = "safari";
 else if (UA.indexOf(" msie ") >= 0)
   UA = "msie";
 else
   UA = "unknown";
exports.hostenv = "xbrowser";
#elif defined (NODEJS)
var UA = "nodejs";
exports.hostenv = "nodejs";
#endif
exports.UA = UA;

