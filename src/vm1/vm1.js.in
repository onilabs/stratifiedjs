/*
 * VM1 Stratified JavaScript Virtual Machine
 *
 * Part of StratifiedJS
 * http://onilabs.com/stratifiedjs
 *
 * (c) 2011-2013 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/*
Preprocessor flags:

define CLIENTSIDE    : for browser-based VM (as opposed to rocket-hosted)
define NODEJS        : for nodejs VM (as opposed to rocket/clientside)

define DEBUG_VM      : VM debugging

define HOTPATH       : don't build execution frames unless we have to

OBSOLETE FLAGS:
    verbose exceptions are always on now; not predicated on this flag anymore:
define VERBOSE_EXCEPTIONS : add line/file/stack members to exceptions
                             (requires compiling c1 with VERBOSE_EXCEPTIONS to
                              get correct values)
                             XXX We should actually only amend Error objects
                             where they are *created*. This code is possibly a
                             bit flaky with exceptions that are thrown by
                             JS code and caught/rethrown by SJS.


    we really don't want async resume:
define ASYNC_RESUME  : obsolete asynchronous resume code path

*/
//#define DEBUG_VM 1
#ifdef DEBUG_VM
function dumpExecutionFrameParents(ef, indent) {
  indent = indent || 0;
  if (ef && ef.parent)
    dumpExecutionFrameParents(ef.parent, indent+1);
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<undefined>';
  console.log(str);
}
function dumpExecutionFrameChildren(ef, indent) {
  indent = indent || 0;
  var str = '';
  for (var i=0; i<indent;++i) str += '  ';
  str += ef ? ef : '<undefined>';
  console.log(str);
  if (ef && ef.child_frame)
    dumpExecutionFrameChildren(ef.child_frame, indent+1);
  else if (ef && ef.children) {
    for (var i = 0; i<ef.children.length; ++i) {
      dumpExecutionFrameChildren(ef.children[i], indent+1);
    }
  }
}
#define EF_TYPES
#define LOG(x) console.log(x);
// XXX figure out why normal CPP stringification is screwed
#define ASSERT(X) if(!(X)) { console.log("Assertion failed: " + "X" ); throw new Error("Assertion failed: " + "X")}
#define WHENDEBUG(X) X
#else
#define ASSERT(X)
#define LOG(x)
#define WHENDEBUG(X)
#endif

// we don't want to rely on the global 'undefined' symbol; see
// https://groups.google.com/d/msg/oni-apollo/fNMz2W8S5mU/sYCgrriYj1MJ
var UNDEF; // == undefined

// on firefox this seems to help, on v8 it doesn't :-/
//define HOTPATH 1

// maximum size of callstack that we'll record in tail-recursive scenarios:
#define MAX_CALLSTACK 20

//----------------------------------------------------------------------

#if defined (CLIENTSIDE)
exports.G = window;
#elif defined (NODEJS)
exports.G = global;
#endif


//----------------------------------------------------------------------
// Control Flow Exceptions

/*
{
  __oni_cfx: true,
  type:      "i"(internal)|"r"(return)|"b"(break)|"c"(continue)|"t"(thrown),
  val:       value
}
*/

// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_cfx(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_cfx)
// define is_cfx(obj) (obj instanceof CFException)
/*function is_cfx(obj) {
  return obj && obj.__oni_cfx;
}*/

function stack_to_string(stack) {
  var rv = '';
  if (stack) {
    for (var i=0; i<stack.length; ++i) {
      var line = stack[i];
      if (line.length == 1)
        line = line[0];
      else
        line = '    at ' + line.slice(0,2).join(':');
      rv += '\n' + line;
    }
  }
  return rv;
}

function CFException_toString() {
  return this.name+": "+this.message + stack_to_string(this.__oni_stack);
}

function adopt_native_stack(e, caller_module) {
  if(!e.stack)
    return;
  var stack = String(e.stack);
  // Remove default toString() output, which can take form:
  // - <msg>
  // - <type>
  // - <type>: <msg>
  var firstColon = stack.indexOf(': ');
  var msgStart = (firstColon === -1) ? 0 : firstColon + 2;
  
  // if firstColon appears after a newline, it's not the one we want
  if (stack.lastIndexOf('\n', msgStart) !== -1) msgStart = 0;

  var msg = String(e.message);
  if (msg && stack.lastIndexOf(msg, msgStart) == msgStart) {
    stack = stack.slice(msgStart + msg.length);
  } else {
    // remove sole <type>, assuming type ends with 'Error'
    stack = stack.replace(/^\w*Error/, '');
  }
  delete e.stack;
  var lines = stack.split("\n");
  var i;
  for (i=0; i<lines.length; i++) {
    var line = lines[i];
    if (!line.length) continue;
    // TODO: make this check more reliable
    if((caller_module && line.indexOf(caller_module) !== -1) ||
       line.indexOf(".app!bundle") !== -1 ||
       line.indexOf("stratified-node.js") !== -1 ||
       line.indexOf("stratified.js") !== -1 ) {
      // we've hit an sjs stack line.
      break;
    }
    e.__oni_stack.push([line]);
  }
}

var token_oniE = {}; // oni-modified exception
function CFException(type, value, line, file) {
  this.type = type;
  this.val = value;
  // XXX checking for "value instanceof Error" alone doesn't work for some errors on firefox
  if (type === "t" && 
      (value instanceof Error || (typeof value === 'object' && value != null && value.message))) {
    if (value._oniE !== token_oniE) {
      // annotate the exception object with our oni-special fields:
      value._oniE = token_oniE;
      value.__oni_stack = value.__oni_stack || [];
      value.line = line;
      value.file = file || "unknown SJS source";

      adopt_native_stack(value, file);

      if (!value.hasOwnProperty('toString')) value.toString = CFException_toString;
    }

    // push current line/file onto stack (if provided):
    if (line)
      value.__oni_stack.push([file || 'unknown SJS source', line]);
  }
  // this.eid = UNDEF;  // 'execution frame' tag for targetted return/break/continue
}

var CFETypes = { r:"return", b:"break", c:"continue", blb: "blocklambda break"};
CFException.prototype = {
  __oni_cfx : true,
  toString : function() {
    if (this.type in CFETypes)
      return "Unexpected "+CFETypes[this.type]+" statement";
    else
      return "Uncaught internal SJS control flow exception ("+this.type+":: "+this.val+")";
  },
  mapToJS : function(uncaught) {
    if (this.type == "t") {
#if defined (CLIENTSIDE)
      // 'uncaught' means we know this exception won't be caught by SJS.
      // We could throw a plain JS error, but browsers have terrible reporting.
      // Instead, we emulate a good browser's onError handling, with full stack
      // logging on an unhandled error.
      // See https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror
      // XXX is there anything browsers do internally to handle errors other than calling onerror?
      if (uncaught && this.val != null && this.val.__oni_stack) {
        var handler = window.onerror;
        var handled = false;
        var msg = this.val.toString();

        if (handler) {
          // we could probably extract a proper url & lineno here,
          // but who cares when we have the entire stacktrace?
          handled = handler.call(window,
              msg,
              "", // url
              0,  // lineno
              0,  // column
              this.val); // exception
        }
        if (!handled) {
          if (console) {
            if (console.error) console.error(msg);
            else console.log(msg);
          }
        }
      }
      else
#endif // CLIENTSIDE
        throw this.val;
    }
    else if (!this.eid) // XXX DO WE NEED THIS???
      throw new Error(this.toString());
    else // this is a 'blb' or 'r' tunneling through a JS functions:
      throw this;
  }
};


// In certain cases where an exception might be picked up several times via different routes (as in
// stratum.value(), we need to make sure that we don't get crosstalk between differently 
// amended stacks.
// For this purpose, we clone exceptions in these cases.
// XXX Note that this will break certain *very unlikely* pathological programming patterns that check 
// an exception for strict equality. Checking for `instanceof` (as would be more common) will still 
// work, and this only affects exceptions that inherit from `Error` (as these are the only ones we 
// annotate in the first place).
// 
#define is_annotated_oni_cfx(obj) (is_cfx(obj) && obj.type === 't' && obj.val != null && obj.val._oniE === token_oniE)

function cloneAnnotatedCFX(obj) { 
  // ASSERT(is_annotated_oni_cfx(obj)) // caller to ensure this
  obj = new CFException('t', Object.create(obj.val));
  obj.val.toString = CFException_toString;
  // The following are necessary to fix cloned JS errors being reported as 'illegal invocation':
  // XXX alternatively we could use an amended CFException_toString, but it's tricky to get
  // that to work with exceptions that are cloned multiple levels deep (if there are such exceptions?)
  Object.defineProperty(obj.val, 'name', { get: function() { return this.__proto__.name; } });
  Object.defineProperty(obj.val, 'message', { get: function() { return this.__proto__.message; }});

  // make sure that the new exceptions gets its own __oni_stack property:
  obj.val.__oni_stack = [].concat(obj.val.__oni_stack);
  return obj;
}


//----------------------------------------------------------------------
// Dynamic variable support:

// current_dyn_vars is a global variable holding dynamic variable
// bindings for the currently stratum. It will be manipulated by the
// VM when a stratum switch takes place:
// We cannot use 'Env' for this, because environments get reset at every function
// boundary (to support SJS being callable from JS)
exports.current_dyn_vars = null; 

//----------------------------------------------------------------------
// Execution Frames

/*
  Note on `ReturnToParentContinuation` & global `cont` function

  In SJS, we can (asynchronously) build large execution frame trees in
  a tail-safe way. To ensure that we we can also unravel these trees
  without blowing the JS stack (by a long chain of
  cont-returnToParent-cont-returnToParent-... calls), we need to code
  calls that tear down a tree in continuation passing style.

  Grep the code for ReturnToParentContinuation for more notes.

*/
#define is_returnToParent(obj) (obj && obj.__oni_rtpc)
function ReturnToParentContinuation(frame, idx, val) {
  this.frame = frame;
  this.idx = idx;
  this.val = val;
}
ReturnToParentContinuation.prototype = {
  __oni_rtpc: true,
  execute: function() { return this.frame.cont(this.idx, this.val) }
};

/*
  Execution frames' `cont` methods should never be called directly,
  but always be through this global function. It takes care of
  executing any `ReturnToParentContinuation`s that the callee might
  return.
*/
function cont(frame, idx, val) {
  var rv = frame.cont(idx, val);
  while (is_returnToParent(rv)) {
    rv = rv.execute();
  }
  return rv;
}

exports.is_ef = function(obj) {
  return obj && obj.__oni_ef;
}
// The type checking here is to prevent V8 deoptimization when obj is a Smi
#define is_ef(obj) (obj !== null && typeof(obj) === 'object' && obj.__oni_ef===true)

function setEFProto(t) { for (var p in EF_Proto) t[p] = EF_Proto[p]; }
//function setEFProto(t) { t.__proto__ = EF_Proto; }


// helper to merge callstacks of two execution frames:
function mergeCallstacks(target_ef, src_ef) {
  // prevent duplication of the callstack if the frames are the same:
  if (target_ef === src_ef) return;
  if (target_ef.callstack) {
    // stack-tests 17
    
    // concat stacks; potentially dropping frames in the middle if
    // we go above MAX_CALLSTACK:
    target_ef.callstack = target_ef.callstack.concat(src_ef.callstack);
    if (target_ef.callstack.length > MAX_CALLSTACK)
      target_ef.callstack.splice(MAX_CALLSTACK/2, 
                                 target_ef.callstack.length-MAX_CALLSTACK+1, 
                                 ['    ...(frames omitted)']);
  }
  else {
    // stack-tests 16
    target_ef.callstack = src_ef.callstack;
  }
}

// base prototype object for execution frames
var EF_Proto = {
#ifdef EF_TYPES
  toString: function() { var rv = "<"+(typeof(this.type) === 'function' ? this.type() : this.type)+""+(this.id ? this.id:'')+'@'+((this.env && this.env.file) ? this.env.file.substr(-20): 'unknown')+">";
                         if (this.callstack)
                           rv += '[' + this.callstack.join(' > ') + ']';
                         return rv;
 },
#else
  toString: function() { return "<suspended SJS>"; },
#endif
  __oni_ef : true,

  wait: function() { return this; },

#ifdef DEBUG_VM
  gatherSuspensionTree: function() {
    try {
    return (this.callstack||[]).concat(this.child_frame ? this.child_frame.gatherSuspensionTree() : []);
    }
    catch (e) {
      console.log("ERROR GATHERING SUSPENSION TREE FOR "+this.child_frame);
      throw e;
    }
  },
#endif

  setChildFrame: function(ef, idx, prevent_callstack_copy) {
    if (this.child_frame) {
      if (prevent_callstack_copy !== true && this.child_frame.callstack) {
        // merge callstacks of old & new childframes:
        mergeCallstacks(ef, this.child_frame);
      }
      this.child_frame.parent = UNDEF;
    }
    this.async = true;
    this.child_frame = ef;
    ef.parent = this;
    ef.parent_idx = idx;
  },

  // quench reentrant resume calls.
  // This signal is issued before abort() calls, to prevent any resume() calls in our
  // call tree from firing, in case they are reentrantly executed by finally-code 
  // in our call tree. See also the tertiary waitfor/and/or sjs-testsuite testcases
  // 153-156.
  quench: function() {
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'abort'
    if (this.child_frame) 
      this.child_frame.quench();
  },

  // abort must either return 'this' (if we need to wait), or a controlflow exception
  abort: function(pseudo_abort) {
    ASSERT(!this.aborted);
    this.aborted = true;
    this.pseudo_abort = pseudo_abort;
    // see sjs-2-test 'reentrant quench/abort' for why we need to
    // check for 'this.child_frame' here and in 'quench'
    if (!this.child_frame) {
      // reentrant abortion
      return this;
    }
    else {
      var abort_val = this.child_frame.abort(pseudo_abort);
      if (is_ef(abort_val)) {
        return this; // need to stay in picture because abort must not return child frame
      }
      else {
        ASSERT(is_cfx(abort_val));

        if (is_annotated_oni_cfx(abort_val) && this.callstack) {
          abort_val.val.__oni_stack = abort_val.val.__oni_stack.concat(this.callstack);
        }

        // this fixes sjs-3-tests.sjs:'return via inactive scope edgecase':
        this.unreturnable = true;
        return abort_val;
      }
    }
  },

  returnToParent: function(val) {
#ifdef DEBUG_VM_X
    // We currently call returnToParent prematurely under various reentrancy scenarios in
    // Alt, Par, and Spawn.
    // XXX This is wrong and extremely fragile and needs a rewrite at some point.
    if (this.__rtp_called) {
      console.log(this + ": redundant call to returnToParent("+val+")");
    }
    else {
      this.__rtp_called = true;
    }
#endif

    // this check is incomplete: try/alt/par that are internally aborted don't have their 'aborted'
    // flag set, yet they *do* accept 'a's
    //    if (this.parent && this.aborted && !this.parent.aborted && is_cfx(val) && val.type === 'a') {
    //      console.log(this+ " RETURNING 'a' to frame that doesn't expect one: "+this.parent);
    //    }

    if(is_cfx(val) && val.type == 't' && this.callstack && val.val!=null && val.val.__oni_stack) {
      val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
    }
    if (this.swallow_r) {
      if (is_cfx(val)) {
        if (val.type === "r") {
          if (!val.eid || val.eid === this.sid) {
            val = val.val;
            if (this.swallow_r === 3) {
              // we've received a tail-called 'return' that shouldn't
              // be returned via the present function. see also notes below
              val = UNDEF;
            }
          }
        }
      }
      else if (is_ef(val)) {
        // we're tailcalling the ef 'val' through ef 'this'. I.e. ef
        // 'this' is dropping out of the picture.

        // We have to ensure that ef 'val' gets a 'swallow_r' policy consistent with that of ef 'this'.
        // In particular, we want 'val' to have the same 'swallow_r' as 'this', with the exception where
        // 'this' is a tail-called function (this.tailcall === true) that is set to return proper 
        // returns only (this.swallow_r === 1) and val is *also* already set up to swallow returns (i.e. it is/was a functional context too). In this case we want to convert any 'returns' emitted
        // by ef 'val' to undef (i.e. set val.swallow_r to 3).
        // The swallow_r special casing fixes sjs-2-tests.sjs:async return propagation and
        // sjs-2-tests.sjs:return propagation from suspended blocklambda

        if (this.swallow_r === 1 && val.swallow_r && this.tailcall) {
          val.swallow_r = 3;
        }
        else {
          val.swallow_r = this.swallow_r; // just pass down flag to child
        }
      }
      else if (this.swallow_r !== 2) {
        val = UNDEF; // only 'return' returns a value to parent
      }
    }
  
    // Mark this frame as unreturnable. This is used by
    // blocklambdas to determine if the lexical function container is
    // still alive.
    this.unreturnable = true;

    // a little cleanup which might aid GC:
    // XXX this breaks function-tests.sjs:exclusive
    // this.env = UNDEF;

    if (this.async) {
      if (this.parent) {
        // we would like to call 
        //   this.parent.cont(this.parent_idx, val) 
        // here, but this might blow the JS stack.
        // We encode in continuation-passing style instead; the topmost `cont`
        // parent of this code path knows how to handle 
        // ReturnToParentContinuation
        return new ReturnToParentContinuation(this.parent, this.parent_idx, val);

        // remove parent to aid gc; we can only do this if val != this
        // (par and alt call through returnToParent via abortInner, which in the 
        // async case returns their own EF)
        // XXX empirically this doesn't seem to help much 
        // if (val !== this) this.parent = UNDEF;
      }
      else // noone waiting for result; make sure exceptions get reported
        if (is_cfx(val) && val.type !== 'a') {
          //console.log("UNREPORTED EXCEPTION IN "+this+":"+val.type+" eid="+val.eid);
          val.mapToJS(true);
        }
    }
    else // sync context
      return val;
  }

};
//EF_Proto.__proto__ = null;

//----------------------------------------------------------------------
// Instruction nodes

// Token which identifies an object as an instruction node
// dispatcher (obj.__oni_dis == token_dis)
var token_dis = {};

// execute an instruction node without mapping exceptions:
function execIN(node, env) {
  if (!node || node.__oni_dis != token_dis) {
    return node; // a literal value
  }
  return node.exec(node.ndata, env);
}
exports.ex = execIN;

// function bodies: create a seq and exec it. map exceptions.
// short for __oni_rt.exec(__oni_rt.Seq(...), aobj, thisobj, file)
// aobj: effective `arguments`
// tobj: effective `this`
exports.exseq = function(aobj,tobj,file, args) {
  var rv = I_seq(args, new Env(aobj,tobj,file));
//  var rv = (new EF_Seq(args, new Env(aobj,tobj,file))).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS(); // throw exceptions, so that we can call this from normal js
  return rv;
};

// block lambda bodies: create a seq and exec it. XXX don't map exceptions?
// short for __oni_rt.exec(__oni_rt.Seq(...), env)
exports.exbl = function(env, args) {
  var rv = I_seq(args, env);
//  var rv = (new EF_Seq(args, env)).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS();
  return rv;
};

var StratumAborted = exports.StratumAborted = function() {}
StratumAborted.prototype = new Error("stratum aborted");


//   exec: instruction executor function
//   returns IN constructor function which returns a instruction object
// For some reason instruction objects created directly without makeINCtor execute slightly faster on chrome and ff 
// -> removing use of makeINCtor
//
//function makeINCtor(exec) {
//  return function(/* ndata */) {
//    return {
//      exec: exec,
//      ndata: arguments,
//      __oni_dis: token_dis
//    };
//  }
//}


//----------------------------------------------------------------------
// Execution environment
/*

  {
    aobj: 'arguments' object,
    tobj: 'this' object,
    file: filename,
    blbref: function execution frame that blocklambda breaks should
            target in current environment 
    blrref: function execution frame that blocklambda returns should
            target in current environment 
    blscope: like blbref, but will be cleared at function boundaries. This is
             to identify the topmost execution frame that a blocklambda break 
             should return to
  }

*/

function Env(aobj, tobj, file, blbref, blrref, blscope, fold, branch) { 
  this.aobj = aobj; // 'arguments' object
  this.tobj = tobj; // 'this' object
  this.file = file; // filename
  this.blbref = blbref;
  this.blrref = blrref;
  this.blscope = blscope;
  this.fold = fold; // place where 'alt' forks
  this.branch = branch; // id of fork branch. XXX should be merged with 'fold'
}

function copyEnv(e) {
  return new Env(e.aobj, e.tobj, e.file, e.blbref, e.blrref, e.blscope, e.fold, e.branch);  
}

//----------------------------------------------------------------------
// C : instruction node for function calls with non-blocking args
// Calls the given function with 'this' set to current environment 

// structure of ndata array:
#define NDATA_CALL_JSFUNC() ndata[0]
#define NDATA_CALL_LINENO() ndata[1]
function I_call(ndata, env) {
  try {
    var rv = (NDATA_CALL_JSFUNC()).call(env);
    if (is_ef(rv)) {
      // collect callstack on the execution frame:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([env.file, NDATA_CALL_LINENO()]);
    }
    return rv;
  }
  catch (e) {
    if (is_cfx(e)) {
      if (e.type == 'blb' && env.blscope && e.eid == env.blscope.sid) {
        // XXX This is only reached when an fcall is encoded as
        // nblock, which currently only happens if the blocklambda is
        // called via a variable, see sjs-testsuite2:26
        return UNDEF;
      }
    } else {
      e = new CFException("t", e, NDATA_CALL_LINENO(), env.file);
    }
    return e;
  }
}
//exports.C = makeINCtor(I_call);
exports.C = function(...args/*f, line*/) {
  return {
    exec: I_call,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Nb : instruction node for non-blocking, argument-less javascript code 
// Calls the given function with 'this' set to current environment.

// structure of ndata array:
#define NDATA_NBLOCK_JSFUNC() ndata[0]
#define NDATA_NBLOCK_LINENO() ndata[1]
function I_nblock(ndata, env) {
  try {
    return (NDATA_NBLOCK_JSFUNC()).call(env);
  }
  catch (e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_NBLOCK_LINENO(), env.file);
    }
    return e;
  }
}
//exports.Nb = makeINCtor(I_nblock);
exports.Nb = function(...args/*f, line*/) {
  return {
    exec: I_nblock,
    ndata: args, //[f, line],
    __oni_dis: token_dis
  };
};


//----------------------------------------------------------------------
// Bl : instruction node for block lambdas

// structure of ndata array:
#define NDATA_BLOCKLAMBDA_JSFUNC() ndata
function I_blocklambda(ndata, env) {
  return NDATA_BLOCKLAMBDA_JSFUNC().bind(env);
}
//exports.Bl = makeINCtor(I_blocklambda);
exports.Bl = function(f) {
  return {
    exec: I_blocklambda,
    ndata: f,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Seq : instruction node for sequential execution of child nodes

// ndata[0] contains flags.
#define NDATA_SEQ_FLAGS() ndata[0]
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE SEQ_FLAG_'s in kernel-sjs.js.in
#define NDATA_SEQ_FLAG_NONE 0
#define NDATA_SEQ_FLAG_FUNCTION 1
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_OR 2
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_AND 4
#define NDATA_SEQ_FLAG_NOTAILCALL 8
#define NDATA_SEQ_FLAG_UNRETURNABLE 16
#define NDATA_SEQ_FLAG_IMPLICIT_RETURN 32 
#define NDATA_SEQ_FLAG_BLOCKLAMBDA 64
// ndata[1..end] contains sequence of instruction nodes

/*
  continuation index:
  1      : start
  2..end : returning from ndata[n-1] (last one tail-called)  
 */

var seq_counter = 0;

function EF_Seq(ndata, env) {
  // 'sid' is an id used in blocklambda break and return references
  this.sid = ++seq_counter;
#ifdef DEBUG_VM
  this.id = this.sid; 
#endif
  this.ndata = ndata;
  this.env = env;

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) {
    if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_BLOCKLAMBDA) {
      this.env = copyEnv(env);
      this.env.blbref = env.blscope; // `break` in our scope targets our parent's scope
      this.env.blrref = env.blrref;
      this.env.blscope = this; // we're a scope for any `break`s in nested blocklambdas
    }
    else {
      // XXX no need to copy env here?
      env.blbref = this; // note down function execution frame in environment
      env.blrref = this;
      env.blscope = this;
    }
  }
  else if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
    this.env = copyEnv(env);
    if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_BLOCKLAMBDA)
      this.env.blbref = env.blscope; // `break` in our scope targets our parent's scope

    // we're a function (blocklambda or normal) but NOT a scope 
    // for any `break`s in child frames (otherwise the compiler would
    // have marked us 'notailcall'). clear blscope so that targeted `break` calls will
    // find their way to the correct scope:
    this.env.blscope = null;
  }

  this.tailcall = !(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == 0    : returns tunnel through us
  // swallow_r == 1    : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  // swallow_r == 3    : 'catch' a tailcalled Return(exp) that should not be returned (i.e. convert to undefined)
  this.swallow_r = (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION == NDATA_SEQ_FLAG_FUNCTION) ? 1 : 0;
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

  // is this a top-level seq (one that can't be return'ed to?)
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE) {
    this.unreturnable = true;
    // mark it as toplevel, for correct error messages and to allow
    // blocklambda breaks to target this frame:
    this.toplevel = true; 
  }
}
setEFProto(EF_Seq.prototype={});
#ifdef EF_TYPES
EF_Seq.prototype.type = function() { 
  var rv = "Seq";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION)
    rv += "(fun)";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_BLOCKLAMBDA)
    rv += "(blkL)";
  if (this.NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    rv += "(notail)";

  return rv;
};
#endif
EF_Seq.prototype.cont = function(idx, val) {
#ifdef DEBUG_VM_XX
  var getType = function(val) {
    var sub = val && val.type;
    return "Seq/" + (sub || "??");
  };
  LOG("EF_Seq.prototype.cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "]) @ " + this.env.file);
#endif
//  console.log(this+"cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "])");

  if (is_ef(val)) {
    // child frame being replaced:
    this.setChildFrame(val, idx);
  }
  else {
    if (is_cfx(val)) {
      // block lambda break
      if (val.type == 'blb' && this.env.blscope && val.eid == this.env.blscope.sid) {
        val = UNDEF;
      }
      else {
        // pass through other exceptions:
        return this.returnToParent(val);
      }
    }
    while (idx<this.ndata.length) {
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      if (this.child_frame) {
        this.child_frame.parent = UNDEF;
        this.child_frame = UNDEF; // ensures correct reentrant aborting
      }
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          if (!is_ef(val))
            return this.returnToParent(val);
        }
      }
      if (++idx == this.ndata.length && this.tailcall) {
        // tail call optimization: 
        break;
      }
      if (is_cfx(val)) {
        // handle reentrant blocklambda breaks
        // (see sjs2-tests:reentrant blocklambda resume/break)
        if (val.type === 'blb' && this.env.blscope && val.eid === this.env.blscope.sid)
          val = undefined;
        break;
      }
      else if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
    return this.returnToParent(val);
  }
};

#ifdef HOTPATH
function I_seq(ndata, env) {
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    return cont(new EF_Seq(ndata, env), 1);

  var sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 
  var idx = 1;
  var val;
  var l = ndata.length;
  while (idx<l) {
    val = execIN(ndata[idx++], env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

    if (is_cfx(val)) break;
    if (is_ef(val)) {
      // need to create an execution frame for ourselves... 
      var ef = new EF_Seq(ndata, env);
      ef.setChildFrame(val, idx);
      return ef;
    }
    if (sc) {
      if (sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
        if (val) break; // returns val
      }
      else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
        if (!val) break; // returns val
      }
    }
  }

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
    if (is_cfx(val)) {
      if (val.type == "r") { 
        if (!val.eid)
          val = val.val;
      }
    }
    else
      val = UNDEF;
  }
  return val;
}
#else /* !HOTPATH */
function I_seq(ndata, env) {
  return cont(new EF_Seq(ndata, env), 1);
}
#endif /* HOTPATH */
//exports.Seq = makeINCtor(I_seq);
exports.Seq = function(...args) {
  return {
    exec: I_seq,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Sc : simple strict function call
//
// executes env.SC_L(arg1, arg2, ...) where arg1..n are strictly
// evaluated instruction nodes


// structure of ndata array:
#define NDATA_SC_LINE() ndata[0]
#define NDATA_SC_L() ndata[1]
#define NDATA_SC_ARGS_OFFSET 2
// ndata[NDATA_SC_ARGS_OFFSET..end] : sc args

/*
  continuation index:
   0 : start
   1 : returning from args evaluation
*/

function EF_Sc(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_SC_ARGS_OFFSET;
  this.pars = [];
}
setEFProto(EF_Sc.prototype={});
#ifdef EF_TYPES
EF_Sc.prototype.type = "Sc";
EF_Sc.prototype.toString = function() {
  return "<Sc@"+this.env.file.substr(-20)+':'+this.ndata[0]+'>';
};
#endif

EF_Sc.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val)) {
    return this.returnToParent(val);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 20
    }
    if (idx == 1) {
      // handle a result that has been passed in
      this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1);
        return this;
      }
      this.pars.push(rv);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the pars, let's do the call:
    try {
        rv = this.NDATA_SC_L().apply(this.env, this.pars);
    }
    catch (e) {
      rv = new CFException("t", e,
                           this.NDATA_SC_LINE(),
                           this.env.file);
    }
    return this.returnToParent(rv);
  }
};

function I_sc(ndata, env) {
  return cont(new EF_Sc(ndata, env), 0);
}

//exports.Sc = makeINCtor(I_sc);
exports.Sc = function(...args) {
  return {
    exec: I_sc,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Fcall : instruction node for calling a function 

// IE-safe helper to determine if something is a function
function testIsFunction(f) {
  if (typeof f == "function") return true;
  // ... else, the IE/Safari workarounds (some things like
  // document.getElementById are not functions)
  // try 1:
//  return ((""+f).indexOf("[native code]") != -1) ||
//    ((""+f).indexOf("Constructor]") != -1);
  // try 2: (doesn't catch "[object ...]")
//  return ((""+f).indexOf("[") != -1 )
  // try 3:
  // don't catch things like: html::Element[div] (stringification of mho:surface html primitives) 
  return /(^| )\[[^o]/.test(""+f);
}  

// structure of ndata array:
// mode: 0: normal call, 1: reference call, 2: 'new' call
#define NDATA_FCALL_MODE() ndata[0]
#define NDATA_FCALL_LINE() ndata[1]
#define NDATA_L_INDEX 2
#define NDATA_FCALL_L() ndata[2]
#define NDATA_FCALL_ARGS_OFFSET 3
// ndata[NDATA_FCALL_ARGS_OFFSET..end] : fcall args

/*
  continuation index:
   0 : start
   1 : returning from l/pars evaluation
   2 : returning from 'new' call (need to return 'this.o') 
*/

function EF_Fcall(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];
}
setEFProto(EF_Fcall.prototype={});
#ifdef EF_TYPES
EF_Fcall.prototype.type = "Fcall";
#endif

EF_Fcall.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val)) {
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // returning from a 'new' call
    return this.returnToParent(typeof val === 'object' ? val : this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i===NDATA_FCALL_ARGS_OFFSET) {
        this.l = val;
      }
      else
        this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(rv)) {
          rv.quench(); // not sure this is needed here XXX
          rv = rv.abort(this.pseudo_abort);
          return this.returnToParent(rv);
        }
      }

      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1, true); // prevent unnecessary callstack copying
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    }
    
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF;
    }

    // alright, we've got the left side + pars, let's do the call:
    try {
      switch (this.NDATA_FCALL_MODE()) {
      case 0:
      // 'normal' call
      // this optimization gives at least 10% performance boost vs 'eval'
      if (typeof this.l == "function") {
        rv = this.l.apply(null, this.pars);
      } 
      else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        var command = "this.l(";
        for (var i=0; i<this.pars.length; ++i) {
          if (i) command +=",";
          command += "this.pars["+i+"]";
        }
        command += ")";
        try {
          rv = eval(command);
        }
        catch (e) {
          // we have a bit of a problem now... the command could have
          // failed because the "function" wasn't a function after
          // all, or because running the builtin failed. As this is
          // mainly a problem on windows (maybe also safari?) we'll
          // take a punt and replace the (cryptic) exception we get
          // ("this.l isn't a function") by a saner one:
          rv = new CFException("t",
                               new Error("'"+this.l+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case 1:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], this.pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA !== "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<this.pars.length; ++i) {
          if (i) command +=",";
          command += "this.pars["+i+"]";
        }
        command += ")";

        try {
          rv = eval(command);
        }
        catch (e) {
          // as above, we have a bit of a problem now... the command
          // could have failed because the "function" wasn't a
          // function after all, or because running the builtin
          // failed. As this is mainly a problem on windows (maybe
          // also safari?) we'll take a punt and replace the (cryptic)
          // exception we get ("this.l isn't a function") by a saner
          // one:
          rv = new CFException("t",
                               new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                               this.NDATA_FCALL_LINE(),
                               this.env.file);
        }
      }
      break;
      case 2:
        // 'new' call
        var ctor = this.l;
        var pars = this.pars;
        rv = new ctor(...pars);
        if (is_ef(rv)) {
          if (!rv.env) throw new Error("Invalid constructor function (no environment)");
          this.o = rv.env.tobj;
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      if (is_cfx(e)) {
        // handle blocklambda break: 
        if (e.type == 'blb' && this.env.blscope && e.eid == this.env.blscope.sid) {
          rv = UNDEF;
        }
        else
          rv = e;
      }
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }
    if (is_ef(rv)) {
      if (this.aborted) {
        // reentrant abortion
        rv = rv.abort(this.pseudo_abort);
        return this.returnToParent(rv);
      }

      // the call is blocking -> insert ourselves into callstack:
      if (!rv.callstack) rv.callstack = [];
      rv.callstack.push([this.env.file, this.NDATA_FCALL_LINE()]);
    }
    return this.returnToParent(rv);
  }
};

function I_fcall(ndata, env) {
  return cont(new EF_Fcall(ndata, env), 0);
}

//exports.Fcall = makeINCtor(I_fcall);
exports.Fcall = function(...args) {
  return {
    exec: I_fcall,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// If : instruction node for executing 'if'

// structure of ndata array:
#define NDATA_IF_TEST() ndata[0]
#define NDATA_IF_CONSEQUENT() ndata[1]
#define NDATA_IF_ALTERNATIVE() ndata[2]

/*
  continuation index:
   0 : start
   1 : returning from test evaluation
*/

#ifdef DEBUG_VM
var if_counter = 0;
#endif

function EF_If(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++if_counter;
#endif
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_If.prototype={});
#ifdef EF_TYPES
EF_If.prototype.type = "If";
#endif

EF_If.prototype.cont = function(idx, val) {
  switch (idx) {
  case 0:
  //  LOG("IF: exec test")
  val = execIN(this.NDATA_IF_TEST(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }

  //  LOG("IF: test execed:"+val)
  case 1:
  if (is_cfx(val)) break;
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  // tail calls:
  if (val)
    val = execIN(this.NDATA_IF_CONSEQUENT(), this.env);
  else
    val = execIN(this.NDATA_IF_ALTERNATIVE(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
      }
    }
  break;
  default:
  val = new CFException("i", "invalid state in EF_If");
  }
  return this.returnToParent(val);
};

function I_if(ndata, env) {
  return cont(new EF_If(ndata, env), 0);
}

//exports.If = makeINCtor(I_if);
exports.If = function(...args/*t,c,a*/) {
  return {
    exec: I_if,
    ndata: args, //[t,c,a],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Switch: instruction node for executing 'switch() { case/default }'

// exported objected designating a 'default' clause:
var Default = {};
exports.Default = Default;

// structure of ndata array:
#define NDATA_SWITCH_EXP() ndata[0]
#define NDATA_SWITCH_CLAUSES() ndata[1]

/*
  continuation index:

phase 0: (evaling switch exp)

   0    : start
   1    : returning from switch expression evaluation

phase 1: (testing clause exp)
   -1   : entering from switch exp evaluation
   0..n : returning from given clause exp 


phase 2: (executing clause code)

   0...n : next clause to run
*/

function EF_Switch(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.phase = 0;
}
setEFProto(EF_Switch.prototype={});
#ifdef EF_TYPES
EF_Switch.prototype.type = "Switch";
#endif

EF_Switch.prototype.cont = function(idx, val) {
  switch (this.phase) {
  case 0: // evaluate switch expression
  if (idx == 0) {
    val = execIN(this.NDATA_SWITCH_EXP(), this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  if (is_cfx(val)) return this.returnToParent(val);
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  this.phase = 1;
  this.testval = val;
  idx = -1;
  case 1: // test clauses until we find a matching one
  while (true) {
    if (idx > -1) { // returning from evaluation of clause test idx
      if (is_cfx(val)) return this.returnToParent(val);
      if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
      else if (val == Default || val == this.testval)
        break; // go into phase 2!
    }
    if (++idx >= this.NDATA_SWITCH_CLAUSES().length)
      return this.returnToParent(null); // all done; no matching clause found
    // test next clause:
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 21
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][0], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
  }
  this.phase = 2;
  val = 0;
  case 2: // run clauses
  while (true) {
    if (is_ef(val)) {
      this.setChildFrame(val, idx);
      return this;
    }
    if (is_cfx(val)) {
      if (val.type == "b") {
        val = val.val;
      }
      return this.returnToParent(val);
    }
    if (idx >= this.NDATA_SWITCH_CLAUSES().length) {
      return this.returnToParent(val);
    }
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      this.child_frame = UNDEF; // prevent callstack copying; stack-tests 22
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][1], this.env);
    if (this.aborted) {
      // a reentrant abortion
      if (is_ef(val)) {
        val.quench(); // not sure this is needed here XXX
        val = val.abort(this.pseudo_abort);
        return this.returnToParent(val);
      }
    }
    ++idx;
  }
  default:
  throw new Error("Invalid phase in Switch SJS node");
  }
};

function I_switch(ndata, env) {
  return cont(new EF_Switch(ndata, env), 0);
}

//exports.Switch = makeINCtor(I_switch);
exports.Switch = function(...args/*exp, clauses*/) {
  return {
    exec: I_switch,
    ndata: args, //[exp, clauses],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Try : instruction node for try/catch/finally

// structure of ndata array:
// ndata[0] contains flags.
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE TRY_FLAG_'s in kernel-sjs.js.in
#define NDATA_TRY_FLAG_NONE 0
#define NDATA_TRY_FLAG_AUGMENTED_FINALLY 1

#define NDATA_TRY_FLAGS() ndata[0]
#define NDATA_TRY_TRY_BLOCK() ndata[1]
#define NDATA_TRY_CATCH_FUNC() ndata[2]
#define NDATA_TRY_FINALLY_BLOCK() ndata[3]
#define NDATA_TRY_RETRACT_BLOCK() ndata[4]

/*
  continuation index not used, we use this.state instead (since we
  need to know the state when we get an abort):

  0 : start
  1 : returning from try block
  2 : returning from catch
  3 : returning from retract
  4 : returning from finally

*/

#ifdef DEBUG_VM
var try_counter = 0;
#endif

function EF_Try(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++try_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.state = 0;
}
setEFProto(EF_Try.prototype={});
#ifdef EF_TYPES
EF_Try.prototype.type = function() { return "Try("+this.state+")" };
#endif

EF_Try.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, this.state);
  }
  else {
    if (this.child_frame) {
      this.child_frame.parent = UNDEF;
      // ensure correct reentrant aborting:
      // XXX not sure if this is negatively impacting call-stack copying
      this.child_frame = UNDEF; 
    }

    switch (this.state) {
    case 0:
    this.state = 1;
    val = execIN(this.NDATA_TRY_TRY_BLOCK(), this.env);

    if (is_ef(val)) {
      this.setChildFrame(val);
      return this;
    }
    case 1:
      // returning from try block
      this.state = 2;
      if (this.NDATA_TRY_CATCH_FUNC() &&
          (is_cfx(val) && val.type == "t")) {
        var v;
        v = val.val;
        val = this.NDATA_TRY_CATCH_FUNC()(this.env, v);
        
        // Check for a reentrant abortion triggered by our catch() block
        // see sjs-2-tests.sjs: reentrant abortion from catch()
        if (this.aborted && is_ef(val)) {
          val.quench();
          val = val.abort(this.pseudo_abort);
        }

        // tail-call optimization:
        // The !(aborted&&is_ef) check is important because cont() is called from EF_Try::abort, and 
        // we don't want to be replaced by a child frame.
        if (!this.NDATA_TRY_RETRACT_BLOCK() && 
            !this.NDATA_TRY_FINALLY_BLOCK() && 
            !(this.aborted && is_ef(val))) {
          return this.returnToParent(val);
        }
        
        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 23
          return this;
        }
      }
    case 2:
    // returning from try/catch
    this.state = 3;
    // save value from catch/try:
    this.rv = val;
    if (this.aborted && !this.pseudo_abort && this.NDATA_TRY_RETRACT_BLOCK()) {
      val = execIN(this.NDATA_TRY_RETRACT_BLOCK(), this.env);

      // tail-call optimization:
      // XXX this breaks sjs-testsuite2:51
      //if (!this.NDATA_TRY_FINALLY_BLOCK())
      //  return this.returnToParent(val);


      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 3:
    // returning from try/catch/retract
    this.state = 4;

    // make sure exceptions from retract get passed through:
    if (is_cfx(val) && val.type === "t") {
      this.rv = val;
    }

    if (this.NDATA_TRY_FINALLY_BLOCK()) {
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        // Can pass in `this.parent` below, for debugging purposes:
        // `try { hold(0); } finally(e) { console.log(e[4]); throw e; }`
        // gives the current ef.
        var v = is_cfx(this.rv) ?
          [this.rv, true, !!this.aborted, !!this.pseudo_abort/*, this.parent*/] :
          [this.rv, false, !!this.aborted, !!this.pseudo_abort/*, this.parent*/];
        val = this.NDATA_TRY_FINALLY_BLOCK()(this.env, v);
      }
      else {
        val = execIN(this.NDATA_TRY_FINALLY_BLOCK(), this.env);
      }
      // we can't tail-call this, because we might have to return
      // the stored rv (if it is an exception)
      if (is_ef(val)) {
        this.setChildFrame(val, 0, true); // prevent unnecessary callstack copying
        return this;
      }
    }
    case 4:
      // returning from finally
      
      if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_AUGMENTED_FINALLY) {
        if (!is_cfx(val)) {
          val = new CFException("t", new Error("augmented finally(){} block needs to throw a value"));
        }
        else {
          // we expect 'throw' in an augmented finally(e){} to rethrow
          // 'e' (or an array with a value - exception or otherwise - as 
          // first argument). 
          // We also want to be able to cope with 'real' exceptions thrown
          // if e.g. there is a logic error in the finally block, so we
          // only resolve to val.val[0] if val.val is an array:
          if (Array.isArray(val.val))
            val = val.val[0];
        }
      }
      else {
        // override res with stored exception (from try or catch) if
        // val isn't an exception
        // It would make sense to never override a real exception thrown in try with
        // a 'return' or 'break' from finally, but - alas - js parity compels us to do so.
        if (!is_cfx(val) || val.type === 'a') {
          val = this.rv;
          //else if (this.aborted)
          //  val = new CFException('a');
        }
        else if (is_cfx(this.rv) && this.rv.type === 't') { // val is an exception and we have a pending exception from try/catch
          // while we cannot override finally's exception, we can log the fact that we are 
          // swallowing an exception:
          var msg; 
          if (val.type === 't')
            msg = "Exception '"+val.val+"' thrown";
          else
            msg = CFETypes[val.type];
          msg += " in finally{} clause overriding try/catch exception '"+this.rv.val+"'";
          if (console.error) console.error(msg);
          else console.log(msg);
        }
      }
    break;
    default:
    val = new CFException("i", "invalid state in CF_Try");
    }
    return this.returnToParent(val);
  }
};

EF_Try.prototype.quench = function() {
  if (this.child_frame && this.state !== 4 && this.state !== 3) // don't quench inside finally or retract blocks
    this.child_frame.quench();
};

EF_Try.prototype.abort = function(pseudo_abort) {
  ASSERT(this.aborted !== true); // sanity check; aborted before
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;

  if (!this.child_frame) return this; // reentrant abort

  ASSERT(this.state !== 3) // sanity check; aborted before
  if (this.state !== 4) { // don't abort finally block
    var val = this.child_frame.abort(this.pseudo_abort); 
    if (is_ef(val)) {
      // we need to wait for the try or catch block, and then let
      // cont() proceed with retract/finally:
      this.setChildFrame(val);
    }
    else {
      // attempt to execute catch/retract/finally blocks synchronously:

      // Leftover from old abort code. Not sure what the logic was here.
      // prevent continuation from ending up at parent, we want to feed
      // it to the abortee directly:
      // this.parent = UNDEF;

      // temporarily need to turn off async flag, so that 'returnToParent' doesn't attempt to 
      // return to non-existing parent, which would cause exceptions to go uncaught
      this.async = false;
      var rv = cont(this, 0, val);
      ASSERT(!is_ef(rv) || rv === this);
      if (rv !== this) {
        if (!is_cfx(rv) || rv.type === 'a')
          rv = val; //new CFException('a');
        return rv;
      }
      else {
        this.rv = val; // XXX not sure this is necessary, since we passed 'val' to 'cont', above
        this.async = true;
      }
      // & fall through. we need to block
    }
  }
  return this;
};

function I_try(ndata, env) {
  return cont(new EF_Try(ndata, env), 0);
}

//exports.Try = makeINCtor(I_try);
exports.Try = function(...args) {
  return {
    exec: I_try,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Loop : instruction node for looping constructs

// structure of ndata array:
#define NDATA_LOOP_INIT_STATE() ndata[0]
#define NDATA_LOOP_TEST() ndata[1]
#define NDATA_LOOP_INC() ndata[2]
#define NDATA_LOOP_BODY(i) ndata[i+1]

/*
  continuation index:
   0 : perform test next
   2 - ndata.length+2 : perform body NDATA_LOOP_BODY+i-2 next
   1 : perform inc next 
*/

function EF_Loop(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Loop.prototype={});
#ifdef EF_TYPES
EF_Loop.prototype.type = "Loop";
#endif

EF_Loop.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    while (true) {
      // test:
      if (idx === 0) {
        if (is_cfx(val)) {
          // maybe return value from body here
          return this.returnToParent(val);
        }
        // perform loop test
        val = execIN(this.NDATA_LOOP_TEST(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying; stack-tests 26
          return this;
        }
        idx = 2; // body next
      }
      // body:
      if (idx > 1) {
        if (idx === 2) {
          // examine return value from loop test:
          if (!val || is_cfx(val)) {
            // maybe return value from body here
            return this.returnToParent(val);
          }
        }
        while (1) {
          if (idx > 2) {
            if (is_cfx(val)) {
              if (val.type === 'blb' && this.env.blscope && val.eid === this.env.blscope.sid) {
                // blocklambda return
                val = UNDEF;
              }
              else {
                if (val.type === "b") {
                  // break statement
                  val = UNDEF;
                }
                else if (val.type === "c") {
                  // continue statement
                  val = UNDEF;
                  // break out of the loop; pick up again at increment:
                  break;
                }
                return this.returnToParent(val);
              }
            }
            if (idx >= this.ndata.length)
              break; // pick up at increment
          }
            
          // perform body
          if (this.child_frame) {
            this.child_frame.parent = UNDEF;
            this.child_frame = UNDEF; // ensure correct reentrant aborting & prevent callstack copying 
          }
          val = execIN(this.NDATA_LOOP_BODY(idx), this.env);
          if (this.aborted) {
            // a reentrant abortion
            if (is_ef(val)) {
              val.quench(); // not sure this is needed here XXX
              val = val.abort(this.pseudo_abort);
              // the is_ef check is crucial here, because the frame might still produce 'break's which the loop
              // must see - see sjs-2-tests 'blocking finally clause in loop is not abort point'
              if (!is_ef(val))
                return this.returnToParent(val);
            }
          }
          ++idx;
          if (is_ef(val)) {
            this.setChildFrame(val, idx);
            return this;
          }
        }
        idx = 1;
      }
      // this point will be reached directly if idx = 1
      if (this.NDATA_LOOP_INC())  {
        // perform inc
        val = execIN(this.NDATA_LOOP_INC(), this.env);
        if (this.aborted) {
          // a reentrant abortion
          if (is_ef(val)) {
            val.quench(); // not sure this is needed here XXX
            val = val.abort(this.pseudo_abort);
            return this.returnToParent(val);
          }
        }

        if (is_ef(val)) {
          this.setChildFrame(val, 0, true); // prevent callstack copying; stack-tests 27
          return this;
        }
      }
      idx = 0;
    }
  }
};

function I_loop(ndata, env) {
  return cont(new EF_Loop(ndata, env), NDATA_LOOP_INIT_STATE(), true);
}

//exports.Loop = makeINCtor(I_loop);
exports.Loop = function(...args) {
  return {
    exec: I_loop,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// ForIn : instruction node for 'for-in' loops

// structure of ndata array
#define NDATA_FORIN_OBJ()  ndata[0]
#define NDATA_FORIN_LOOPF() ndata[1]

/*
  continuation index:
   0   : start
   1   : returning from evalution of forin obj
   2   : returning from loopf
*/

function EF_ForIn(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_ForIn.prototype={});
#ifdef EF_TYPES
EF_ForIn.prototype.type = "ForIn";
#endif

EF_ForIn.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == 0) {
      val = execIN(this.NDATA_FORIN_OBJ(), this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort(this.pseudo_abort);
          return this.returnToParent(val);
        }
      }

      if (is_ef(val)) {
        this.setChildFrame(val, 1, true); // prevent callstack copying
        return this;
      }
      idx = 1;
    }
    if (idx == 1) {
      // returning from evaluation of forin obj
      if (is_cfx(val))
        return this.returnToParent(val);
      var for_in_obj = val;
      for (var x in for_in_obj) {
        if (typeof this.remainingX === 'undefined') {
          val = this.NDATA_FORIN_LOOPF()(this.env,x);
          if (is_cfx(val)) {
              if (val.type == "b") {
                // break statement
                val = UNDEF;
              }
              else if (val.type == "c") {
                // continue
                val = UNDEF;
                continue;
              }
            return this.returnToParent(val);
          }
          if (is_ef(val)) {
            this.remainingX = [];
            this.for_in_obj = for_in_obj;
          }
        }
        else
          this.remainingX.push(x);
      }
      if (is_ef(val)) {
        if (!this.remainingX) this.remainingX = [];
        this.setChildFrame(val, 2, true); // prevent callstack copying
        return this;
      }
      // all done
      return this.returnToParent(val);
    }
    if (idx == 2) {
      while (1) {
        // returning from evaluation of loop
        if (is_cfx(val)) {
            if (val.type == "b") {
              // break
              val = UNDEF;
            }
            else if (val.type == "c") {
              // continue
              val = UNDEF;
              if (this.remainingX.length)
                continue;
            }            
          return this.returnToParent(val);
        }
        if (is_ef(val)) {
          this.setChildFrame(val, 2, true); // prevent callstack copying
          return this;
        }
        var arg;
        while (true) {
          if (!this.remainingX.length) {
            this.for_in_obj = undefined;
            return this.returnToParent(val);
          }
          arg = this.remainingX.shift();
          if (arg in this.for_in_obj)
            break;
        }
        val = this.NDATA_FORIN_LOOPF()(this.env, arg);
        // go round the loop again
      }
    }
  }
};

function I_forin(ndata, env) {
  return cont(new EF_ForIn(ndata, env), 0);
}

//exports.ForIn = makeINCtor(I_forin);
exports.ForIn = function(...args/*obj,loop*/) {
  return {
    exec: I_forin,
    ndata: args, //[obj,loop],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Par : stratified par construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/


// helper for Par & Alt:
function mergeExceptions(new_exception, original_exception) { 

  if (is_cfx(new_exception)) {
    if (!is_cfx(original_exception)) {
      // propagate everything but aborts:
      if (new_exception.type !== 'a') return new_exception;
      return original_exception;
    }
    // else... competing exceptions
    // we'll replace any existing exception only if the new exception is a 'true' exception:
    if (new_exception.type !== 't') return original_exception;
    if (console) {
      // XXX not sure what to do. Create a new exception with two sub-exceptions??
      var msg;
      if (original_exception.type === 't')
        msg = "Multiple exceptions from sub-strata. Swallowing "+original_exception.val;
      else
        msg = "Swallowing control-flow exception of type '"+original_exception.type+"' because it is overridden by a true exception";
      if (console.error) console.error(msg);
      else console.log(msg);
    }
    return new_exception;
  }
  else {
    return original_exception;
  }
}

#ifdef DEBUG_VM
var par_counter = 0;
#endif

function EF_Par(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++par_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Par.prototype={});
#ifdef EF_TYPES
EF_Par.prototype.type = "Par";
#endif

EF_Par.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        val = execIN(this.ndata[i], this.env);
        exports.current_dyn_vars = parent_dyn_vars;
        if (this.inner_aborted) {
          // this check is to catch the case of reentrant abortion through
          // suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else if (is_cfx(val)) {
          // an exception aborts all other pending branches:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      }
      // we clear ndata here to:
      //   (a) serve as an indication that we're done with kicking off all children. If ndata is not
      //       UNDEF, we know that we're being called reentrantly - not used yet: see also comment at start of
      //       returnToParent
      //   (b) to aid garbage collection
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension or called reentrantly from a branch that is continued by another branch
      --this.pending;
      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted && 
          !(val.type === 'blb' && this.env.blscope && val.eid === this.env.blscope.sid)) {
        // an exception aborts all other pending branches: (but only
        // if it is not a blb break targetted at us - this can happen
        // when a break is tail-called: see "sjs-2-tests:tailcalled blocklambda break / par edge case")
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending < 2) {
      if (this.pendingCFE === undefined) {
        // 'normal' return path:
        
        if (this.pending === 0)
          return this.returnToParent(val);
        // make a tail-call if there is only one last pending child:
        var return_child;
        for (var i=0; i<this.children.length; ++i)
          if ((return_child = this.children[i])) { 
            // We must NOT delete the child array here
            // to prevent a reentrancy case (see sjs-2-tests:par-reentrant-tailcall-edgecase)
            // this.children = undefined;
            return this.returnToParent(return_child);
          }
        return this.returnToParent(new CFException("i", "invalid state in Par"));
      }
      else {
        // There is a pending control flow exception which we need to return.
        // Therefore we can't do a tail call.

        // make sure a real exception overrides a normal control flow exception
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        if (this.pending === 0)
          return this.returnToParent(this.pendingCFE);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Par.prototype.quench = function() {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench'.
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally
  for (var i=0; i<this.children.length; ++i) {
    if (this.children[i])
      this.children[i].quench();
  }
};

EF_Par.prototype.abort = function(pseudo_abort) {
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    return this;
    //return this.pendingCFE || new CFException('a');
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  return this.abortInner();
};

EF_Par.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a
  // branch excepts)
  this.inner_aborted = true;
  for (var i=0; i<this.children.length; ++i)
    if (this.children[i]) {
      var val = this.children[i].abort(this.pseudo_abort);
      if (is_ef(val)) // need to wait on this one...
        this.setChildFrame(val, i);
      else {
        this.pendingCFE = mergeExceptions(val, this.pendingCFE);

        // aid gc, but note that this will mask any superfluous (and
        // incorrect) cont-calls from the child:
        //this.children[i].parent = UNDEF;

        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  if (!this.pending) // all done
    return this.pendingCFE || new CFException('a'); // if there is no pending cfe, pendingCFE is undefined
  // we need to wait:
  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Par.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/and: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.push(['WAITFOR/AND', child_trees]);
    return st;
  };
#endif

// setChildFrame function used by EF_Par, EF_Alt, EF_WfW:
function setChildFramePar(ef, idx) {
  if (this.children[idx]) {
    if (this.children[idx].callstack) {
      // merge callstacks of old & new childframes (stack-tests 28,29)
      mergeCallstacks(ef, this.children[idx]);
    }
    this.children[idx].parent = UNDEF;
  }
  this.children[idx] = ef;
  ef.parent = this;
  ef.parent_idx = idx;
}

EF_Par.prototype.setChildFrame = setChildFramePar;

function I_par(ndata, env) {
  return cont(new EF_Par(ndata, env), -1);
}

//exports.Par = makeINCtor(I_par);
exports.Par = function(...args) {
  return {
    exec: I_par,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// Alt : stratified alt construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/

#ifdef DEBUG_VM
var alt_counter = 0;
#endif

function EF_Alt(ndata, env) {
#ifdef DEBUG_VM
  this.id = ++alt_counter;
#endif
  this.ndata = ndata;
  this.env = env;

  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Alt.prototype={});
#ifdef EF_TYPES
EF_Alt.prototype.type = function() {return "Alt(aborted="+!!this.aborted+")"};
#endif

EF_Alt.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        // create a new environment for 'collapse' support
        // XXX it sucks that we have to create a new environment for each branch here 
        var env = copyEnv(this.env);
        env.fold = this;
        env.branch = i;
        val = execIN(this.ndata[i], env);
        exports.current_dyn_vars = parent_dyn_vars;
                     
        if (this.inner_aborted) {
          // the check for !aborted here is to catch the case of
          // reentrant abortion through suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          return this.pendingRV;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else {
          // an exception or real value aborts all other pending branches:
          this.pendingRV = val;
          this.quench();
          return this.abortInner();
        }
        if (this.collapsed) break; // don't start any other branches
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension. 
      --this.pending;
      this.children[idx] = UNDEF;
      this.pendingRV = mergeExceptions(val, this.pendingRV);

      if (this.collapsing) {
        // we're returning from an async abort after collapsing
        // (uncommon case; see comment below)
        if (this.pending == 1) {
          // only our collapsing branch is left; continue with it
          var cf = this.collapsing.cf;
          this.collapsing = UNDEF;
          cont(cf, 1);
        }
        return;
      }
      else {
        // 'normal' case

        // abort all pending branches
        if (!this.inner_aborted) {
          if (this.pendingRV === undefined)
            this.pendingRV = val;
          this.quench();
          return this.returnToParent(this.abortInner());
        }
        if (this.pending == 0)
          return this.returnToParent(this.pendingRV);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Alt.prototype.quench = function(except) {
  // XXX we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'reentrant quench'.
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally

  if (this.collapsing) {
    // we're being quenched after a collapse; just quench the collapsing branch
    this.children[this.collapsing.branch].quench();
  }
  else {
    // common case, quench all branches (possibly except 'except')
    for (var i=0; i<this.children.length; ++i) {
      if (i!== except && this.children[i])
        this.children[i].quench();
    }
  }
};

EF_Alt.prototype.abort = function(pseudo_abort) {
  // XXX not sure what the rationale was here
  //this.parent = UNDEF;
  if (this.aborted) {
    //XXX not sure what the rationale was here
    //this.pendingRV = UNDEF;
    return this;
  }

  this.pseudo_abort = pseudo_abort;
  this.aborted = true;
  var rv;
  if (!this.inner_aborted) {
    rv = this.abortInner();
  }
  else if (this.pending)
    rv = this;

  this.pendingRV = this.pendingRV || new CFException('a');
  if (rv !== this && !is_cfx(rv)) rv = this.pendingRV;
  return rv;
};

EF_Alt.prototype.abortInner = function() {
//  ASSERT(!this.inner_aborted);

  // see Par::abortInner for more details
  this.inner_aborted = true;
  if (this.collapsing) {
    // we're being aborted after a collapse; just need to abort the collapsing branch
    var branch = this.collapsing.branch;
    this.collapsing = UNDEF;
    var val = this.children[branch].abort(this.pseudo_abort);
    if (is_ef(val)) // need to wait
      this.setChildFrame(val, branch);
    else {
      --this.pending;
      this.children[branch] = UNDEF;
    }
  }
  else {
    // common case: abort all branches
    for (var i=0; i<this.children.length; ++i)
      if (this.children[i]) {
        var val = this.children[i].abort(this.pseudo_abort);
        if (is_ef(val)) // need to wait
          this.setChildFrame(val, i);
        else {
          this.pendingRV = mergeExceptions(val, this.pendingRV);
          --this.pending;
          this.children[i] = UNDEF;
        }
      }
  }
  if (!this.pending)
    return this.pendingRV;
  this.async = true;
  return this;
};

#ifdef DEBUG_VM
  EF_Alt.prototype.gatherSuspensionTree = function() {
    var st = this.callstack || [];
    var child_trees = [];
    for (var i=0; i<this.children.length; ++i) {
      try {
        if (this.children[i])
          child_trees.push(this.children[i].gatherSuspensionTree());
      }
      catch (e) {
        console.log("Waitfor/or: Error gathering suspension tree for "+this.children[i]);
        throw e;
      }
    }
    st.concat([['WAITFOR/OR', child_trees]]);
    return st;
  },
#endif

EF_Alt.prototype.setChildFrame = setChildFramePar;

EF_Alt.prototype.docollapse = function(branch, cf) {
  this.collapsed = true;
  var have_async_branch_retract = false;
  // abort all children apart from 'branch'
  this.quench(branch);
  for (var i=0; i<this.children.length; ++i) {
    if (i == branch) continue;
    if (this.children[i]) {
      var val = this.children[i].abort();
      if (is_ef(val)) { // need to wait
        have_async_branch_retract = true;
        this.setChildFrame(val, i);
      }
      else {
        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  }
  if (!have_async_branch_retract) {
    ASSERT(this.pending <= 1); // =0 for sync case, =1 for async case 
    return true;
  }
  // ... else we need to wait
  // this happens if there is an asynchronous retract or finally clause 
  // in one of the aborted branches 
  this.collapsing = { branch:branch, cf:cf};
  return false;
};

function I_alt(ndata, env) {
  return cont(new EF_Alt(ndata, env), -1);
}

//exports.Alt = makeINCtor(I_alt);
exports.Alt = function(...args) {
  return {
    exec: I_alt,
    ndata: args,
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// WfW: stratified waitfor-while construct
/*
   ndata[0] = controlled branch / children[0]
   ndata[1] = controlling branch / children[1]

   continuation index:
   -1: start
*/

function EF_WfW(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(2);
}
setEFProto(EF_WfW.prototype={});
#ifdef EF_TYPES
EF_WfW.prototype.type = function() {return "WfW(aborted="+!!this.aborted+")"};
#endif

EF_WfW.prototype.cont = function(idx, val) {
  //console.log("wfw cont("+idx+","+val+",pending="+this.pending+")");
  if (is_ef(val)) {
    // child frame being replaced
    this.setChildFrame(val, idx);
  }
  else {
    if (idx === -1) {
      var parent_dyn_vars = exports.current_dyn_vars;
      // kick off children
      for (var i=0; i<2;++i) {
        val = execIN(this.ndata[i], this.env);
        exports.current_dyn_vars = parent_dyn_vars;
        if (this.inner_aborted) {
          if (is_ef(val)) {
            // reentrant abortion through suspend/resume
            // (sjs-3-tests:'waitfor/while:reentrant quench',
            //  sjs-3-tests:'reentrant edge case')
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          this.pendingCFE = mergeExceptions(val, this.pendingCFE);
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else if (is_cfx(val) || i===1) {
          // an exception in either branch or a 'normal' exit from the 
          // second branch aborts the WfW:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      } // end kick off children
      this.ndata = UNDEF;
    }
    else {
      // returning from a suspension (or called reentrantly from a branch that is continued by
      // another branch)
      --this.pending;

      if (this.children[idx]) {
        // clear parent on child to aid gc:
        this.children[idx].parent = UNDEF;
        this.children[idx] = UNDEF;
      }
      if (is_cfx(val) && !this.inner_aborted &&
          !(val.type === 'blb' && this.env.blscope && val.eid === this.env.blscope.sid)) {
        // an exception aborts all other pending branches: (but only
        // if it is not a blb break targetted at us - this can happen
        // when a break is tail-called: "see sjs-3-tests:tailcalled blocklambda break / wfw edge case")
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    
    if (this.pending === 1) {
      if (this.pendingCFE === undefined && this.children[1]) {
        // we can make a tailcall:
        return this.returnToParent(this.children[1]);
      }
      else if (this.children[0]) {
        // we only have the controlled branch left; abort it:
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending === 0) {
      // XXX do we need the mergeExceptions call here?
      return this.returnToParent(mergeExceptions(val, this.pendingCFE));
    }

    this.async = true;
    return this;
  }
};

EF_WfW.prototype.quench = function() {
  // we have to quench even if inner_aborted is true - see
  // sjs-3-tests:'waitfor/while:reentrant quench'.
  // This means that we're probably doing some redundant quenches which could 
  // be optimized away.
  // if (this.inner_aborted) return; // already quenched/aborted internally
  if (this.children[0]) this.children[0].quench();
  if (this.children[1]) this.children[1].quench();
};

EF_WfW.prototype.abort = function(pseudo_abort) {
  // Leftover from old abort code. Not sure what the logic was here.
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  //this.parent = UNDEF;
  if (this.aborted) {
    // XXX not sure this is still true
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    //this.pendingCFE = UNDEF;
    return this;
    //return this.pendingCFE || new CFException('a');
  }
  else
    this.pseudo_abort = pseudo_abort;
  this.pendingCFE = this.pendingCFE || new CFException('a');
  this.aborted = true;
  return this.abortInner();
};

EF_WfW.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a 
  // branch excepts or when the 2nd branch returns)
  this.inner_aborted = true;
  // we always want to abort the second branch before the first
  if (this.children[1]) {
    var val = this.children[1].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      this.setChildFrame(val, 1);
      this.async = true;
      return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[1] = UNDEF;
    } 
  }
  if (this.children[0]) {
    var val = this.children[0].abort(this.pseudo_abort);
    if (is_ef(val)) { // need to wait
      this.setChildFrame(val, 0);
      this.async = true;
      return this;
    }
    else {
      this.pendingCFE = mergeExceptions(val, this.pendingCFE);
      // aid gc, but note that this will mask any superfluous (and incorrect)
      // cont-calls from the child:
      // this.children[1].parent = UNDEF;
      --this.pending;
      this.children[0] = UNDEF;
    }
  }
  // assert this.pending === 0
  return this.pendingCFE;
};

EF_WfW.prototype.setChildFrame = setChildFramePar;

function I_wfw(ndata, env) {
  return cont(new EF_WfW(ndata, env), -1);
}
exports.WfW = function(...args) {
  return { exec: I_wfw,
           ndata: args,
           __oni_dis: token_dis };
};

//----------------------------------------------------------------------
// Suspend: stratified suspend operation

#ifdef ASYNC_RESUME
var ResumeQueue = {
  messages: [],
  pickup_pending: false,
  post: function(resume_struct) {
    this.messages.push(resume_struct);
    if (!this.pickup_pending) {
      this.pickup_pending = true;
#ifdef CLIENTSIDE
      setTimeout(function() { ResumeQueue.pickup(); }, 0);
#else
      callAsync(function() { ResumeQueue.pickup(); });
#endif
    }
  },
  pickup: function() {
    this.pickup_pending = false;
    var ms = this.messages;
    this.messages = [];
    for (var i=0; i<ms.length; ++i) {
      var m = ms[i];
      cont(m[0],m[1],m[2]);
    }
  }
};
exports.Q = ResumeQueue;
#endif

// structure of ndata array:
#define NDATA_SUSPEND_SUSPENDFUNC() ndata[0]
#define NDATA_SUSPEND_RETURNFUNC() ndata[1]

/*
  continuation index:
  0: start
  1: returning from execution of suspend function
  2: returning from execution of resume function
  3: returning from abortion of suspend function

  state variables:
  returning: resume function has been called or suspend threw
  suspendCompleted: suspend block has executed completely
  retvals: return values as passed into resume function
*/

function EF_Suspend(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Suspend.prototype={});
#ifdef EF_TYPES
EF_Suspend.prototype.type = "Suspend";
#endif

EF_Suspend.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    ASSERT(idx == 1 || idx == 3) //(others shouldn't rebase)
    this.setChildFrame(val, idx);
  }
  else {
    switch (idx) {
    case 0:
    try {
      var ef = this;
      this.dyn_vars = exports.current_dyn_vars;
#ifdef ASYNC_RESUME
      var resumefunc = function(...args) { ResumeQueue.post([ef,2,args]); };
#else
  // XXX We could return something from resumefunc
  var resumefunc = function(...args) {
    try {
      var caller_dyn_vars = exports.current_dyn_vars;
      exports.current_dyn_vars = ef.dyn_vars;
      cont(ef, 2, args);
    }
    catch(e) {
      var s = function() { throw e; };
#if defined (CLIENTSIDE)
      setTimeout(s, 0);
#elif defined (NODEJS)
      process.nextTick(s);
#else
      callAsync(s);
#endif
    }
    finally {
      ef.dyn_vars = undefined; // aid gc
      exports.current_dyn_vars = caller_dyn_vars;
    }
  };

#endif
      // XXX If we want to enable the 'clearOrphanedBLR' functionality in the bridge
      // then we need to reflect the execution frame onto the resume function here:
      //resumefunc.ef = ef; 

      //      LOG("executing suspend")
      val = this.NDATA_SUSPEND_SUSPENDFUNC()(this.env, resumefunc);
    }
    catch (e) {
      // XXX is this required??
      val = new CFException("t", e);
    }
    //    LOG('done executing suspend')
    // At this point we might have received a reentrant callback
    // from the resume function!!
    if (this.returning) {
      //      LOG('reentrant cb')
      if (is_ef(val)) {
        ASSERT(!this.child_frame)
        // processing up to here has been synchronous; we still need to abort
        this.setChildFrame(val, /* not relevant */0);
        this.quench();
        val = val.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          // get parent to wait for us:
          this.async = true;
          return this;
        }
        // ... else fall through
      }
      return cont(this, 3, null);
    }
    
    if (is_ef(val)) {
      this.setChildFrame(val, 1);
      return this;
    }
    case 1:
    // returning from execution of suspend function
    if (is_cfx(val)) {
      this.returning = true;
      break;
    }
    this.suspendCompleted = true;
    // suspend:
    this.async = true;
    return this;
    case 2:
    // returning from execution of resume function.        
    // Note that this might happen reentrantly, while we're still
    // processing the suspend block!!!
    if (this.returning) {
      // this is a trailing resume which we can safely ignore
      return;
    }
    this.returning = true;
    if (is_cfx(val)) {
      // sanity check
      // this shouldn't happen
      val = new CFException("i", "Suspend: Resume function threw ("+val.toString()+")");
      break;
    }
    this.retvals = val;
    if (!this.suspendCompleted) {
      // abort the suspend block:
      if (!this.child_frame) {
        // The suspend block is still executing synchronously.
        // This is a reentrant invocation of 'resume'.
        // We'll pick up with processing again when the suspend block is done
        this.returning = true;
        return;
      }
      else {
        this.quench();
        val = this.child_frame.abort(this.pseudo_abort);
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          return this;
        }
        // ... else fall through to case 3
        //        LOG('synchronous abortion')
          }
    }
    case 3:
    // set values with return function:
    try {
      this.NDATA_SUSPEND_RETURNFUNC().apply(this.env, this.retvals);
      val = UNDEF;
    }
    catch (e) {
      val = new CFException("i", "Suspend: Return function threw ("+e+")");
    }
    break;
    case 4:
      // return from external abort
      // fall through to returnToParent
      break;
    default:
    val = new CFException("i", "Invalid state in Suspend ("+idx+")");
    }
    return this.returnToParent(val);
  }
};

EF_Suspend.prototype.quench = function() {
  this.returning = true; // prevent resume() calls from having any effect
  if (!this.suspendCompleted)
    this.child_frame.quench();
};

EF_Suspend.prototype.abort = function(pseudo_abort) {
  //  LOG('SUSPEND abort (childf='+this.child_frame+')')
  exports.current_dyn_vars = this.dyn_vars;
  this.returning = true;
  this.aborted = true;
  this.pseudo_abort = pseudo_abort;
  if (!this.suspendCompleted) {
    var abort_val = this.child_frame.abort(pseudo_abort);
    if (is_ef(abort_val)) {
      this.setChildFrame(abort_val, 4);
      return this; // need to stay in picture, because abort must not return child frame
    }
    else {
      ASSERT(is_cfx(abort_val));
      return abort_val;
    }
  }
  return new CFException('a');
};

function I_sus(ndata, env) {
  return cont(new EF_Suspend(ndata, env), 0);
}

//exports.Suspend = makeINCtor(I_sus);
exports.Suspend = function(...args/*s,r*/) {
  return {
    exec: I_sus,
    ndata: args, //[s,r],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// spawn

// structure of ndata array:
#define NDATA_SPAWN_LINE() ndata[0]
#define NDATA_SPAWN_EXP() ndata[1]

// continuation index:
// 0: start
// 1: returning from async execution
// 2: returning from async parent stratum abortion during block lambda return

#ifdef DEBUG_VM
var spawn_counter = 0;
#endif
  
function EF_Spawn(ndata, env, notifyAsync, notifyVal, notifyAborted) {
#ifdef DEBUG_VM
  this.id = ++spawn_counter;
#endif
  this.ndata = ndata;
  this.env = env;
  this.notifyAsync = notifyAsync;
  this.notifyVal = notifyVal;
  this.notifyAborted = notifyAborted;
}
setEFProto(EF_Spawn.prototype={});
#ifdef EF_TYPES
EF_Spawn.prototype.type = "Spawn";
EF_Spawn.prototype.toString = function() { return "<Spawn"+this.id+"@"+this.env.file.substr(-20)+":"+this.ndata[0]+'>' };
#endif

EF_Spawn.prototype.cont = function(idx, val) {

  if (idx == 0) {
    // Set this.abort_path to the spawned stratum (if any) that we were started from.
    // We'll use this information to resolve abort cycles across strata:
    this.abort_path = exports.current_dyn_vars ? exports.current_dyn_vars.__oni__spawned_stratum : null;
    this.parent_dyn_vars = exports.current_dyn_vars;
    // Inject ourselves as the new spawned stratum into the dynamic vars seen by our stratum's 
    // code:
    exports.current_dyn_vars = Object.create(this.parent_dyn_vars);
    exports.current_dyn_vars.__oni__spawned_stratum = this;
    val = execIN(this.NDATA_SPAWN_EXP(), this.env);
    // Reset dyn vars:
    exports.current_dyn_vars = this.parent_dyn_vars;
    if (is_cfx(val) && (val.type === 'blb' || (val.type === 'r' && val.eid))) {
      return val;
    }
  }
  else if (idx === 2) {
    // returning from waiting for an aborted frame
    if (is_ef(val)) {
      this.setChildFrame(val, 2);
      return this.returnToParent(this);
    }
    else if (!is_cfx(val) || ((val.type !== 'r' || !val.eid) && val.type !== 'blb')) {
      // For blocklambda breaks and returns we fall through to the cfx handling below, so that they
      // get propagated appropriately.
      this.in_abortion = false;
      this.done = true;
      this.abort_path = undefined; // aid gc

      this.notifyVal(this.return_val, true);
      this.notifyAborted(val);

// XXX not sure what this is for
//      if (this.aborted && !is_cfx(this.return_val)) {
//        this.return_val = new CFException('a');
//      }

      return this.returnToParent(this.return_val);
    }
  }

  if (is_cfx(val)) {
    if (val.type === 'r' && val.eid) {
      // we have a blocklambda return
      // As we don't have a parent to abort, we abort this.env.blrref and
      // arrange for the blb to be passed on to this.env.blrref's parent:
      var frame_to_abort = this.env.blrref;

      if (!frame_to_abort.parent || frame_to_abort.unreturnable) {
        this.done = true;
        this.notifyVal(new CFException("t",
                                       new Error("Blocklambda return from spawned stratum to inactive scope"),
                                       this.NDATA_SPAWN_LINE(),
                                       this.env.file));
        this.notifyAborted(UNDEF);
        return;
      }

      // mark us unabortable:
      this.in_abortion = true;

      // inject ourselves:
      this.parent = frame_to_abort.parent;
      this.parent_idx = frame_to_abort.parent_idx;

      // tell parent about ourselves, so that we get any reentrant abort calls
      cont(this.parent, this.parent_idx, this);
      // for safety, make sure frame_to_abort doesn't send any returns
      // to this.parent. We're taking that role
      frame_to_abort.parent = UNDEF;

      // Abort the frame with a pseudo-abort (because we don't want 'retract' clauses executed)
      frame_to_abort.quench();
      var aborted_target = frame_to_abort.abort(true);
      if (is_ef(aborted_target)) {
        // make sure our aborted target's parent gets the blb:
        this.return_val = val;
        this.setChildFrame(aborted_target, 2);

        // return value to ef & listeners:
        this.notifyVal(UNDEF, true);
        this.notifyAborted(UNDEF);

        // no reason to call notifyAsync here; we've already done that in a previous cont() call
        this.returnToParent(this);
        return;
      }

      this.in_abortion = false;
      this.done = true;


      // return value to ef & listeners:
      this.notifyVal(UNDEF, true);
      this.notifyAborted(UNDEF);

      // return the blb to our aborted target's parent synchronously:
      return this.returnToParent(val.eid === frame_to_abort.sid ? val.val : val);
    }
    else if (val.type === 'blb') {
      // we have a blocklambda break
      // As we don't have a parent to abort, we abort this.env.blrref and
      // arrange for the blb to be passed on to this.env.blrref's parent:
      var frame_to_abort = this.env.blrref;

      if (!frame_to_abort.parent || frame_to_abort.unreturnable) {
        this.done = true;
        this.notifyVal(new CFException("t",
                                       new Error("Blocklambda break from spawned stratum to invalid or inactive scope"),
                                       this.NDATA_SPAWN_LINE(),
                                       this.env.file));
        this.notifyAborted(UNDEF);
        return;
      }

      // mark us unabortable:
      this.in_abortion = true;

      // inject ourselves:
      this.parent = frame_to_abort.parent;
      this.parent_idx = frame_to_abort.parent_idx;
      // tell parent about ourselves, so that we get any reentrant abort calls
      cont(this.parent, this.parent_idx, this);
      // for safety, make sure frame_to_abort doesn't send any returns
      // to this.parent. We're taking that role
      frame_to_abort.parent = UNDEF;

      // Abort the frame:
      frame_to_abort.quench();
      // XXX should this be a pseudo abort??
      var aborted_target = frame_to_abort.abort(true);
      if (is_ef(aborted_target)) {
        // make sure our aborted target's parent gets the blb:
        this.return_val = val;
        this.setChildFrame(aborted_target, 2);

        // return value to ef & listeners:
        this.notifyVal(UNDEF, true);
        this.notifyAborted(UNDEF);

        // no reason to call notifyAsync here; we've already done that in a previous cont() call
        this.returnToParent(this);
        return;
      }

      this.in_abortion = false;
      this.done = true;


      // return value to ef & listeners:
      this.notifyVal(UNDEF, true);
      this.notifyAborted(UNDEF);

      // return the blb to our aborted target's parent synchronously:
      return this.returnToParent(val);
    }
  } // is_cfx(val)
  
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    if (idx == 0)
      this.notifyAsync();
  }
  else {
    this.parent_dyn_vars = undefined; // aid gc
    this.in_abortion = false;
    this.done = true;
    this.notifyVal(val);
  }
};

EF_Spawn.prototype.abort = function(pseudo) {
  // This function is only called by stratum.abort, below, or when we receive a reentrant abort after
  // notifying listeners.
  // We don't need to deal with notifyAsync/notifyVal, because all value listeners 
  // will already have been called.
  if (this.in_abortion) return this;
  if (this.done) return new CFException('a');

  this.in_abortion = true;
  if (this.child_frame) {
    this.child_frame.quench();
    var val = this.child_frame.abort(pseudo); 
    if (is_ef(val)) {
      // we need to wait
      this.setChildFrame(val, 2);
      return this;
    }
    else {
      this.in_abortion = false;
      this.done = true;
      return val;//new CFException('a');
    }
  }
};

function EF_SpawnWaitFrame(waitarr) {
  this.dyn_vars = exports.current_dyn_vars;
  this.waitarr = waitarr;
  waitarr.push(this);
}
setEFProto(EF_SpawnWaitFrame.prototype={});
#ifdef EF_TYPES
EF_SpawnWaitFrame.prototype.type = "Stratum.value()";
#endif
EF_SpawnWaitFrame.prototype.quench = function() {};
EF_SpawnWaitFrame.prototype.abort = function() {
  var idx = this.waitarr.indexOf(this); // assert != -1
  this.waitarr.splice(idx, 1);
  return new CFException('a');
}
EF_SpawnWaitFrame.prototype.cont = function(val) {
  if (this.parent) {
    var current_dyn_vars = exports.current_dyn_vars;
    exports.current_dyn_vars = this.dyn_vars;
    this.dyn_vars = undefined; // aid gc

    if (is_annotated_oni_cfx(val)) {
      // we need to clone the exception, because there might be several value listeners which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      val = cloneAnnotatedCFX(val);

      // append callstack leading out of this `.value()` call:
      if (this.callstack)
        val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
    }

    cont(this.parent, this.parent_idx, val);
    exports.current_dyn_vars = current_dyn_vars;
  }
}

// XXX
var nextTick;
if (exports.G.nextTick) {
  nextTick  = exports.G.nextTick;
}
else if (exports.G.Promise) {
 nextTick = function(cb) { Promise.resolve().then(cb); };
}
else throw new Error("host environment not supported - need 'Promise' or 'nextTick'");

function EF_SpawnAbortFrame(waitarr, spawn_frame) {
  this.dyn_vars = exports.current_dyn_vars;
  this.waitarr = waitarr;
  waitarr.push(this);
  var me = this;
  nextTick(function() { me.resolveAbortCycle(spawn_frame); });

}
setEFProto(EF_SpawnAbortFrame.prototype={});
#ifdef EF_TYPES
EF_SpawnAbortFrame.prototype.type = "Stratum.abort()";
#endif
EF_SpawnAbortFrame.prototype.quench = function() {};
EF_SpawnAbortFrame.prototype.abort = function() {
  // to ensure proper sequencing of finally clauses, abort is unabortable
  this.aborted = true;
  return this;
}
EF_SpawnAbortFrame.prototype.cont = function(val) {
  if (this.done) return;
  if (this.parent) {
    var current_dyn_vars = exports.current_dyn_vars;
    exports.current_dyn_vars = this.dyn_vars;
    this.dyn_vars = undefined; // aid gc
    this.done = true;
    if (this.aborted && !is_cfx(val) && this.parent.aborted)
      val = new CFException('a');

    if (is_annotated_oni_cfx(val)) {
      // we need to clone the exception, because there might be several abort() calls which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      val = cloneAnnotatedCFX(val);

      // append callstack leading out of this `.abort()` call:
      if (this.callstack) {
        val.val.__oni_stack = val.val.__oni_stack.concat(this.callstack);
      }
    }


    cont(this.parent, this.parent_idx, val);
    exports.current_dyn_vars = current_dyn_vars;
  }
  else if (is_cfx(val) && (val.type === 't' || val.val instanceof Error)){
    // make sure exceptions end up somewhere
    hold0(function() { val.mapToJS(true); });
  }
}
EF_SpawnAbortFrame.prototype.resolveAbortCycle = function(spawn_frame) {
  if (this.done) return;
  var parent = this.parent;
  while (parent) {
    if (spawn_frame === parent) {
// Turn this warning off, as we use cyclic aborts quite frequently
//      var msg = "Warning: Cyclic stratum.abort() call from within stratum." + stack_to_string(this.callstack);
//      if (console) {
//        if (console.error) console.error(msg);
//        else console.log(msg);
//      }
      this.cont(UNDEF);
      return;
    }
    // If parent is null, we'll try 'abort_path', which will be set on EF_Spawn frames
    // that were started from other EF_Spawn's. It allows abort cycles across strata.
    parent = parent.parent || parent.abort_path;
  }
};


function ReifiedStratumProto() {}
exports.ReifiedStratumProto = ReifiedStratumProto;

// waitforValue deprecated:
ReifiedStratumProto.prototype.waitforValue = function() { return this.value() };
ReifiedStratumProto.prototype.toString = function() {return "[object Stratum]"; };


function I_spawn(ndata, env) {
  var val, async, have_val, picked_up=false;
  var value_waitarr = [];
  var abort_waitarr = [];

  // copy environment and reset blocklambda scope/refs, so that we 
  // don't get GC reference cycles
  env = copyEnv(env);
  env.blscope = null;
  env.blbref = null;
  // we need blrref for routing blb breaks from the spawned stratum; see EF_Spawn.prototype.cont
  // see also sjs-2-tests::'detached async blocklambda break 1'
  //env.blrref = null;


  var stratum = new ReifiedStratumProto();
  stratum.abort = function(pseudo) {
    var dyn_vars = exports.current_dyn_vars;
    
    if (ef.done) return UNDEF;

    // the 'in_abortion' check is important, or we might end up with deadlock, when an abort() call
    // in a finally clause is waiting for the spawn frame and vice versa, as in:
    // try { stratum = spawn ({||hold(0); return})(); stratum.value(); }finally { stratum.abort() }
    if (ef.in_abortion) {
      return new EF_SpawnAbortFrame(abort_waitarr, ef);
    }

    // we abort synchronously (i.e. abort() will block for any blocking finally clauses,
    // but any value listeners will receive a 'stratum aborted' notification immediately
    var rv = ef.abort(pseudo);

    exports.current_dyn_vars = dyn_vars;
    
    async = false;

    // value listeners will get a 'stratum aborted' exception'
    // any 'real' exception thrown during abortion will only go to the abort call itself.
    val =  new CFException("t",
                           new StratumAborted(),
                           NDATA_SPAWN_LINE(),
                           env.file);
    while (value_waitarr.length)
      cont(value_waitarr.shift(), val);
    
    if (is_ef(rv)) {
      return new EF_SpawnAbortFrame(abort_waitarr, ef);
    }
    
    // the rv.type check prevents CFException('a') from leaking out
    if (!is_cfx(rv) || rv.type !== 't')
      rv = UNDEF;
    notifyAborted(rv);


    if (is_annotated_oni_cfx(rv)) {
      // we need to clone the exception, because there might be several abort() calls which
      // all get their stack amended differently.
      // See also note at top of definition of `is_annotated_oni_cfx`
      rv = cloneAnnotatedCFX(rv);
      // throw the value (rather than returning), so that the callstack gets amended by the 
      // calling code:
      throw rv.val;
    }

    return rv;
  };

  stratum.value = function() {
    if (!async) { 
      picked_up=true; 
      if (is_annotated_oni_cfx(val)) {
        // we need to clone the exception, because there might be several value listeners which
        // all get their stack amended differently.
        // See also note at top of definition of `is_annotated_oni_cfx`
        var v = cloneAnnotatedCFX(val);
        // throw the value (rather than returning), so that the callstack gets amended by the
        // calling code:
        throw v.val;
      }
      return val; 
    }
    return new EF_SpawnWaitFrame(value_waitarr);
  };
    
  stratum.running = function() { return async; };

  stratum.waiting = function() {
    return value_waitarr.length;
  };
     
  // Undocumented '_adopt' feature:
  // _adopt is used to embed a stratum in a different scope for blreturns/breaks.
  // It is used for continuation buffers. 
  // See unit/sjs-3-tests:'return via different scope with _adopt'.
  // XXX There is probably a better way to expose this feature, therefore it is 
  // undocumented at this point.
  stratum._adopt = function(blrref) {
    //console.log(this+" adopting "+blrref+" as blrref. Was: "+ef.env.blrref);
    ef.env.blrref = blrref;
  };

  function notifyAsync() {
    async = true;
  }
  function notifyVal(_val, have_caller) {
    if (val !== undefined) // this guard is important so that a
      return;              // reentrant 'stratum aborted' exception
                           // doesn't get overwritten by a later result
    val = _val;
    async = false;
    if (!have_caller && !value_waitarr.length) {
      // make sure exceptions that noone is waiting on get reported in
      // console. Only report stray control flow exceptions & exceptions that
      // are instanceof Error;
      // IE shows a popup for uncaught exceptions, and exceptions
      // without linenumbers etc are very confusing
      if (is_cfx(val) && (val.type != 't' || val.val instanceof Error)) {
        // XXX unfortunately stray control flow exceptions, such as
        // e.g. returns from blocklambdas, will not have line numbers
        // attached. Maybe we shouldn't report them?
        //
        // It is essential that we throw the exception *asynchronously*
        // when async = false. Otherwise it will end up at our
        // caller. For simplicity we always throw asynchronously:
        setTimeout(function() { 
          // We only throw if the value hasn't been picked up in the
          // meanwhile. This is for cases where we have:
          //   var stratum = spawn synchronous_throw_here;
          //   stratum.value();
          // We want to prevent the exception feeding to the user twice in this case
          if (!picked_up)
            val.mapToJS(true); 
        }, 0);
      }
    }
    else {
      while (value_waitarr.length)
        cont(value_waitarr.shift(), val);
    }
    
  }
  function notifyAborted(_val) {
    if (!is_cfx(_val) || _val.type !== 't')
      _val = UNDEF;
    while (abort_waitarr.length)
      cont(abort_waitarr.shift(), _val);
  }

  var ef = new EF_Spawn(ndata, env, notifyAsync, notifyVal, notifyAborted);

  // pass through control flow exceptions, or return stratum:
  return cont(ef, 0) || stratum;
}
  
//exports.Spawn = makeINCtor(I_spawn);
exports.Spawn = function(...args/*line, exp*/) {
  return {
    exec: I_spawn,
    ndata: args, //[line, exp],
    __oni_dis: token_dis
  }
};

//----------------------------------------------------------------------
// collapse

// structure of ndata array:
#define NDATA_COLLAPSE_LINE() ndata

// continuation index:
// 0: start
// 1: returning from async execution
  
function EF_Collapse(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Collapse.prototype={});
#ifdef EF_TYPES
EF_Collapse.prototype.type = "Collapse";
#endif

// mark us as a collapse frame
EF_Collapse.prototype.__oni_collapse = true;

EF_Collapse.prototype.cont = function(idx, val) {
  if (idx == 0) {
    var fold = this.env.fold;
    if (!fold)
      return new CFException("t", new Error("Unexpected collapse statement"),
                             this.NDATA_COLLAPSE_LINE(), this.env.file);
    if (fold.docollapse(this.env.branch, this))
      return true;
    // else ... we're going async
    this.async = true;
    return this;
  }
  else if (idx == 1) // returning from collapsing
    return this.returnToParent(true);
  else 
    return this.returnToParent(new CFException("t", "Internal error in SJS runtime (collapse)",
                                               this.NDATA_COLLAPSE_LINE(), this.env.file));
};

// don't need to do anything for quenching/aborting. we'll never be prodded by upstream after an abort.
EF_Collapse.prototype.quench = function() {};
EF_Collapse.prototype.abort = function() { this.aborted = true; return new CFException('a')};

function I_collapse(ndata, env) {
  return cont(new EF_Collapse(ndata, env), 0);
}
  
//exports.Collapse = makeINCtor(I_collapse);
exports.Collapse = function(line) {
  return {
    exec: I_collapse,
    ndata: line,
    __oni_dis: token_dis
  }
};
  
//----------------------------------------------------------------------
// builtin strict functions

function dummy() {}

// setTimeout has a minimum delay of 4ms; we want hold(0) to be faster
// see e.g. https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
var hold0, clear0;
// Note: we cannot use process.nextTick, because hold(0) must not stall I/O. 
// It would e.g. break 'require-tests:non-circular reference waits for the full module'
// See also https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
if (exports.G.setImmediate) {
  hold0 = exports.G.setImmediate;
  clear0 = exports.G.clearImmediate;
}
/*
similarly to process.nextTick, this will stall I/O:
else if (false && exports.G.Promise) {
  hold0 = function(cb) { Promise.resolve().then(cb); }
  clear0 = function(id) { }
}
*/
else if (exports.G.postMessage && !exports.G.importScripts) {
  var postMessageIsAsync = true;
  var oldOnMessage = exports.G.onmessage;
  exports.G.onmessage = function() {
    postMessageIsAsync = false;
  };
  exports.G.postMessage("", "*");
  exports.G.onmessage = oldOnMessage;
  if (postMessageIsAsync) {
    // install an event handler on `global` for the `message` event;
    // draws heavily from https://github.com/NobleJS/setImmediate/blob/master/setImmediate.js
    var MESSAGE_PREFIX = "com.onilabs.hold0" + Math.random();

    var tasks = {};

    function onGlobalMessage(event) {
      if (event.source === exports.G && 
          typeof event.data === 'string' &&
          event.data.indexOf(MESSAGE_PREFIX) === 0) {
        var id = event.data.substring(MESSAGE_PREFIX.length);
        var f;
        if ((f = tasks[id])) {
          delete tasks[id];
          f();
        }
      }
    }

    if (exports.G.addEventListener) {
      exports.G.addEventListener("message", onGlobalMessage, false);
    }
    else {
      exports.G.attachEvent("onmessage", onGlobalMessage);
    }

    var id_counter = 1;

    var hold0 = function(f) {
      var id = id_counter++;
      tasks[id] = f;
      exports.G.postMessage(MESSAGE_PREFIX + id, "*");
      return id;
    };
    
    var clear0 = function(id) {
      delete tasks[id];
    };
  }
}

if (!hold0) {
  hold0 = function(co) { return setTimeout(co, 0) };
  clear0 = clearTimeout;
}

exports.Hold = function(duration_ms) {
  var dyn_vars = exports.current_dyn_vars;

  function abort() {
    // restore dyn vars for finally clauses
    exports.current_dyn_vars = dyn_vars;
    return new CFException('a');
  }
  
  if (duration_ms === UNDEF)
    return { 
#ifdef EF_TYPES
             toString: function() { return "<HOLD()>"; },
#endif
             __oni_ef: true,
             wait: function() { return this; },
#ifdef DEBUG_VM
             gatherSuspensionTree: function() { return [this.toString()] },
#endif
             quench: dummy,
             abort: abort
           };

  if (duration_ms === 0) {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD(0)>"; },
#endif
                __oni_ef: true, 
                wait: function() { return this },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
                quench: function() { sus = null; clear0(this.co); },
                co: hold0(function() { 
                  if (sus && sus.parent) {
                    exports.current_dyn_vars = dyn_vars;
                    cont(sus.parent, sus.parent_idx, UNDEF);
                    exports.current_dyn_vars = null;
                  }
                })
              };
    return sus;
  }
  else {
    var sus = { 
#ifdef EF_TYPES
                toString: function() { return "<HOLD("+duration_ms+"ms)>"; },
#endif
                __oni_ef: true,
                wait: function() { return this },
#ifdef DEBUG_VM
                gatherSuspensionTree: function() { return [this.toString()] },
#endif
                abort: abort,
#if defined (CLIENTSIDE) || defined (NODEJS)
                quench: function() { sus = null; clearTimeout(this.co); }
#else
                quench: function() { sus = null; this.co.cancel(); }
#endif
              };
    sus.co = setTimeout(
      function() {
        if (sus && sus.parent) {
          exports.current_dyn_vars = dyn_vars;
          cont(sus.parent, sus.parent_idx, UNDEF);
          exports.current_dyn_vars = null;
        }
      },
      duration_ms);
    return sus;
  }
};

exports.Throw = function(exp, line, file) { return new CFException("t", exp, line, file); };

exports.Arr = function(...args) { return args };

exports.Obj = function(...args) {
  // note comment in kernel-sjs.js.in::ph_obj_lit about the way props
  // are encoded into arguments object
  var obj = new Object();
  for (var i=0; i<args[0].length; ++i)
    obj[args[0][i]] = args[i+1];
  return obj;
};

function QuasiProto(parts) {this.parts=parts;}
exports.QuasiProto = QuasiProto;

exports.Quasi = function(...args) {
  return new QuasiProto(args);
};

exports.Return = function(exp) {
  return new CFException("r", exp);
};

exports.Break = function(lbl) {
  return new CFException("b", lbl);
};

exports.Cont = function(lbl) {
  return new CFException("c", lbl);
};

exports.BlBreak = function(env, lbl) {
  var e = new CFException('blb', lbl);
  if (!env.blbref) throw new Error("Internal runtime error; no reference frame in BlBreak");
  if (env.blbref.unreturnable && !env.blbref.toplevel) // the return scope is not active anymore!
    throw new Error("Blocklambda break to inactive scope");
  e.eid = env.blbref.sid;
  return e;
};

exports.BlReturn = function(exp) {
  var e = new CFException('r', exp);
  if (!this.blrref) throw new Error("Internal runtime error; no reference frame in BlReturn");
  if (this.blrref.unreturnable) { 
    if (this.blrref.toplevel)
      throw new Error("Invalid blocklambda 'return' statement; 'return' is only allowed in blocklambdas that are nested in functions");
    else {
      // return scope not active anymore!
      throw new Error("Blocklambda return to inactive function");
    }
  }
  e.eid = this.blrref.sid;
  return e;
};

exports.With = function(exp, bodyf) {
  return bodyf(this, exp);
};

exports.join_str = function(...args) {
  var rv = '';
  for (var i=0,l=args.length;i<l;++i)
    rv += args[i];
  return rv;
};

exports.infix = {
  '+':   function(a,b) { return a+b; },
  '-':   function(a,b) { return a-b; },
  '*':   function(a,b) { return a*b; },
  '/':   function(a,b) { return a/b; },
  '%':   function(a,b) { return a%b; },
  '<<':  function(a,b) { return a<<b; },
  '>>':  function(a,b) { return a>>b; },
  '>>>': function(a,b) { return a>>>b; },
  '<':   function(a,b) { return a<b; },
  '>':   function(a,b) { return a>b; },
  '<=':  function(a,b) { return a<=b; },
  '>=':  function(a,b) { return a>=b; },
  '==':  function(a,b) { return a==b; },
  '!=':  function(a,b) { return a!=b; },
  '===': function(a,b) { return a===b; },
  '!==': function(a,b) { return a!==b; },
  '&':   function(a,b) { return a&b; },
  '^':   function(a,b) { return a^b; },
  '|':   function(a,b) { return a|b; },
  ',':   function(a,b) { return a,b; },
  'instanceof':
         function(a,b) { return a instanceof b; },
  'in':  function(a,b) { return a in b; }
};

#if defined (CLIENTSIDE)
//----------------------------------------------------------------------
// UA sniffing
var UA = navigator.userAgent.toLowerCase();
if (UA.indexOf(" chrome/") >= 0)
  UA = "chrome";
 else if (UA.indexOf(" firefox/") >= 0)
   UA = "firefox";
 else if (UA.indexOf(" safari/") >= 0)
   UA = "safari";
 else if (UA.indexOf(" msie ") >= 0)
   UA = "msie";
 else
   UA = "unknown";
exports.hostenv = "xbrowser";
#elif defined (NODEJS)
var UA = "nodejs";
exports.hostenv = "nodejs";
#endif
exports.UA = UA;

