#!./apollo
var object = require('sjs:object');
var seq = require('sjs:sequence');
var str = require('sjs:string');
var {waitforEvent} = require('sjs:nodejs/events');
var childProcess = require('sjs:nodejs/child-process');
var rocketPort = 7071;

// provide some sensible defaults
// (only used if not already in process.env)
({
  CHROME_BIN: 'chromium-browser',
  PHANTOMJS_BIN: 'phantomjs',
  ROCKET_HOST: "localhost:#{rocketPort}",
}) .. object.ownPropertyPairs .. seq.each {|prop|
  var [key, val] = prop;
  if (!(key in process.env)) {
    process.env[key] = val;
  }
}

var args = process.argv.slice(1);
var idx = args.indexOf('--');
var leadingArgs = idx == -1 ? args : args.slice(0, idx);
var command = (leadingArgs .. seq.filter(x -> !(x .. str.startsWith('-'))) .. seq.toArray)[0];


var action = function () {
  var child = childProcess.launch('../karma/bin/karma', args, {stdio:'inherit', detached: true, env:process.env});
  waitfor {
    try {
      childProcess.wait(child);
    } retract {
      // karma dies poorly. Usually TERM is enough to kill it, but
      // sometimes it requires a KILL (generally when it can't find a browser)
      // console.log("Killing karma");
      var options = {wait: true, signal:'SIGTERM', detatched: true};
      waitfor {
        childProcess.kill(child, options);
      } or {
        hold(1 * 1000);
        console.log("Waiting for `karma` to exit ... (pid #{child.pid})");
        hold(8 * 1000);
        console.log("Karma still running; sending KILL");
        options.signal = 'SIGKILL';
        childProcess.kill(child, options);
      }
    }
  } or {
    process .. waitforEvent('SIGINT');
  }
}

var rocketCtl = require('./test/lib/rocket_ctrl')
try {
  if (command == 'start') {
    // insert our config file
    args = ['-c', 'tools/karma/conf.js'].concat(args);
    rocketCtl.withRocket(rocketPort, {stdio: 'inherit'}, action);
  } else {
    action();
  }
} catch(e) {
  // console.log(e.message ? e.message : "");
  process.exit(1);
}
